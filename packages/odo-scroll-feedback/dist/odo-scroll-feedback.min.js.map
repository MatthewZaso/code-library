{"version":3,"file":"odo-scroll-feedback.min.js","sources":["../src/scroll-feedback.js"],"sourcesContent":["/**\n * @fileoverview The `ScrollFeedback` class listens for input from the user:\n * mouse, keyboard, touch. Based on the input, the `ScrollFeedback` instance will\n * emit navigation events with a `direction` property signifying which way the\n * user should be taken.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nimport TinyEmitter from 'tiny-emitter';\n\n/*\n * Detect passive event listeners.\n * https://developers.google.com/web/updates/2017/01/scrolling-intervention\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/dom/passiveeventlisteners.js\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n *\n * Weird istanbul ignore:\n * https://github.com/gotwarlost/istanbul/issues/445#issuecomment-150498338\n */\nlet supportsPassiveOption = false;\ntry {\n  window.addEventListener('test', null, {\n    get passive/* istanbul ignore next */() {\n      supportsPassiveOption = true;\n    },\n  });\n} catch (e) { /* continue */ }\n\nconst KeyCodes = {\n  SPACE: 32,\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  END: 35,\n  HOME: 36,\n  UP: 38,\n  DOWN: 40,\n};\n\nclass ScrollFeedback extends TinyEmitter {\n  constructor(element, options) {\n    super();\n\n    this.element = element;\n\n    this.options = Object.assign({}, ScrollFeedback.Defaults, options);\n    this._listenerOptions = ScrollFeedback.PASSIVE_LISTENERS ? { passive: false } : false;\n\n    this.canScroll = true;\n    this._isUserPaused = false;\n    this.wheelTimeout = null;\n    this.scrollTimeout = null;\n    this.wheelAmount = { x: 0, y: 0 };\n    this.startPosition = { x: 0, y: 0 };\n\n    this._handleWheel = this._handleWheel.bind(this);\n    this._handleKeydown = this._handleKeydown.bind(this);\n    this._handleTouchStart = this._handleTouchStart.bind(this);\n    this._handleTouchMove = this._handleTouchMove.bind(this);\n    this._resume = this._resume.bind(this);\n    this._handleScrollTimerExpired = this._handleScrollTimerExpired.bind(this);\n    this._handleScrollEnd = this._handleScrollEnd.bind(this);\n\n    this.enable();\n  }\n\n  /**\n   * Enable the scroll feedback instance by adding event listeners.\n   */\n  enable() {\n    // `wheel` is the standard, but Safari<8 only supports `mousewheel`.\n    // IE9+, Chrome, Firefox, Opera all use `wheel`.\n    this.element.addEventListener('wheel', this._handleWheel, this._listenerOptions);\n    this.element.addEventListener('mousewheel', this._handleWheel, this._listenerOptions);\n\n    // Use the arrow keys to navigate next and previous as well.\n    document.addEventListener('keydown', this._handleKeydown, this._listenerOptions);\n\n    // Prevent touch events from scrolling the page. They need to be interpreted.\n    document.body.addEventListener('touchstart', this._handleTouchStart, this._listenerOptions);\n    document.body.addEventListener('touchmove', this._handleTouchMove, this._listenerOptions);\n    document.body.addEventListener('touchend', this._resume, this._listenerOptions);\n  }\n\n  /**\n   * Disable the instance by removing event listeners.\n   */\n  disable() {\n    this.element.removeEventListener('wheel', this._handleWheel, this._listenerOptions);\n    this.element.removeEventListener('mousewheel', this._handleWheel, this._listenerOptions);\n\n    document.removeEventListener('keydown', this._handleKeydown, this._listenerOptions);\n\n    document.body.removeEventListener('touchstart', this._handleTouchStart, this._listenerOptions);\n    document.body.removeEventListener('touchmove', this._touchmoveHandler, this._listenerOptions);\n    document.body.removeEventListener('touchend', this._resume, this._listenerOptions);\n  }\n\n  /**\n   * Mouse wheel event. The cross-browser code is from iScroll 5.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleWheel(evt) {\n    if (this._shouldIgnoreEvent(evt.target)) {\n      return;\n    }\n\n    if (this.canScroll) {\n      clearTimeout(this.scrollTimeout);\n      this.scrollTimeout = setTimeout(this._handleScrollTimerExpired,\n        this.options.scrollTimerDelay);\n\n      if (this._intentToNavigate(this.wheelAmount)) {\n        this._triggerNavigation(this.wheelAmount);\n        this._pause();\n      }\n    }\n\n    // Execute the scrollEnd event after 300ms the wheel stopped scrolling\n    clearTimeout(this.wheelTimeout);\n    this.wheelTimeout = setTimeout(this._handleScrollEnd, this.options.scrollEndDelay);\n\n    // Wheeling amount since the last wheel event.\n    const { x, y } = this._getWheelDelta(evt);\n\n    // Using prevent default all the time stops the swipe-to-go-back on the\n    // magic mouse (and probably others). Only prevent the default if there is\n    // no vertical movement and some horizontal movement.\n    if (!(y === 0 && Math.abs(x) > 0)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n    }\n\n    // Keep a running total of the amount in each direction.\n    this.wheelAmount.x += x;\n    this.wheelAmount.y += y;\n  }\n\n  /**\n   * Before navigating, this function determines if the user has scrolled past\n   * the wheel threshold constant and that they have scrolled more Y (vertical)\n   * than X (horizontal).\n   * @param {{x: number, y: number}} delta Amount moved since last movement.\n   */\n  _intentToNavigate(delta) {\n    const absY = Math.abs(delta.y);\n    const absX = Math.abs(delta.x);\n\n    return absY > this.options.movementThreshold && absY > absX;\n  }\n\n  /**\n   * Trigger the navigation, after it's been determined the user's\n   * intent was to navigate.\n   */\n  _triggerNavigation(delta) {\n    const direction = delta.y < 0 ?\n      ScrollFeedback.Direction.NEXT :\n      ScrollFeedback.Direction.PREVIOUS;\n    this.navigate(direction);\n  }\n\n  /**\n   * Scroll events stopped firing. Reset some things and notify.\n   * @private\n   */\n  _handleScrollEnd() {\n    clearTimeout(this.scrollTimeout);\n    this.wheelTimeout = null;\n    this._resume();\n    this.emit(ScrollFeedback.Events.SCROLL_END);\n    this.wheelAmount = {\n      x: 0,\n      y: 0,\n    };\n  }\n\n  /**\n   * The scroll timer starts when the first intent to navigate is called. If the\n   * user keeps scrolling the page, this timer will expire and trigger the scroll\n   * end event to happen.\n   */\n  _handleScrollTimerExpired() {\n    clearTimeout(this.wheelTimeout);\n    this._handleScrollEnd();\n  }\n\n  /**\n   * Event listener for key down. If a special key is pressed, this class will\n   * emit an event with the direction the page should go.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleKeydown(evt) {\n    let direction = null;\n\n    switch (evt.which) {\n\n      // Up and page up.\n      // Falls through\n      case KeyCodes.UP:\n      case KeyCodes.PAGE_UP:\n        direction = ScrollFeedback.Direction.PREVIOUS;\n        break;\n\n      // Down arrow and page down.\n      // Falls through\n      case KeyCodes.DOWN:\n      case KeyCodes.PAGE_DOWN:\n        direction = ScrollFeedback.Direction.NEXT;\n        break;\n\n      // Space bar normally scrolls the page down, advance to the next\n      // waypoint on spacebar press. Holding shift and pressing space scrolls\n      // the page up.\n      case KeyCodes.SPACE:\n        if (evt.shiftKey) {\n          direction = ScrollFeedback.Direction.PREVIOUS;\n        } else {\n          direction = ScrollFeedback.Direction.NEXT;\n        }\n\n        break;\n\n      case KeyCodes.HOME:\n        direction = ScrollFeedback.Direction.START;\n        break;\n\n      case KeyCodes.END:\n        direction = ScrollFeedback.Direction.END;\n        break;\n\n      // no default\n    }\n\n    if (direction) {\n      // Stop up and down from scrolling the page.\n      evt.preventDefault();\n      evt.stopPropagation();\n\n      if (this.canScroll) {\n        this.navigate(direction);\n      }\n    }\n  }\n\n  /**\n   * Save the starting position of the user's finger on touch start.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleTouchStart(evt) {\n    this.startPosition = {\n      x: evt.changedTouches[0].pageX,\n      y: evt.changedTouches[0].pageY,\n    };\n  }\n\n  /**\n   * Emits a navigation event if the user has moved their finger far enough.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleTouchMove(evt) {\n    if (this._shouldIgnoreEvent(evt.target)) {\n      return;\n    }\n\n    if (!this.canScroll) {\n      evt.preventDefault();\n      return;\n    }\n\n    const pos = {\n      x: evt.changedTouches[0].pageX,\n      y: evt.changedTouches[0].pageY,\n    };\n\n    const delta = {\n      x: pos.x - this.startPosition.x,\n      y: pos.y - this.startPosition.y,\n    };\n\n    if (this._intentToNavigate(delta)) {\n      evt.preventDefault();\n      this._triggerNavigation(delta);\n      this._pause();\n    }\n  }\n\n  /**\n   * Calculate the amount of wheeling since the last wheel event.\n   *\n   * Info on deltaMode in Firefox https://github.com/cubiq/iscroll/issues/577\n   * Wheel event on MDN https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n   *\n   * @param {WheelEvent} e Event object.\n   * @return {{x: number, y: number}}\n   * @private\n   */\n  _getWheelDelta(e) {\n    let wheelDeltaX;\n    let wheelDeltaY;\n\n    // Normalize the wheel delta value.\n    if ('deltaX' in e) {\n      // deltaMode can be three different values: pixels, lines, or pages. 0, 1, or 2.\n      if (e.deltaMode === 1) {\n        wheelDeltaX = -e.deltaX * ScrollFeedback.MOUSE_WHEEL_SPEED;\n        wheelDeltaY = -e.deltaY * ScrollFeedback.MOUSE_WHEEL_SPEED;\n      } else {\n        wheelDeltaX = -e.deltaX;\n        wheelDeltaY = -e.deltaY;\n      }\n\n      // Support Safari<8\n    } else if ('wheelDeltaX' in e) {\n      wheelDeltaX = e.wheelDeltaX / 120 * ScrollFeedback.MOUSE_WHEEL_SPEED;\n      wheelDeltaY = e.wheelDeltaY / 120 * ScrollFeedback.MOUSE_WHEEL_SPEED;\n    }\n\n    return {\n      x: wheelDeltaX,\n      y: wheelDeltaY,\n    };\n  }\n\n  /**\n   * If the element which received the touch move event is one which should\n   * be ignored, exit immidiately.\n   * @param {Element} element Element to test.\n   * @return {boolean} Whether to ignore the event or not.\n   */\n  _shouldIgnoreEvent(element) {\n    return !!this.options.ignore && element.closest(this.options.ignore) !== null;\n  }\n\n  /**\n   * Emits a NAVIGATE event with a direction.\n   * @param {ScrollFeedback.Direction} direction Direction to navigate.\n   */\n  navigate(direction) {\n    this.emit(ScrollFeedback.Events.NAVIGATE, {\n      direction,\n    });\n  }\n\n  /**\n   * Scroll and touch events will not be counted as input.\n   */\n  _pause() {\n    this.canScroll = false;\n  }\n\n  /**\n   * Only set the can scroll flag to true when the user of this component has\n   * not paused it.\n   */\n  _resume() {\n    if (!this._isUserPaused) {\n      this.canScroll = true;\n    }\n  }\n\n  /**\n   * Scroll and touch events will not be counted as input.\n   */\n  pause() {\n    this._isUserPaused = true;\n    this._pause();\n  }\n\n  /**\n   * Counts scrolls and touch events as inputs.\n   */\n  resume() {\n    this._isUserPaused = false;\n    this._resume();\n  }\n\n  /**\n   * Remove DOM references and event handlers.\n   */\n  dispose() {\n    clearTimeout(this.scrollTimeout);\n    clearTimeout(this.wheelTimeout);\n    this.disable();\n    this.element = null;\n  }\n}\n\n/** @enum {string} */\nScrollFeedback.Events = {\n  NAVIGATE: 'odoscrollfeedback:navigate',\n  SCROLL_END: 'odoscrollfeedback:scrollend',\n};\n\n/** @enum {number} */\nScrollFeedback.Direction = {\n  START: 1,\n  PREVIOUS: 2,\n  NEXT: 3,\n  END: 4,\n};\n\n/**\n * Options which can be overriden for the input handler.\n * @type {Object}\n */\nScrollFeedback.Defaults = {\n  ignore: null, // A selector string matching elements which should not be interpreted\n  movementThreshold: 5, // Amount needed in deltaY (touch or mouse wheel) before event is emitted.\n  scrollEndDelay: 350, // The amount of time between scrolls to trigger scroll end\n  scrollTimerDelay: 2000, // Delay before one continuous scroll triggers scroll end\n};\n\nScrollFeedback.MOUSE_WHEEL_SPEED = 20;\n\nScrollFeedback.PASSIVE_LISTENERS = supportsPassiveOption;\n\nexport default ScrollFeedback;\n"],"names":["supportsPassiveOption","addEventListener","e","KeyCodes","ScrollFeedback","element","options","_TinyEmitter","Object","assign","Defaults","_listenerOptions","PASSIVE_LISTENERS","passive","canScroll","_isUserPaused","wheelTimeout","scrollTimeout","wheelAmount","x","y","startPosition","_handleWheel","_this","bind","_handleKeydown","_handleTouchStart","_handleTouchMove","_resume","_handleScrollTimerExpired","_handleScrollEnd","enable","this","body","disable","removeEventListener","_touchmoveHandler","evt","_shouldIgnoreEvent","target","setTimeout","scrollTimerDelay","_intentToNavigate","_triggerNavigation","_pause","scrollEndDelay","_getWheelDelta","Math","abs","preventDefault","stopPropagation","delta","absY","absX","movementThreshold","direction","Direction","NEXT","PREVIOUS","navigate","emit","Events","SCROLL_END","which","UP","PAGE_UP","DOWN","PAGE_DOWN","SPACE","shiftKey","HOME","START","END","changedTouches","pageX","pageY","pos","wheelDeltaX","wheelDeltaY","deltaMode","deltaX","MOUSE_WHEEL_SPEED","deltaY","ignore","closest","NAVIGATE","pause","resume","dispose","TinyEmitter"],"mappings":"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"}