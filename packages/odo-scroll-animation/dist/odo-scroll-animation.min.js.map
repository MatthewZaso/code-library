{"version":3,"file":"odo-scroll-animation.min.js","sources":["../src/scroll-animation.js"],"sourcesContent":["/**\n * @fileoverview A service for adding a scroll listener to a target (like the\n * page or a modal) and receiving a callback which is throttled to once per frame\n * using requestAnimationFrame. If the scroll event is dispatched more than once\n * in one frame, the service cancels the previous request and makes a new one.\n * It will only bind one scroll event listener per target, no matter the number\n * of callbacks associated with it.\n *\n * @author Glen Cheney\n */\n\nlet id = 0;\nfunction uniqueId() {\n  id += 1;\n  return `sa_${id}`;\n}\n\nfunction isWindow(obj) {\n  return obj && obj.window && obj.document && obj.location && obj.alert && obj.setInterval;\n}\n\nfunction isDocument(obj) {\n  return obj && obj.nodeType === 9;\n}\n\nconst service = {\n\n  /**\n   * A collection of scroll listeners the service is using.\n   * @type {Map.<string, Object>}\n   * @private\n   */\n  _listeners: new Map(),\n\n  /**\n   * A map of request animation frame ids for each target.\n   * @type {Map.<Element, number>}\n   * @private\n   */\n  _targets: new Map(),\n\n  /**\n   * Finds all listeners registered with the given target element.\n   * @param {Window|Element} element Target element.\n   * @return {Array.<Function>} An array of listener functions.\n   * @private\n   */\n  _getListenersForTarget(element) {\n    const functions = [];\n\n    this._listeners.forEach((obj) => {\n      if (obj.target === element) {\n        functions.push(obj.fn);\n      }\n    });\n\n    return functions;\n  },\n\n  /**\n   * The window uses `pageXOffset` and `pageYOffset` while regular elements use\n   * `scrollLeft` and `scrollTop`.\n   * @param {Element|Window} target The element which scrolled.\n   * @return {{top: number, left: number}}\n   * @private\n   */\n  _getScrollPosition(target) {\n    let top;\n    let left;\n\n    // If this is a document or window, get the offset from the window.\n    if (isWindow(target)) {\n      // IE9+ have pageYOffset and pageXOffset.\n      top = window.pageYOffset;\n      left = window.pageXOffset;\n    } else {\n      top = target.scrollTop;\n      left = target.scrollLeft;\n    }\n\n    return {\n      top,\n      left,\n    };\n  },\n\n  /**\n   * Calls all handlers for a give target with the target's new scroll top\n   * value.\n   * @param {Element} target Element which was scrolled.\n   * @private\n   */\n  _callListeners(target) {\n    const scroll = this._getScrollPosition(target);\n\n    // Find all listeners tied to the element which is currently scrolling.\n    const listeners = this._getListenersForTarget(target);\n    for (let i = 0, len = listeners.length; i < len; i++) {\n      listeners[i](scroll.top, scroll.left);\n    }\n\n    // Remove the request id, meaning this request has finished.\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Handles scroll events on an element. It uses request animation frame\n   * to execute the real handlers only once per frame.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleTargetScrolled(evt) {\n    const target = evt.currentTarget;\n\n    // Cancel the last request animation frame if it hasn't executed yet.\n    if (this._targets.get(target)) {\n      cancelAnimationFrame(this._targets.get(target));\n    }\n\n    // Request a new animation frame.\n    const requestId = requestAnimationFrame(this._callListeners.bind(this, target));\n    this._targets.set(target, requestId);\n  },\n\n  /**\n   * Adds a scroll listener to a target.\n   * @param {Element} target Element.\n   * @private\n   */\n  _register(target) {\n    target.addEventListener('scroll', this._onScroll, false);\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Remove the scroll listener and target from the map.\n   * @param {Element} target Target element.\n   * @private\n   */\n  _unregister(target) {\n    target.removeEventListener('scroll', this._onScroll, false);\n    this._targets.delete(target);\n  },\n\n  /**\n   * Add a new scroll listener to an optional target. Defaults to when the\n   * page is scrolled.\n   * @param {Element=} target Optional element. Default = window.\n   * @param {function(number)} fn Callback method with the new scroll top\n   *     value as the first parameter.\n   * @return {string} Id to unbind with.\n   */\n  add(target, fn) {\n    // Assume the window/document should be the scroll target if none is provided.\n    if (typeof target === 'function') {\n      fn = target; // eslint-disable-line no-param-reassign\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    // Attach events to the window instead of the document.\n    if (isDocument(target)) {\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    if (!target || !target.addEventListener) {\n      throw new TypeError(`OdoScrollAnimation: \"${target}\" is not an Element, Document, or Window`);\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError(`OdoScrollAnimation: \"${fn}\" is not a function`);\n    }\n\n    // Check if this target already has a scroll listener.\n    if (!this._targets.has(target)) {\n      this._register(target);\n    }\n\n    const id = uniqueId();\n\n    this._listeners.set(id, {\n      target,\n      fn,\n    });\n\n    return id;\n  },\n\n  /**\n   * Remove a scroll listener by id.\n   * @param {string} id The id returned from adding it.\n   */\n  remove(id) {\n    const listener = this._listeners.get(id);\n    if (listener) {\n      const listeners = this._getListenersForTarget(listener.target);\n\n      // If this listener is the last one listening to this target, unbind\n      // the scroll event from it.\n      if (listeners.length === 1) {\n        this._unregister(listener.target);\n      }\n\n      this._listeners.delete(id);\n    }\n  },\n};\n\n// Proxied functions are different every time they are created. To be able to\n// remove the same handler, the context is bound here instead of inside `add`.\nservice._onScroll = service._handleTargetScrolled.bind(service);\n\nexport default service;\n"],"names":["id","uniqueId","service","Map","element","functions","_listeners","forEach","obj","target","push","fn","top","left","window","document","location","alert","setInterval","pageYOffset","pageXOffset","scrollTop","scrollLeft","scroll","this","_getScrollPosition","listeners","_getListenersForTarget","i","len","length","_targets","set","evt","currentTarget","get","requestId","requestAnimationFrame","_callListeners","bind","addEventListener","_onScroll","removeEventListener","delete","nodeType","TypeError","has","_register","listener","_unregister","_handleTargetScrolled"],"mappings":"8LAWA,IAAIA,EAAK,EACT,SAASC,oBACD,GAYR,IAAMC,cAOQ,IAAIC,aAON,IAAIA,oCAQSC,OACfC,iBAEDC,WAAWC,QAAQ,SAACC,GACnBA,EAAIC,SAAWL,KACPM,KAAKF,EAAIG,MAIhBN,+BAUUI,OAjDHD,EAkDVI,SACAC,gBAnDUL,EAsDDC,IArDDD,EAAIM,QAAUN,EAAIO,UAAYP,EAAIQ,UAAYR,EAAIS,OAAST,EAAIU,eAuDnEJ,OAAOK,cACNL,OAAOM,gBAERX,EAAOY,YACNZ,EAAOa,oDAeHb,WACPc,EAASC,KAAKC,mBAAmBhB,GAGjCiB,EAAYF,KAAKG,uBAAuBlB,GACrCmB,EAAI,EAAGC,EAAMH,EAAUI,OAAQF,EAAIC,EAAKD,MACrCA,GAAGL,EAAOX,IAAKW,EAAOV,WAI7BkB,SAASC,IAAIvB,EAAQ,sCASNwB,OACdxB,EAASwB,EAAIC,cAGfV,KAAKO,SAASI,IAAI1B,yBACCe,KAAKO,SAASI,IAAI1B,QAInC2B,EAAYC,sBAAsBb,KAAKc,eAAeC,KAAKf,KAAMf,SAClEsB,SAASC,IAAIvB,EAAQ2B,uBAQlB3B,KACD+B,iBAAiB,SAAUhB,KAAKiB,WAAW,QAC7CV,SAASC,IAAIvB,EAAQ,4BAQhBA,KACHiC,oBAAoB,SAAUlB,KAAKiB,WAAW,QAChDV,SAASY,OAAOlC,iBAWnBA,EAAQE,GAnId,IAAoBH,KAqIM,mBAAXC,MACJA,IACIK,SAvIKN,EA2IDC,IA1Ic,IAAjBD,EAAIoC,aA2IL9B,SAGNL,IAAWA,EAAO+B,uBACf,IAAIK,kCAAkCpC,iDAG5B,mBAAPE,QACH,IAAIkC,kCAAkClC,yBAIzCa,KAAKO,SAASe,IAAIrC,SAChBsC,UAAUtC,OAGXT,EAAKC,gBAENK,WAAW0B,IAAIhC,mBAKbA,mBAOFA,OACCgD,EAAWxB,KAAKlB,WAAW6B,IAAInC,GACjCgD,IAKuB,IAJPxB,KAAKG,uBAAuBqB,EAASvC,QAIzCqB,aACPmB,YAAYD,EAASvC,aAGvBH,WAAWqC,OAAO3C,aAO7BE,EAAQuC,UAAYvC,EAAQgD,sBAAsBX,KAAKrC"}