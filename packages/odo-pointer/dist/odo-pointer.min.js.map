{"version":3,"file":"odo-pointer.min.js","sources":["../src/pointer-event.js","../src/settings.js","../src/pointer.js"],"sourcesContent":["import { Coordinate } from '@odopod/odo-helpers';\nimport settings from './settings';\n\nfunction isXAxis(axis) {\n  return axis === settings.Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === settings.Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === settings.Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== settings.Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new Coordinate(\n    finiteOrZero(deltaX / deltaTime),\n    finiteOrZero(deltaY / deltaTime),\n  );\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(\n      coord1.x, coord2.x, settings.Direction.LEFT,\n      settings.Direction.RIGHT, settings.Direction.NONE,\n    );\n  }\n\n  return getTheDirection(\n    coord1.y, coord2.y, settings.Direction.UP,\n    settings.Direction.DOWN, settings.Direction.NONE,\n  );\n}\n\nfunction isOnAxis(axis, direction) {\n  const isXAndLeftOrRight = isXAxis(axis) && (\n    direction === settings.Direction.LEFT ||\n    direction === settings.Direction.RIGHT);\n\n  const isYAndUpOrDown = isYAxis(axis) && (\n    direction === settings.Direction.UP ||\n    direction === settings.Direction.DOWN);\n\n  const isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return (isXAxis(axis) && Math.abs(deltaX) > 0) ||\n\n  // Y axis and deltaY > 0\n  (isYAxis(axis) && Math.abs(deltaY) > 0) ||\n\n  // Both axis, as long as it actually moved.\n  (isBothAxis(axis) && hasDirection(direction));\n}\n\nfunction getAxisDirection(axis, start, end) {\n  const _start = Object.assign({}, start);\n  const _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nclass PointerEvent {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  constructor(options) {\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = Coordinate.distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {settings.Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(\n      options.axis, this.direction,\n      this.delta.x, this.delta.y,\n    );\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {settings.Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default PointerEvent;\n","import OdoDevice from '@odopod/odo-device';\n\nexport default {\n  /** @enum {string} */\n  EventType: {\n    START: 'odopointer:start',\n    MOVE: 'odopointer:move',\n    END: 'odopointer:end',\n  },\n\n  /** @enum {string} */\n  Direction: {\n    RIGHT: 'right',\n    LEFT: 'left',\n    UP: 'up',\n    DOWN: 'down',\n    NONE: 'no_movement',\n  },\n\n  /** @enum {string|boolean} */\n  TouchActionSupport: {\n    x: OdoDevice.prefixed('touchAction', 'pan-y'),\n    y: OdoDevice.prefixed('touchAction', 'pan-x'),\n    xy: OdoDevice.prefixed('touchAction', 'none'),\n  },\n\n  /** @enum {string} */\n  TouchAction: {\n    x: 'pan-y',\n    y: 'pan-x',\n    xy: 'none',\n  },\n\n  /** @enum {string} */\n  Axis: {\n    X: 'x',\n    Y: 'y',\n    BOTH: 'xy',\n  },\n\n  Defaults: {\n    axis: 'xy',\n    preventEventDefault: true,\n  },\n\n  /**\n   * The current velocity property will be clamped to this value (pixels/millisecond).\n   * @const {number}\n   */\n  MAX_VELOCITY: 12,\n\n  /**\n   * When the pointer is down, an interval starts to track the current velocity.\n   * @const {number}\n   */\n  VELOCITY_INTERVAL: 100,\n\n  /**\n   * Velocity required for a movement to be considered a swipe.\n   * @const {number}\n   */\n  SWIPE_VELOCITY: 0.6,\n\n  /**\n   * The scroll/drag amount (pixels) required on the draggable axis before\n   * stopping further page scrolling/movement.\n   * @const {number}\n   */\n  LOCK_THRESHOLD: 6,\n\n  /**\n   * The scroll/drag amount (pixels) required on the opposite draggable axis\n   * before dragging is deactivated for the rest of the interaction.\n   * @const {number}\n   */\n  DRAG_THRESHOLD: 5,\n};\n","/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport { Coordinate, events, math, utilities } from '@odopod/odo-helpers';\nimport settings from './settings';\nimport PointerEvent from './pointer-event';\n\nclass Pointer extends TinyEmitter {\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {Element} element Element to watch.\n   * @param {Object} options Options object.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    const opts = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * Whether to prevent the default event action on move.\n     * @type {boolean}\n     * @private\n     */\n    this._shouldPreventDefault = opts.preventEventDefault;\n\n    /**\n     * The draggable element.\n     * @type {Element}\n     * @private\n     */\n    this._el = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    this.pageStart = new Coordinate();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    this.page = new Coordinate();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    this.delta = new Coordinate();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    this._lastPosition = new Coordinate();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    this._friction = 1;\n\n    /**\n     * Draggable axis.\n     * @type {string}\n     * @private\n     */\n    this.axis = opts.axis;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    this.velocity = new Coordinate();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    this.dragEventTarget = document;\n\n    const touchAction = Pointer.TouchActionSupport[this.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (this._shouldPreventDefault && this._isTouchActionSupported) {\n      this.element.style[touchAction] = Pointer.TouchAction[this.axis];\n    } else if (this._shouldPreventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.addEventListener(events.TOUCHMOVE, utilities.noop);\n    }\n\n    this.listen();\n  }\n\n  listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (OdoDevice.HAS_POINTER_EVENTS) {\n      this._el.addEventListener(events.POINTERDOWN, this._onStart);\n    } else {\n      this._el.addEventListener(events.MOUSEDOWN, this._onStart);\n\n      if (OdoDevice.HAS_TOUCH_EVENTS) {\n        this._el.addEventListener(events.TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this._el.addEventListener(events.DRAGSTART, Pointer._preventDefault);\n  }\n\n  /**\n   * Returns the draggable element.\n   * @return {Element}\n   */\n  get element() {\n    return this._el;\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  isXAxis() {\n    return this.axis === Pointer.Axis.X;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n  isYAxis() {\n    return this.axis === Pointer.Axis.Y;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n  isBothAxis() {\n    return this.axis === Pointer.Axis.BOTH;\n  }\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n  get friction() {\n    return this._friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this._friction = friction;\n  }\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  }\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  }\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n  _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  }\n\n  /**\n   * Drag start handler.\n   * @param  {Event} evt The drag event object.\n   * @private\n   */\n  _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(\n        this._trackVelocity.bind(this),\n        Pointer.VELOCITY_INTERVAL,\n      );\n    }\n  }\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {Event} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this._shouldPreventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  }\n\n  /**\n   * Finish the drag move function.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    const endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    const isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  }\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new Coordinate();\n    this.velocity = new Coordinate();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  }\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    const lastDelta = Coordinate.difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  }\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n  _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  }\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n  _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n  _shouldLock(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n  _shouldDeactivate(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!PointerEvent}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new Pointer.Event({\n      type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity,\n    });\n  }\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n  _addDragHandlers(startType) {\n    const target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case events.POINTERDOWN:\n        target.addEventListener(events.POINTERMOVE, this._onMove);\n        target.addEventListener(events.POINTERUP, this._onEnd);\n        target.addEventListener(events.POINTERCANCEL, this._onEnd);\n        break;\n      case events.MOUSEDOWN:\n        target.addEventListener(events.MOUSEMOVE, this._onMove);\n        target.addEventListener(events.MOUSEUP, this._onEnd);\n        break;\n      case events.TOUCHSTART:\n        target.addEventListener(events.TOUCHMOVE, this._onMove);\n        target.addEventListener(events.TOUCHEND, this._onEnd);\n        target.addEventListener(events.TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  }\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n  _removeDragHandlers() {\n    const target = this.dragEventTarget;\n    target.removeEventListener(events.POINTERMOVE, this._onMove);\n    target.removeEventListener(events.POINTERUP, this._onEnd);\n    target.removeEventListener(events.POINTERCANCEL, this._onEnd);\n    target.removeEventListener(events.MOUSEMOVE, this._onMove);\n    target.removeEventListener(events.MOUSEUP, this._onEnd);\n    target.removeEventListener(events.TOUCHMOVE, this._onMove);\n    target.removeEventListener(events.TOUCHEND, this._onEnd);\n    target.removeEventListener(events.TOUCHCANCEL, this._onEnd);\n  }\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n  _trackVelocity() {\n    const now = Date.now();\n    const elapsed = now - this._lastTime;\n    const delta = Coordinate.difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    const maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = math.clamp(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = math.clamp(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  }\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n  hasVelocity(velocity, threshold = Pointer.SWIPE_VELOCITY) {\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Remove event listeners and element references.\n   */\n  dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this._el.removeEventListener(events.POINTERDOWN, this._onStart);\n    this._el.removeEventListener(events.MOUSEDOWN, this._onStart);\n    this._el.removeEventListener(events.TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this._el.style[Pointer.TouchActionSupport[this.axis]] = '';\n    } else if (this._shouldPreventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.removeEventListener(events.TOUCHMOVE, utilities.noop);\n    }\n\n    this._el = null;\n    this.dragEventTarget = null;\n  }\n\n  /**\n   * Whether the event is from a touch.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   */\n  static isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  }\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  static _isCancelEvent(evt) {\n    return evt.type === events.POINTERCANCEL || evt.type === events.TOUCHCANCEL;\n  }\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {Event} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n  static _getPageCoordinate(evt) {\n    let pagePoints;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new Coordinate(pagePoints.pageX, pagePoints.pageY);\n  }\n\n  static _preventDefault(evt) {\n    evt.preventDefault();\n  }\n}\n\nObject.assign(Pointer, settings);\n\n/** @type {PointerEvent} */\nPointer.Event = PointerEvent;\n\nexport default Pointer;\n"],"names":["isXAxis","axis","settings","Axis","X","isYAxis","Y","isBothAxis","BOTH","hasDirection","direction","Direction","NONE","finiteOrZero","velocity","Number","isFinite","getTheDirection","value1","value2","isGreater","isLess","isEqual","getDirection","coord1","coord2","Math","abs","x","y","LEFT","RIGHT","UP","DOWN","prefixed","OdoDevice","PointerEvent","options","type","target","currentTarget","start","end","delta","deltaTime","deltaX","deltaY","Coordinate","getVelocity","this","currentVelocity","distance","isDirectionOnAxis","isXAndLeftOrRight","isYAndUpOrDown","isBothAndNotNone","isOnAxis","didMoveOnAxis","axisDirection","_start","Object","assign","_end","getAxisDirection","position","defaultPrevented","preventDefault","Pointer","element","_TinyEmitter","nodeType","TypeError","opts","Defaults","_shouldPreventDefault","preventEventDefault","_el","pageStart","page","_lastPosition","_friction","hasDragged","_isLocked","_isDeactivated","_enabled","_velocityTrackerId","startTime","_lastTime","_hasTrackedVelocity","dragEventTarget","document","touchAction","TouchActionSupport","_this","_isTouchActionSupported","style","TouchAction","HAS_TOUCH_EVENTS","addEventListener","events","TOUCHMOVE","utilities","noop","listen","_onStart","_handleDragStart","bind","HAS_POINTER_EVENTS","POINTERDOWN","MOUSEDOWN","TOUCHSTART","DRAGSTART","_preventDefault","applyFriction","coordinate","scale","friction","_canStartDrag","evt","isEnabled","isTouchEvent","button","_canContinueDrag","_setDragStartValues","_getPageCoordinate","_emitEvent","_createEvent","EventType","START","_addDragHandlers","setInterval","_trackVelocity","VELOCITY_INTERVAL","_handleDragMove","_setDragMoveValues","MOVE","_finishDragMove","_maybeLock","_maybeDeactivate","_handleDragEnd","Date","now","_removeDragHandlers","endEvent","END","isCancelEvent","_isCancelEvent","pagePosition","lastDelta","difference","translate","_shouldLock","_shouldDeactivate","pastX","LOCK_THRESHOLD","pastY","DRAG_THRESHOLD","Event","id","startType","_onMove","_onEnd","POINTERMOVE","POINTERUP","POINTERCANCEL","MOUSEMOVE","MOUSEUP","TOUCHEND","TOUCHCANCEL","removeEventListener","elapsed","maxVelocity","MAX_VELOCITY","math","clamp","hasVelocity","threshold","SWIPE_VELOCITY","event","emit","dispose","changedTouches","pagePoints","pageX","pageY","enabled","TinyEmitter"],"mappings":"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"}