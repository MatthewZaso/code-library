{"version":3,"file":"odo-pointer.min.js","sources":["../src/settings.js","../src/pointer-event.js","../src/pointer.js"],"sourcesContent":["/** @enum {string} */\nexport const Direction = {\n  RIGHT: 'right',\n  LEFT: 'left',\n  UP: 'up',\n  DOWN: 'down',\n  NONE: 'no_movement',\n};\n\n/** @enum {string} */\nexport const Axis = {\n  X: 'x',\n  Y: 'y',\n  BOTH: 'xy',\n};\n","import { Coordinate } from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\n\nfunction isXAxis(axis) {\n  return axis === Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new Coordinate(\n    finiteOrZero(deltaX / deltaTime),\n    finiteOrZero(deltaY / deltaTime),\n  );\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(\n      coord1.x, coord2.x, Direction.LEFT,\n      Direction.RIGHT, Direction.NONE,\n    );\n  }\n\n  return getTheDirection(\n    coord1.y, coord2.y, Direction.UP,\n    Direction.DOWN, Direction.NONE,\n  );\n}\n\nfunction isOnAxis(axis, direction) {\n  const isXAndLeftOrRight = isXAxis(axis) && (\n    direction === Direction.LEFT ||\n    direction === Direction.RIGHT);\n\n  const isYAndUpOrDown = isYAxis(axis) && (\n    direction === Direction.UP ||\n    direction === Direction.DOWN);\n\n  const isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return (isXAxis(axis) && Math.abs(deltaX) > 0) ||\n\n  // Y axis and deltaY > 0\n  (isYAxis(axis) && Math.abs(deltaY) > 0) ||\n\n  // Both axis, as long as it actually moved.\n  (isBothAxis(axis) && hasDirection(direction));\n}\n\nfunction getAxisDirection(axis, start, end) {\n  const _start = Object.assign({}, start);\n  const _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nclass PointerEvent {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  constructor(options) {\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = Coordinate.distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(\n      options.axis, this.direction,\n      this.delta.x, this.delta.y,\n    );\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default PointerEvent;\n","/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport {\n  clamp,\n  Coordinate,\n  events,\n  noop,\n} from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\nimport _PointerEvent from './pointer-event';\n\nclass Pointer extends TinyEmitter {\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {HTMLElement} element Element to watch.\n   * @param {PointerOptions} options Options object.\n   * @throws {TypeError} Throws when the element parameter isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    /**\n     * @type {PointerOptions}\n     */\n    this.options = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * The draggable element.\n     * @type {HTMLElement}\n     * @private\n     */\n    this.element = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    this.pageStart = new Coordinate();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    this.page = new Coordinate();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    this.delta = new Coordinate();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    this._lastPosition = new Coordinate();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    this._friction = 1;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    this.velocity = new Coordinate();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    this.dragEventTarget = document;\n\n    const touchAction = Pointer.TouchActionSupport[this.options.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (this.options.preventEventDefault && this._isTouchActionSupported) {\n      this.element.style[touchAction] = Pointer.TouchAction[this.options.axis];\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.addEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.listen();\n  }\n\n  listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (OdoDevice.HAS_POINTER_EVENTS) {\n      this.element.addEventListener(events.POINTERDOWN, this._onStart);\n    } else {\n      this.element.addEventListener(events.MOUSEDOWN, this._onStart);\n\n      if (OdoDevice.HAS_TOUCH_EVENTS) {\n        this.element.addEventListener(events.TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this.element.addEventListener(events.DRAGSTART, Pointer._preventDefault);\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  isXAxis() {\n    return this.options.axis === Pointer.Axis.X;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n  isYAxis() {\n    return this.options.axis === Pointer.Axis.Y;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n  isBothAxis() {\n    return this.options.axis === Pointer.Axis.BOTH;\n  }\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n  get friction() {\n    return this._friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this._friction = friction;\n  }\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  }\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  }\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n  _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  }\n\n  /**\n   * Drag start handler.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The drag event object.\n   * @private\n   */\n  _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(\n        this._trackVelocity.bind(this),\n        Pointer.VELOCITY_INTERVAL,\n      );\n    }\n  }\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this.options.preventEventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  }\n\n  /**\n   * Finish the drag move function.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @private\n   */\n  _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    const endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    const isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  }\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new Coordinate();\n    this.velocity = new Coordinate();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  }\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    const lastDelta = Coordinate.difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  }\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n  _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  }\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n  _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n  _shouldLock(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n  _shouldDeactivate(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!Pointer.Event}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new Pointer.Event({\n      type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.options.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity,\n    });\n  }\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n  _addDragHandlers(startType) {\n    const target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case events.POINTERDOWN:\n        target.addEventListener(events.POINTERMOVE, this._onMove);\n        target.addEventListener(events.POINTERUP, this._onEnd);\n        target.addEventListener(events.POINTERCANCEL, this._onEnd);\n        break;\n      case events.MOUSEDOWN:\n        target.addEventListener(events.MOUSEMOVE, this._onMove);\n        target.addEventListener(events.MOUSEUP, this._onEnd);\n        break;\n      case events.TOUCHSTART:\n        target.addEventListener(events.TOUCHMOVE, this._onMove);\n        target.addEventListener(events.TOUCHEND, this._onEnd);\n        target.addEventListener(events.TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  }\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n  _removeDragHandlers() {\n    const target = this.dragEventTarget;\n    target.removeEventListener(events.POINTERMOVE, this._onMove);\n    target.removeEventListener(events.POINTERUP, this._onEnd);\n    target.removeEventListener(events.POINTERCANCEL, this._onEnd);\n    target.removeEventListener(events.MOUSEMOVE, this._onMove);\n    target.removeEventListener(events.MOUSEUP, this._onEnd);\n    target.removeEventListener(events.TOUCHMOVE, this._onMove);\n    target.removeEventListener(events.TOUCHEND, this._onEnd);\n    target.removeEventListener(events.TOUCHCANCEL, this._onEnd);\n  }\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n  _trackVelocity() {\n    const now = Date.now();\n    const elapsed = now - this._lastTime;\n    const delta = Coordinate.difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    const maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = clamp(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = clamp(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  }\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n  hasVelocity(velocity, threshold = Pointer.SWIPE_VELOCITY) {\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Remove event listeners and element references.\n   */\n  dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this.element.removeEventListener(events.POINTERDOWN, this._onStart);\n    this.element.removeEventListener(events.MOUSEDOWN, this._onStart);\n    this.element.removeEventListener(events.TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this.element.style[Pointer.TouchActionSupport[this.options.axis]] = '';\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.removeEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.element = null;\n    this.dragEventTarget = null;\n  }\n\n  /**\n   * Whether the event is from a touch.\n   * @param {object} evt Event object.\n   * @return {boolean}\n   */\n  static isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  }\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  static _isCancelEvent(evt) {\n    return evt.type === events.POINTERCANCEL || evt.type === events.TOUCHCANCEL;\n  }\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n  static _getPageCoordinate(evt) {\n    let pagePoints;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new Coordinate(pagePoints.pageX, pagePoints.pageY);\n  }\n\n  static _preventDefault(evt) {\n    evt.preventDefault();\n  }\n}\n\n/** @enum {string} */\nPointer.Direction = Direction;\n\n/** @enum {string} */\nPointer.Axis = Axis;\n\n/** @enum {string} */\nPointer.EventType = {\n  START: 'odopointer:start',\n  MOVE: 'odopointer:move',\n  END: 'odopointer:end',\n};\n\n/** @enum {string|boolean} */\nPointer.TouchActionSupport = {\n  x: OdoDevice.prefixed('touchAction', 'pan-y'),\n  y: OdoDevice.prefixed('touchAction', 'pan-x'),\n  xy: OdoDevice.prefixed('touchAction', 'none'),\n};\n\n/** @enum {string} */\nPointer.TouchAction = {\n  x: 'pan-y',\n  y: 'pan-x',\n  xy: 'none',\n};\n\n/**\n * @typedef {{axis: Axis, preventEventDefault: boolean}} PointerOptions\n */\n\n/** @type {PointerOptions} */\nPointer.Defaults = {\n  axis: 'xy',\n  preventEventDefault: true,\n};\n\n/**\n * The current velocity property will be clamped to this value (pixels/millisecond).\n * @const {number}\n */\nPointer.MAX_VELOCITY = 12;\n\n/**\n * When the pointer is down, an interval starts to track the current velocity.\n * @const {number}\n */\nPointer.VELOCITY_INTERVAL = 100;\n\n/**\n * Velocity required for a movement to be considered a swipe.\n * @const {number}\n */\nPointer.SWIPE_VELOCITY = 0.6;\n\n/**\n * The scroll/drag amount (pixels) required on the draggable axis before\n * stopping further page scrolling/movement.\n * @const {number}\n */\nPointer.LOCK_THRESHOLD = 6;\n\n/**\n * The scroll/drag amount (pixels) required on the opposite draggable axis\n * before dragging is deactivated for the rest of the interaction.\n * @const {number}\n */\nPointer.DRAG_THRESHOLD = 5;\n\nPointer.Event = _PointerEvent;\n\nexport default Pointer;\n"],"names":["Direction","Axis","isXAxis","axis","X","isYAxis","Y","isBothAxis","BOTH","hasDirection","direction","NONE","finiteOrZero","velocity","Number","isFinite","getTheDirection","value1","value2","isGreater","isLess","isEqual","getDirection","coord1","coord2","Math","abs","x","y","LEFT","RIGHT","UP","DOWN","PointerEvent","options","deltaTime","deltaX","deltaY","isXAndLeftOrRight","isYAndUpOrDown","isBothAndNotNone","type","target","currentTarget","start","end","delta","this","Coordinate","currentVelocity","distance","isDirectionOnAxis","didMoveOnAxis","axisDirection","_start","Object","assign","_end","getAxisDirection","position","defaultPrevented","preventDefault","Pointer","element","_TinyEmitter","nodeType","TypeError","Defaults","pageStart","page","_lastPosition","_friction","hasDragged","_isLocked","_isDeactivated","_enabled","_velocityTrackerId","startTime","_lastTime","_hasTrackedVelocity","dragEventTarget","document","touchAction","TouchActionSupport","_this","_isTouchActionSupported","preventEventDefault","style","TouchAction","OdoDevice","HAS_TOUCH_EVENTS","addEventListener","events","TOUCHMOVE","noop","listen","_onStart","_handleDragStart","bind","HAS_POINTER_EVENTS","POINTERDOWN","MOUSEDOWN","TOUCHSTART","DRAGSTART","_preventDefault","applyFriction","coordinate","scale","friction","_canStartDrag","evt","isEnabled","isTouchEvent","button","_canContinueDrag","_setDragStartValues","_getPageCoordinate","_emitEvent","_createEvent","EventType","START","_addDragHandlers","setInterval","_trackVelocity","VELOCITY_INTERVAL","_handleDragMove","_setDragMoveValues","MOVE","_finishDragMove","_maybeLock","_maybeDeactivate","_handleDragEnd","Date","now","_removeDragHandlers","endEvent","END","isCancelEvent","_isCancelEvent","pagePosition","lastDelta","difference","translate","_shouldLock","_shouldDeactivate","pastX","LOCK_THRESHOLD","pastY","DRAG_THRESHOLD","Event","id","startType","_onMove","_onEnd","POINTERMOVE","POINTERUP","POINTERCANCEL","MOUSEMOVE","MOUSEUP","TOUCHEND","TOUCHCANCEL","removeEventListener","elapsed","maxVelocity","MAX_VELOCITY","clamp","hasVelocity","threshold","SWIPE_VELOCITY","event","emit","dispose","changedTouches","pagePoints","pageX","pageY","enabled","TinyEmitter","prefixed","_PointerEvent"],"mappings":"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"}