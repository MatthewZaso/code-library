{"version":3,"file":"odo-pointer.js","sources":["../src/settings.js","../src/pointer-event.js","../src/pointer.js"],"sourcesContent":["/** @enum {string} */\nexport const Direction = {\n  RIGHT: 'right',\n  LEFT: 'left',\n  UP: 'up',\n  DOWN: 'down',\n  NONE: 'no_movement',\n};\n\n/** @enum {string} */\nexport const Axis = {\n  X: 'x',\n  Y: 'y',\n  BOTH: 'xy',\n};\n","import { Coordinate } from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\n\nfunction isXAxis(axis) {\n  return axis === Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new Coordinate(\n    finiteOrZero(deltaX / deltaTime),\n    finiteOrZero(deltaY / deltaTime),\n  );\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(\n      coord1.x, coord2.x, Direction.LEFT,\n      Direction.RIGHT, Direction.NONE,\n    );\n  }\n\n  return getTheDirection(\n    coord1.y, coord2.y, Direction.UP,\n    Direction.DOWN, Direction.NONE,\n  );\n}\n\nfunction isOnAxis(axis, direction) {\n  const isXAndLeftOrRight = isXAxis(axis) && (\n    direction === Direction.LEFT ||\n    direction === Direction.RIGHT);\n\n  const isYAndUpOrDown = isYAxis(axis) && (\n    direction === Direction.UP ||\n    direction === Direction.DOWN);\n\n  const isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return (isXAxis(axis) && Math.abs(deltaX) > 0) ||\n\n  // Y axis and deltaY > 0\n  (isYAxis(axis) && Math.abs(deltaY) > 0) ||\n\n  // Both axis, as long as it actually moved.\n  (isBothAxis(axis) && hasDirection(direction));\n}\n\nfunction getAxisDirection(axis, start, end) {\n  const _start = Object.assign({}, start);\n  const _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nclass PointerEvent {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  constructor(options) {\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = Coordinate.distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(\n      options.axis, this.direction,\n      this.delta.x, this.delta.y,\n    );\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default PointerEvent;\n","/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport {\n  clamp,\n  Coordinate,\n  events,\n  noop,\n} from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\nimport _PointerEvent from './pointer-event';\n\nclass Pointer extends TinyEmitter {\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {HTMLElement} element Element to watch.\n   * @param {PointerOptions} options Options object.\n   * @throws {TypeError} Throws when the element parameter isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    /**\n     * @type {PointerOptions}\n     */\n    this.options = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * The draggable element.\n     * @type {HTMLElement}\n     * @private\n     */\n    this.element = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    this.pageStart = new Coordinate();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    this.page = new Coordinate();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    this.delta = new Coordinate();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    this._lastPosition = new Coordinate();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    this._friction = 1;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    this.velocity = new Coordinate();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    this.dragEventTarget = document;\n\n    const touchAction = Pointer.TouchActionSupport[this.options.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (this.options.preventEventDefault && this._isTouchActionSupported) {\n      this.element.style[touchAction] = Pointer.TouchAction[this.options.axis];\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.addEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.listen();\n  }\n\n  listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (OdoDevice.HAS_POINTER_EVENTS) {\n      this.element.addEventListener(events.POINTERDOWN, this._onStart);\n    } else {\n      this.element.addEventListener(events.MOUSEDOWN, this._onStart);\n\n      if (OdoDevice.HAS_TOUCH_EVENTS) {\n        this.element.addEventListener(events.TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this.element.addEventListener(events.DRAGSTART, Pointer._preventDefault);\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  isXAxis() {\n    return this.options.axis === Pointer.Axis.X;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n  isYAxis() {\n    return this.options.axis === Pointer.Axis.Y;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n  isBothAxis() {\n    return this.options.axis === Pointer.Axis.BOTH;\n  }\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n  get friction() {\n    return this._friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this._friction = friction;\n  }\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  }\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  }\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n  _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  }\n\n  /**\n   * Drag start handler.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The drag event object.\n   * @private\n   */\n  _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(\n        this._trackVelocity.bind(this),\n        Pointer.VELOCITY_INTERVAL,\n      );\n    }\n  }\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this.options.preventEventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  }\n\n  /**\n   * Finish the drag move function.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @private\n   */\n  _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    const endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    const isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  }\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new Coordinate();\n    this.velocity = new Coordinate();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  }\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    const lastDelta = Coordinate.difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  }\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n  _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  }\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n  _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n  _shouldLock(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n  _shouldDeactivate(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!Pointer.Event}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new Pointer.Event({\n      type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.options.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity,\n    });\n  }\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n  _addDragHandlers(startType) {\n    const target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case events.POINTERDOWN:\n        target.addEventListener(events.POINTERMOVE, this._onMove);\n        target.addEventListener(events.POINTERUP, this._onEnd);\n        target.addEventListener(events.POINTERCANCEL, this._onEnd);\n        break;\n      case events.MOUSEDOWN:\n        target.addEventListener(events.MOUSEMOVE, this._onMove);\n        target.addEventListener(events.MOUSEUP, this._onEnd);\n        break;\n      case events.TOUCHSTART:\n        target.addEventListener(events.TOUCHMOVE, this._onMove);\n        target.addEventListener(events.TOUCHEND, this._onEnd);\n        target.addEventListener(events.TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  }\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n  _removeDragHandlers() {\n    const target = this.dragEventTarget;\n    target.removeEventListener(events.POINTERMOVE, this._onMove);\n    target.removeEventListener(events.POINTERUP, this._onEnd);\n    target.removeEventListener(events.POINTERCANCEL, this._onEnd);\n    target.removeEventListener(events.MOUSEMOVE, this._onMove);\n    target.removeEventListener(events.MOUSEUP, this._onEnd);\n    target.removeEventListener(events.TOUCHMOVE, this._onMove);\n    target.removeEventListener(events.TOUCHEND, this._onEnd);\n    target.removeEventListener(events.TOUCHCANCEL, this._onEnd);\n  }\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n  _trackVelocity() {\n    const now = Date.now();\n    const elapsed = now - this._lastTime;\n    const delta = Coordinate.difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    const maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = clamp(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = clamp(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  }\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n  hasVelocity(velocity, threshold = Pointer.SWIPE_VELOCITY) {\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Remove event listeners and element references.\n   */\n  dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this.element.removeEventListener(events.POINTERDOWN, this._onStart);\n    this.element.removeEventListener(events.MOUSEDOWN, this._onStart);\n    this.element.removeEventListener(events.TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this.element.style[Pointer.TouchActionSupport[this.options.axis]] = '';\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.removeEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.element = null;\n    this.dragEventTarget = null;\n  }\n\n  /**\n   * Whether the event is from a touch.\n   * @param {object} evt Event object.\n   * @return {boolean}\n   */\n  static isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  }\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  static _isCancelEvent(evt) {\n    return evt.type === events.POINTERCANCEL || evt.type === events.TOUCHCANCEL;\n  }\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n  static _getPageCoordinate(evt) {\n    let pagePoints;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new Coordinate(pagePoints.pageX, pagePoints.pageY);\n  }\n\n  static _preventDefault(evt) {\n    evt.preventDefault();\n  }\n}\n\n/** @enum {string} */\nPointer.Direction = Direction;\n\n/** @enum {string} */\nPointer.Axis = Axis;\n\n/** @enum {string} */\nPointer.EventType = {\n  START: 'odopointer:start',\n  MOVE: 'odopointer:move',\n  END: 'odopointer:end',\n};\n\n/** @enum {string|boolean} */\nPointer.TouchActionSupport = {\n  x: OdoDevice.prefixed('touchAction', 'pan-y'),\n  y: OdoDevice.prefixed('touchAction', 'pan-x'),\n  xy: OdoDevice.prefixed('touchAction', 'none'),\n};\n\n/** @enum {string} */\nPointer.TouchAction = {\n  x: 'pan-y',\n  y: 'pan-x',\n  xy: 'none',\n};\n\n/**\n * @typedef {{axis: Axis, preventEventDefault: boolean}} PointerOptions\n */\n\n/** @type {PointerOptions} */\nPointer.Defaults = {\n  axis: 'xy',\n  preventEventDefault: true,\n};\n\n/**\n * The current velocity property will be clamped to this value (pixels/millisecond).\n * @const {number}\n */\nPointer.MAX_VELOCITY = 12;\n\n/**\n * When the pointer is down, an interval starts to track the current velocity.\n * @const {number}\n */\nPointer.VELOCITY_INTERVAL = 100;\n\n/**\n * Velocity required for a movement to be considered a swipe.\n * @const {number}\n */\nPointer.SWIPE_VELOCITY = 0.6;\n\n/**\n * The scroll/drag amount (pixels) required on the draggable axis before\n * stopping further page scrolling/movement.\n * @const {number}\n */\nPointer.LOCK_THRESHOLD = 6;\n\n/**\n * The scroll/drag amount (pixels) required on the opposite draggable axis\n * before dragging is deactivated for the rest of the interaction.\n * @const {number}\n */\nPointer.DRAG_THRESHOLD = 5;\n\nPointer.Event = _PointerEvent;\n\nexport default Pointer;\n"],"names":["Direction","Axis","isXAxis","axis","X","isYAxis","Y","isBothAxis","BOTH","hasDirection","direction","NONE","finiteOrZero","velocity","Number","isFinite","getVelocity","deltaTime","deltaX","deltaY","Coordinate","getTheDirection","value1","value2","isGreater","isLess","isEqual","getDirection","coord1","coord2","Math","abs","x","y","LEFT","RIGHT","UP","DOWN","isOnAxis","isXAndLeftOrRight","isYAndUpOrDown","isBothAndNotNone","didMoveOnAxis","getAxisDirection","start","end","_start","Object","assign","_end","PointerEvent","options","type","target","currentTarget","delta","currentVelocity","distance","isDirectionOnAxis","axisDirection","position","defaultPrevented","preventDefault","Pointer","element","nodeType","TypeError","Defaults","pageStart","page","_lastPosition","_friction","hasDragged","_isLocked","_isDeactivated","_enabled","_velocityTrackerId","startTime","_lastTime","_hasTrackedVelocity","dragEventTarget","document","touchAction","TouchActionSupport","_isTouchActionSupported","preventEventDefault","style","TouchAction","OdoDevice","HAS_TOUCH_EVENTS","addEventListener","events","TOUCHMOVE","noop","listen","_onStart","_handleDragStart","bind","HAS_POINTER_EVENTS","POINTERDOWN","MOUSEDOWN","TOUCHSTART","DRAGSTART","_preventDefault","applyFriction","coordinate","scale","friction","_canStartDrag","evt","isEnabled","isTouchEvent","button","_canContinueDrag","_setDragStartValues","_getPageCoordinate","isPrevented","_emitEvent","_createEvent","EventType","START","_addDragHandlers","setInterval","_trackVelocity","VELOCITY_INTERVAL","_handleDragMove","_setDragMoveValues","MOVE","_finishDragMove","_maybeLock","_maybeDeactivate","_handleDragEnd","Date","now","_removeDragHandlers","endEvent","END","isCancelEvent","_isCancelEvent","pagePosition","lastDelta","difference","translate","_shouldLock","_shouldDeactivate","pastX","LOCK_THRESHOLD","pastY","DRAG_THRESHOLD","Event","id","startType","_onMove","_onEnd","POINTERMOVE","POINTERUP","POINTERCANCEL","MOUSEMOVE","MOUSEUP","TOUCHEND","TOUCHCANCEL","removeEventListener","elapsed","maxVelocity","MAX_VELOCITY","clamp","hasVelocity","threshold","SWIPE_VELOCITY","event","emit","dispose","changedTouches","pagePoints","pageX","pageY","enabled","TinyEmitter","prefixed","_PointerEvent"],"mappings":"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"}