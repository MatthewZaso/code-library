{"version":3,"file":"odo-carousel.js","sources":["../src/carousel-event.js","../src/settings.js","../src/template-engine.js","../src/utils.js","../src/carousel.js"],"sourcesContent":["\nclass CarouselEvent {\n  /**\n   * Object representing a carousel event.\n   * @param {string} type Event type.\n   * @param {Carousel} carousel The carousel instance.\n   * @param {number=} optFrom The logical index the carousel is coming from.\n   * @param {number=} optTo The logical index the carouesl is going to.\n   * @constructor\n   */\n  constructor(type, carousel, optFrom, optTo) {\n    this.type = type;\n\n    /** @type {HTMLElement} */\n    this.target = carousel.element;\n\n    /** @type {number} carousel slid from this index. */\n    this.from = optFrom;\n\n    /** @type {number} carousel slid to this index. */\n    this.to = optTo;\n\n    /** @type {boolean} Whether the carousel actually changed slides. */\n    this.hasSlideChanged = optFrom !== optTo;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default CarouselEvent;\n","export default {\n\n  /**\n   * Event types emitted by the carousel.\n   * @enum {string}\n   */\n  EventType: {\n    WILL_NAVIGATE: 'odocarousel:willnavigate',\n    SLIDE_START: 'odocarousel:slidestart',\n    SLIDE_END: 'odocarousel:slideend',\n  },\n\n  /** @enum {string} */\n  Classes: {\n    BASE: 'odo-carousel',\n    FADE: 'odo-carousel--fade',\n    VERTICAL: 'odo-carousel--vertical',\n    WRAPPER: 'odo-carousel__wrapper',\n    CAROUSEL_ELEMENT: 'odo-carousel__element',\n\n    SLIDE: 'odo-carousel__slide',\n    ACTIVE_SLIDE: 'odo-carousel__slide--active',\n    PREVIOUS_SLIDE: 'odo-carousel__slide--previous',\n    PAST_SLIDE: 'odo-carousel__slide--past',\n    NEXT_SLIDE: 'odo-carousel__slide--next',\n    FUTURE_SLIDE: 'odo-carousel__slide--future',\n\n    VISIBLE: 'odo-carousel__slide--visible',\n    BEHIND: 'odo-carousel__slide--behind',\n\n    PAGINATION: 'odo-carousel__pagination',\n    PAGINATION_DOT: 'odo-carousel__pagination-dot',\n    PAGINATION_DOT_SELECTED: 'is-selected',\n\n    PADDLES: 'odo-carousel__nav-paddles',\n    PADDLE: 'odo-carousel__nav-paddle',\n    PADDLE_NEXT: 'odo-carousel__nav-next',\n    PADDLE_PREV: 'odo-carousel__nav-prev',\n    PADDLE_DISABLED: 'is-disabled',\n\n    SLIDE_CHILD: 'odo-carousel__slide-child',\n  },\n\n  Defaults: {\n    startIndex: 0,\n    isVertical: false,\n    isLooped: false,\n    isJumped: false,\n    isFade: false,\n    isCentered: false,\n    neighborCount: 1,\n    slideshowSpeed: 1000,\n    animationSpeed: 400,\n    crossfadeAmount: 0.875,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    pagination: false,\n    getNavPaddleHtml: null,\n    getPaginationHtml: null,\n    template: {\n      paddles: '<nav class=\"odo-carousel__nav-paddles\">{{ prev }}{{ next }}</nav>',\n      paddleNext: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"next slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-next\">{{ paddleInner }}</a>',\n      paddlePrev: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"previous slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-prev\">{{ paddleInner }}</a>',\n      paddleNextInner: '<svg viewBox=\"75.4 27 461.2 738\"><path d=\"M167.7 27l368.9 369-368.9 369-92.3-92.3 276.7-276.7-276.7-276.7z\"/></svg>',\n      paddlePrevInner: '<svg viewBox=\"75.396 26.994 461.208 738.012\"><path d=\"M444.336 765.006l-368.94-369.006 368.94-369.006 92.268 92.268-276.738 276.738 276.738 276.738z\"/></svg>',\n      pagination: '<nav class=\"odo-carousel__pagination\" role=\"tablist\">{{ dots }}</nav>',\n      paginationDot: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\"></a>',\n      paginationDotSecondary: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\" data-secondary-index=\"{{ secondaryIndex }}\" aria-hidden=\"{{ hidden }}\"></a>',\n    },\n  },\n\n  TRANSITION_END_WAIT: 32,\n};\n","/**\n * A simple string replacement template with double curly braces. You can use\n * nested objects and functions too.\n *\n * @example\n * // \"Today is Thursday\"\n * template(\"Today is {{ day }}\", {\n *   day: 'Thursday',\n * });\n *\n * // \"Today is Friday\"\n * template(\"Today is {{ month.day }}\", {\n *   month: {\n *     day: 'Friday',\n *   },\n * });\n *\n * // \"Today is Saturday\"\n * template(\"Today is {{ day }}\", {\n *   today: 'Saturday',\n *   day() {\n *     return this.today;\n *   },\n * });\n *\n * @param {string} str Template.\n * @param {object} data Data object with keys which match your template.\n * @return {string}\n */\nexport default function template(str, data) {\n  // A modified version of Malsup's template method for Cycle.\n  // https://github.com/malsup/cycle2/blob/master/src/jquery.cycle2.tmpl.js\n\n  // Regex which matches {{cool}} or {{ cool }} where `cool` is what should\n  // be replaced.\n  return str.replace(/{{\\s?((.)?.*?)\\s?}}/g, (match, str) => {\n    const names = str.split('.');\n    let obj = data;\n    let property;\n\n    // If the name has dots in it, \"person.name\", loop through each one.\n    if (names.length > 1) {\n      property = obj;\n      for (let i = 0; i < names.length; i++) {\n        obj = property;\n        property = property[names[i]] || str;\n      }\n\n    // Otherwise, it's a simple assignment from the data object.\n    } else {\n      property = obj[str];\n    }\n\n    // If they passed a function, use that.\n    if (typeof property === 'function') {\n      return property.call(obj);\n    }\n\n    // Return the string if it exists.\n    if (property !== undefined && property !== null && property !== str) {\n      return property;\n    }\n\n    // Otherwise, return the original string.\n    return str;\n  });\n}\n","/**\n * Parse the transform matrix into x and y translation values.\n * @param {string} str Transform matrix, or \"none\".\n * @return {{ x: number, y: number}}\n */\nexport function getTranslate(str) {\n  // If no transform is set, the computed transform will be \"none\".\n  if (str === 'none') {\n    return {\n      x: 0,\n      y: 0,\n    };\n  }\n\n  const array = str.match(/(-?[\\d.]+)/g);\n  return {\n    x: parseFloat(array[4]),\n    y: parseFloat(array[5]),\n  };\n}\n\nlet count = 0;\nexport function uniqueId() {\n  count += 1;\n  return `odo-carousel${count}`;\n}\n\n/**\n * Find every element within the parent which is focusable via tabbing and\n * enable/disable it. Ideally, some property could be set on the parent\n * element itself to prevent tabbing into it. visibility:hidden accomplishes\n * this, but there can be slides in view which are not the current slide.\n * @param {Element} parent Ancestor element to disable tabbing into.\n * @param {boolean} canFocus Whether to enable or disable focusability.\n */\nexport function toggleFocusability(parent, canFocus) {\n  const focusableElements = 'a[href],button,details,iframe,input,textarea,select,*[tabindex]';\n  const elements = Array.from(parent.querySelectorAll(focusableElements));\n\n  // Test the parent element itself. Odo Helpers polyfills `matches`.\n  if (parent.matches(focusableElements)) {\n    elements.push(parent);\n  }\n\n  for (let i = elements.length - 1; i >= 0; i--) {\n    if (canFocus) {\n      // Prefer resetting the tabIndex property by using removeAttribute to lets\n      // the browser decide if it should go back to 0 (like if it was a button)\n      // or to -1 if it wasn't originally focusable.\n      elements[i].removeAttribute('tabindex');\n    } else {\n      elements[i].tabIndex = -1;\n    }\n  }\n}\n","/**\n * @fileoverview A UI Component for creating versatile carousels. They are\n * peformant, draggable, and can ininitely loop.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport OdoPointer from '@odopod/odo-pointer';\nimport OdoDraggable from '@odopod/odo-draggable';\nimport {\n  cancelTransitionEnd,\n  capitalize,\n  clamp,\n  closest,\n  getElementsSize,\n  getNthSibling,\n  getSize,\n  giveId,\n  onTransitionEnd,\n  swapElements,\n  Timer,\n  wrapAroundList,\n} from '@odopod/odo-helpers';\n\nimport CarouselEvent from './carousel-event';\nimport settings from './settings';\nimport templateEngine from './template-engine';\nimport { getTranslate, toggleFocusability, uniqueId } from './utils';\n\nclass Carousel extends TinyEmitter {\n  /**\n   * @param {HTMLElement} element The outermost carousel element.\n   * @param {Object} [options] An options object.\n   * @constructor\n   * @throws {TypeError} if element isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!(element instanceof HTMLElement)) {\n      throw new TypeError(`OdoCarousel requires an element. Got: \"${element}\"`);\n    }\n\n    this.element = element;\n\n    /**\n     * Deep copy from the defaults and override defaults with options passed in.\n     * @public\n     */\n    this.options = Carousel.getOptions(options);\n\n    /**\n     * Whether the carousel is vertical or horizontal.\n     * @type {boolean}\n     * @protected\n     */\n    this.isVertical = this.options.isVertical;\n\n    /**\n     * Whether this is a looped carousel which is not a fading carousel.\n     * @type {boolean}\n     */\n    this._isSlidingLooped = this.options.isLooped && !this.options.isFade;\n\n    /**\n     * The DOM index of the current slide element within the slides' parent.\n     * @type {number}\n     * @protected\n     */\n    this.domIndex = 0;\n\n    /**\n     * The previous domIndex value.\n     * @type {number}\n     * @protected\n     */\n    this.lastDomIndex = 0;\n\n    /**\n     * Current logical index.\n     * @type {number}\n     */\n    this._selectedIndex = 0;\n\n    /**\n     * The slide container's parent.\n     * @type {HTMLElement}\n     * @private\n     */\n    this._slideContainerParentEl = null;\n\n    /**\n     * The container for the slides and the element which is moved around with\n     * transforms or absolute positioning.\n     * @type {HTMLElement}\n     * @private\n     */\n    this._carouselEl = null;\n\n    /**\n     * An array of slides (elements) in the carousel.\n     * @type {Array.<!HTMLElement>}\n     * @private\n     */\n    this._slides = [];\n\n    /**\n     * Whether the carousel is currently skipping slides. For example, going from\n     * slide 1 to 3, a jumping carousel repositions the slides so that 3 is next\n     * to 1 and only has to animate one slide length to get to it. This flag\n     * indicates a slide has been repositioned.\n     * @type {boolean}\n     * @private\n     */\n    this._isJumped = false;\n\n    /**\n     * Whether the carousel is able to be used. This can be changed with the\n     * `setEnabled` method.\n     * @type {boolean}\n     * @private\n     */\n    this._isEnabled = true;\n\n    /**\n     * Top or left.\n     * @type {string}\n     * @private\n     */\n    this._posAttr = this.isVertical ? 'top' : 'left';\n\n    /**\n     * offsetTop or offsetLeft.\n     * @type {string}\n     * @private\n     */\n    this._offsetPosition = 'offset' + capitalize(this._posAttr);\n\n    /**\n     * Height or width.\n     * @type {string}\n     * @private\n     */\n    this._dimensionAttr = this.isVertical ? 'height' : 'width';\n\n    /**\n     * Value used in `translate{X|Y}()`.\n     * @type {string}\n     */\n    this._translateAxis = this.isVertical ? 'Y' : 'X';\n\n    /**\n     * A flag indicating that the carousel is animating. It also will have\n     * a transition end event lister bound to it if the browser can\n     * transition transforms.\n     * @type {boolean}\n     * @protected\n     */\n    this.isTransitioning = false;\n\n    /**\n     * The id returned from onTransitionEnd which is used to cancel\n     * the transitionend listener.\n     * @type {number}\n     */\n    this._transitionId = null;\n\n    /**\n     * If a selector is specified, gotoSlide will look for this on the last\n     * slide and not reveal unneccesary whitespace to the right of the last\n     * matched element.\n     * @type {boolean}\n     * @private\n     */\n    this._hasSlideChildren = false;\n\n    /**\n     * Default to true for being able to drag the carousel between slides.\n     * @type {boolean}\n     * @private\n     */\n    this._isDraggable = true;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the carousel is at a resting position or between slides.\n     * @type {boolean}\n     */\n    this._isOffset = false;\n\n    /**\n     * A Timer used to make the carousel an autoplaying slideshow.\n     * @type {Timer}\n     * @private\n     */\n    this._timer = null;\n\n    /**\n     * Time, in milliseconds, to wait before adding zero opacity to the slide,\n     * which triggers the css transition. timeout = speed - (speed * %).\n     * @type {number}\n     * @private\n     */\n    this._crossfadeTimeout = this.options.animationSpeed -\n        (this.options.animationSpeed * this.options.crossfadeAmount);\n\n    /**\n     * When carousel slides are centered, they won't be aligned with the starting\n     * edge of the carousel wrapper. The starting edge (relative zero) is used\n     * to determine which slide is closest to the current position.\n     * @type {number}\n     */\n    this._startEdge = 0;\n\n    /**\n     * Draggable attached to the carousel element. Used for non-fade carousels.\n     * @type {OdoDraggable}\n     */\n    this.draggable = null;\n\n    /**\n     * Pointer attached to the main element. Used for fading carousels.\n     * @type {OdoPointer}\n     */\n    this.pointer = null;\n\n    /**\n     * Carousels containing only two slides with looping functionality are special\n     * cases. Slides need to be duplicated and pagination needs to be rendered\n     * differently. This is because in order for the user to navigate in either\n     * direction from the active slide, the second slide would need to be present in\n     * both the 'previous' and 'next' positions. 'Bidirectional' will refer to\n     * carousels with content that unnaturally exists for the sake of navigational\n     * purposes.\n     * @type {boolean}\n     */\n    this._isBidirectional = false;\n\n    // Deprecated method.\n    this.resetSync = this.reset;\n\n    // Go.\n    this.decorate();\n  }\n\n  /**\n   * Finds an element within this class' main element based on a class name.\n   * @param {string} className Class name to search for.\n   * @param {HTMLElement} [context] Optionally provide the context (scope)\n   *     for the query. Default is the main element of the class.\n   * @return {HTMLElement[]} An array which may or may not contain the element\n   *     which was searched for.\n   */\n  getElementsByClass(className, context = this.element) {\n    return Array.from(context.getElementsByClassName(className));\n  }\n\n  /**\n   * Retrieve an element by its class name.\n   * @param {string} className Class name to search for.\n   * @param {HTMLElement} [context] Optinal scope for search.\n   * @return {HTMLElement|null} The element or null if it isn't found.\n   */\n  getElementByClass(className, context) {\n    return this.getElementsByClass(className, context)[0] || null;\n  }\n\n  /**\n   * Modify the DOM to be a carousel.\n   */\n  decorate() {\n    this._saveDomElements();\n\n    // After we determine the number of slides, we have enough information to decide if\n    // this carousel will be a special bidirectional one.\n    if (this.options.isLooped && this._slides.length === 2) {\n      this._decorateBidirectionalCarousel();\n    }\n\n    this._setA11yAttributes();\n    this._renderPaddles();\n\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    this._setSlideIndices();\n\n    if (this.options.isFade) {\n      this._decorateFadeCarousel();\n    } else {\n      this._decorateRegularCarousel();\n    }\n\n    this._onClick = this._handleClick.bind(this);\n    this.element.addEventListener('click', this._onClick);\n\n    // Set the selected index without animation.\n    this.setSelectedIndex(this._getSafeIndex(this.options.startIndex), true);\n\n    // Changes viewport, so it needs to come after the goto zero.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateRegularCarousel() {\n    // Add easing to container\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_PROPERTY] = OdoDevice.Css.TRANSFORM;\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_TIMING_FUNCTION] = this.options.easing;\n\n    this._hasSlideChildren = this._getSlideChildren().length > 0;\n\n    this.bindDragEvents();\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateFadeCarousel() {\n    this._isDraggable = false;\n\n    // Add transitions to each slide.\n    this.getSlides().forEach((slide, i) => {\n      slide.style[OdoDevice.Dom.TRANSITION] = 'opacity ' +\n        this.options.animationSpeed + 'ms linear';\n\n      // The first slide needs to have the visible class.\n      if (i === 0) {\n        slide.classList.add(Carousel.Classes.VISIBLE);\n      }\n    });\n\n    this.bindSwipeEvents();\n  }\n\n  /**\n   * Sets up the additional DOM modifications that will be needed for bidirectional\n   * carousels. We will essentially be duplicating both carousel slides so that no\n   * matter the current index, the active slide will alway have neighbors on either side.\n   * Then later on, we hide the additional pagination.\n   * @private\n   */\n  _decorateBidirectionalCarousel() {\n    // Bidirectional carousels automatically will need to become a jumped carousels,\n    // since we will be adding artificial slides that ruin natural navigation.\n    this._isBidirectional = true;\n    this._isJumped = true;\n\n    // Turn 2 slides into 4.\n    this._slides.forEach((slide) => {\n      this.getCarouselElement().appendChild(slide.cloneNode(true));\n    });\n\n    // Update the global slides variable to include the new elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Set static accessibility attributes.\n   */\n  _setA11yAttributes() {\n    this.getWrapper().setAttribute('aria-live', 'polite');\n    this.getCarouselElement().setAttribute('role', 'list');\n    this.getSlides().forEach((slide) => {\n      giveId(slide, uniqueId);\n      slide.setAttribute('role', 'listitem');\n    });\n  }\n\n  /**\n   * Remove static accessibility attributes.\n   */\n  _removeA11yAttributes() {\n    this.getWrapper().removeAttribute('aria-live');\n    this.getCarouselElement().removeAttribute('role');\n    this.getSlides().forEach((slide) => {\n      slide.removeAttribute('role');\n    });\n  }\n\n  /**\n   * Store references to commonly used DOM elements.\n   * @private\n   */\n  _saveDomElements() {\n    // Element which wraps the element which contains all the slides.\n    this._slideContainerParentEl = this.getElementByClass(Carousel.Classes.WRAPPER);\n\n    // Element which contains all the slides.\n    this._carouselEl = this.getElementByClass(Carousel.Classes.CAROUSEL_ELEMENT);\n\n    // Because carousels can have carousels inside them, finding elements by\n    // class retrieves too many elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Store references to generated elements. The pagination dots cannot be save in\n   * `_saveDomElements` because the number of slides is not yet known.\n   * @private\n   */\n  _saveRenderedElements() {\n    this._paddlePrevious = this.getElementByClass(Carousel.Classes.PADDLE_PREV);\n    this._paddleNext = this.getElementByClass(Carousel.Classes.PADDLE_NEXT);\n    this._paginationDots = this.getElementsByClass(Carousel.Classes.PAGINATION_DOT)\n      .map(dot => ({\n        dot,\n        i: parseInt(dot.getAttribute('data-index'), 10),\n        i2: parseInt(dot.getAttribute('data-secondary-index'), 10),\n      }));\n  }\n\n  /**\n   * Add navigation paddles (previous and next buttons) to the carousel.\n   * @private\n   */\n  _renderPaddles() {\n    this.element.insertAdjacentHTML('beforeend', this._getNavPaddleHtml());\n  }\n\n  /**\n   * Remove navigation paddles from the carousel (if they exist).\n   * @private\n   */\n  _removePaddles() {\n    this._removeByClass(Carousel.Classes.PADDLES);\n  }\n\n  /**\n   * Remove a child element by class, if it exists.\n   * @param {string} className Class name of the element to find and remove.\n   */\n  _removeByClass(className) {\n    const element = this.getElementByClass(className);\n    if (element) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  /**\n   * Retrieves the html string for the nav paddles from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getNavPaddleHtml() {\n    if (typeof this.options.getNavPaddleHtml === 'function') {\n      return this.options.getNavPaddleHtml.call(this, this);\n    }\n\n    return Carousel.template(this.options.template.paddles, {\n      prev: Carousel.template(this.options.template.paddlePrev, {\n        paddleInner: this.options.template.paddlePrevInner,\n      }),\n      next: Carousel.template(this.options.template.paddleNext, {\n        paddleInner: this.options.template.paddleNextInner,\n      }),\n    });\n  }\n\n  /**\n   * Add pagination (the dots) to the carousel.\n   * @private\n   */\n  _renderPagination() {\n    this.element.insertAdjacentHTML('beforeend', this._getPaginationHtml());\n  }\n\n  /**\n   * Remove pagination from the carousel (if they exist).\n   * @private\n   */\n  _removePagination() {\n    this._removeByClass(Carousel.Classes.PAGINATION);\n  }\n\n  /**\n   * Retrieves the html string for the pagination from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getPaginationHtml() {\n    if (typeof this.options.getPaginationHtml === 'function') {\n      return this.options.getPaginationHtml.call(this, this);\n    }\n\n    const dots = this._buildPaginationHtml();\n\n    return Carousel.template(this.options.template.pagination, {\n      dots,\n    });\n  }\n\n  /**\n   * Builds and returns the HTML string of the pagination dots.\n   * Bidirectional carousels utilize a separate template that includes\n   * secondary indices.\n   * @return {string}\n   * @private\n   */\n  _buildPaginationHtml() {\n    const template = this._isBidirectional ?\n      this.options.template.paginationDotSecondary :\n      this.options.template.paginationDot;\n\n    return this.getSlides().reduce((dotsHtml, slide, i, arr) => {\n      const data = {\n        index: i,\n        index1: i + 1,\n        slideId: slide.id,\n      };\n\n      if (this._isBidirectional) {\n        // If you are rendering pagination for a bidirectional carousel, you will need\n        // secondary indices computed. This returns the secondary index based on the primary.\n        // i.e. For 4 slides, 1 returns 3, 2 returns 4 and the inverse.\n        data.secondaryIndex = i > 1 ? i % 2 : i + 2;\n        data.hidden = i >= arr.length / 2;\n      }\n\n      return dotsHtml + Carousel.template(template, data);\n    }, '');\n  }\n\n  /**\n   * Listen for dragging events.\n   * @protected\n   */\n  bindDragEvents() {\n    this.draggable = new OdoDraggable(this._carouselEl, {\n      axis: this.isVertical ? OdoPointer.Axis.Y : OdoPointer.Axis.X,\n    });\n\n    this._onDragStart = this._handleDragStart.bind(this);\n    this._onDragMove = this._handleDragMove.bind(this);\n    this._onDragEnd = this._handleDragEnd.bind(this);\n\n    this.draggable.on(OdoDraggable.EventType.START, this._onDragStart);\n    this.draggable.on(OdoDraggable.EventType.MOVE, this._onDragMove);\n    this.draggable.on(OdoDraggable.EventType.END, this._onDragEnd);\n  }\n\n  /**\n   * Listen for the pointer to come up from the screen, then execute a callback.\n   * @protected\n   */\n  bindSwipeEvents() {\n    this.pointer = new OdoPointer(this._carouselEl, {\n      axis: OdoPointer.Axis.X,\n      preventEventDefault: true,\n    });\n\n    this._onPointerEnd = this._handlePointerEnd.bind(this);\n    this.pointer.on(OdoPointer.EventType.END, this._onPointerEnd);\n  }\n\n  /**\n   * Add a slide to the end of the carousel.\n   * @param {string} slideHtml Html string for the slide.\n   */\n  addSlide(slideHtml) {\n    // Make sure looped carousels are in the right order without any neighbors.\n    this._setSlidesToLogicalOrder();\n\n    // Insert new slide at the end.\n    this._carouselEl.insertAdjacentHTML('beforeend', slideHtml);\n\n    this.reset();\n  }\n\n  /**\n   * Synchronously reset the slides. Use this when you're sure the elements\n   * within the carousel are done changing.\n   */\n  reset() {\n    // Update the slides.\n    this._saveDomElements();\n\n    // Remove old paddles + pagination.\n    this._removePaddles();\n    this._removePagination();\n\n    this._setA11yAttributes();\n\n    // Re-render paddles and pagination.\n    this._renderPaddles();\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    // Update slide indices now that there's a new slide.\n    this._setSlideIndices();\n\n    // Go to the slide it was at before.\n    const selected = this.getSelectedIndex();\n    this.setSelectedIndex(0, true);\n\n    // Try going back to the previous one.\n    this.setSelectedIndex(selected, true);\n\n    // Set neighbors slides for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Retreives the cached carousel wrapper element.\n   * @return {HTMLElement}\n   */\n  getWrapper() {\n    return this._slideContainerParentEl;\n  }\n\n  /**\n   * Retreives the cached carousel element.\n   * @return {HTMLElement}\n   */\n  getCarouselElement() {\n    return this._carouselEl;\n  }\n\n  /**\n   * Returns the array of slides in the carousel.\n   * @return {!Array.<!HTMLElement>} The slides array.\n   */\n  getSlides() {\n    return this._slides;\n  }\n\n  /**\n   * Get the slide element at the given index.\n   * @param {number} index The logical index of the slide you want.\n   * @return {HTMLElement} The slide element.\n   */\n  getSlide(index) {\n    return this.getSlides()[index];\n  }\n\n  /**\n   * Get the index of the currently active slide.\n   * @return {number} Index of the current slide.\n   */\n  getSelectedIndex() {\n    return this._selectedIndex;\n  }\n\n  /**\n   * Translates the original index to the current DOM index.\n   * @param {number} logicalIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getDomIndex(logicalIndex) {\n    return this.getSlideIndices().indexOf(logicalIndex);\n  }\n\n  /**\n   * Translates the DOM index to the original logical index.\n   * @param {number} domIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getLogicalIndex(domIndex) {\n    return this.getSlideIndices()[domIndex];\n  }\n\n  /**\n   * Takes a logical index which could potentially be out of range and returns\n   * the logical index within range.\n   * @param {number} logicalIndex Logical index to make safe.\n   * @return {number} Safe logical index.\n   * @private\n   */\n  _getSafeIndex(logicalIndex) {\n    if (this.isIndexOutOfRange(logicalIndex)) {\n      if (this.options.isLooped) {\n        return this._getRelativeIndex(logicalIndex, 0);\n      }\n      return this.clampIndexToSlides(logicalIndex);\n    }\n    return logicalIndex;\n  }\n\n  /**\n   * Calculates the offset index for a circular list.\n   * @param {number} index Starting index.\n   * @param {number} displacement Offset from the starting index. Can be negative\n   *     or positive. For example, -2 or 2.\n   * @return {number} The index of the relative displacement, wrapping around\n   *     the end of the list to the start when the displacement is larger than\n   *     what's left in the list.\n   */\n  _getRelativeIndex(index, displacement) {\n    return wrapAroundList(index, displacement, this._slides.length);\n  }\n\n  /**\n   * @param {number} index Index to test.\n   * @return {boolean} Whether a given index is out of range of the carousel.\n   */\n  isIndexOutOfRange(index) {\n    return index <= -1 || index >= this._slides.length;\n  }\n\n  /**\n   * Constrain an index within bounds.\n   * @param {number} index Index to clamp.\n   * @return {number}\n   */\n  clampIndexToSlides(index) {\n    return clamp(index, 0, this._slides.length - 1);\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the first slide.\n   */\n  isFirstSlide() {\n    return this.getSelectedIndex() === 0;\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the last slide.\n   */\n  isLastSlide() {\n    return this.getSelectedIndex() === this._slides.length - 1;\n  }\n\n  /**\n   * Generates the array which will follow the DOM order of the slides in their\n   * container and saves it.\n   * @private\n   */\n  _setSlideIndices() {\n    this._slideIndices = new Array(this._slides.length);\n\n    for (let i = 0, len = this._slides.length; i < len; i++) {\n      this._slideIndices[i] = i;\n    }\n  }\n\n  /** @return {!Array.<!number>} The slide indices array. */\n  getSlideIndices() {\n    return this._slideIndices;\n  }\n\n  /**\n   * Retrieves the slide children.\n   * @param {HTMLElement} [optSlide] Slide to look within.\n   * @return {HTMLElement[]} NodeList of slide children.\n   * @private\n   */\n  _getSlideChildren(optSlide) {\n    return this.getElementsByClass(Carousel.Classes.SLIDE_CHILD, optSlide);\n  }\n\n  /**\n   * Modifieds the _slideIndices array to represent the DOM order of the slides\n   * within their container.\n   * @param {number} currentValue The value to be moved. This is the same as the\n   *     logical index.\n   * @param {number} toIndex The location to move it to in the array. It will be\n   *     clamped between zero and one less than the length of the array. This is\n   *     also referred to as the DOM index.\n   * @private\n   */\n  _moveIndex(currentValue, toIndex) {\n    const clampedIndex = this.clampIndexToSlides(toIndex);\n    const fromIndex = this._getDomIndex(currentValue);\n    const arr = this._slideIndices;\n\n    // Array moveIndex.\n    arr.splice(clampedIndex, 0, arr.splice(fromIndex, 1)[0]);\n  }\n\n  /**\n   * Swaps positions of two logical indices in the slide indices array.\n   * @param {number} logIndex1 First logical index which will be swappeed.\n   * @param {number} logIndex2 Second logical index to be swapped.\n   * @private\n   */\n  _swapIndexes(logIndex1, logIndex2) {\n    const domIndexOfLogicalIndex1 = this._getDomIndex(logIndex1);\n    this._slideIndices[domIndexOfLogicalIndex1] = -1;\n    this._slideIndices[this._getDomIndex(logIndex2)] = logIndex1;\n    this._slideIndices[domIndexOfLogicalIndex1] = logIndex2;\n  }\n\n  /**\n   * Gets the slide positions (offsets from the left|top) array.\n   * @param {HTMLElement[]} slideSet the slides array.\n   * @return {Array.<number>} array of slide positions.\n   * @private\n   */\n  _getPositions(slideSet) {\n    const bounds = this.getWrapper().getBoundingClientRect()[this._posAttr];\n    return slideSet.map(el => el.getBoundingClientRect()[this._posAttr] - bounds);\n  }\n\n  /**\n   * Enable or disable dragging.\n   * @param {boolean} enabled Whether it should be draggable.\n   * @private\n   */\n  _setDraggableEnabled(enabled) {\n    if (this.draggable) {\n      this.draggable.isEnabled = enabled;\n    } else {\n      this.pointer.isEnabled = enabled;\n    }\n  }\n\n  /**\n   * Enable or disable dragging of the carousel.\n   * @param {boolean} isDraggable Whether it should be draggable.\n   */\n  setDraggable(isDraggable) {\n    this._isDraggable = isDraggable;\n    this._setDraggableEnabled(isDraggable);\n  }\n\n  /**\n   * Public method which returns the enabled state.\n   * @return {boolean}\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  /**\n   * Toggle the enabled/disabled state of the carousel. When it's disabled, it\n   * will not be able to navigate slides.\n   * @param {boolean} enabled Whether to enable or disable.\n   */\n  set isEnabled(enabled) {\n    this._isEnabled = enabled;\n    this._setDraggableEnabled(enabled);\n  }\n\n  /**\n   * Gets the adjusted position.\n   * @param {HTMLElement} destinationSlide The slide the carousel is headed to.\n   * @return {number} The position it is.\n   * @private\n   */\n  _getNewPosition(destinationSlide) {\n    // Destination position.\n    let destinationPosition = destinationSlide[this._offsetPosition];\n\n    // Width or height of the carousel element.\n    const carouselSize = getSize(this.getCarouselElement())[this._dimensionAttr];\n\n    if (this.options.isCentered) {\n      const destinationSize = getSize(destinationSlide)[this._dimensionAttr];\n      const wrapperSize = getSize(this.getWrapper())[this._dimensionAttr];\n      this._startEdge = (wrapperSize - destinationSize) / 2;\n      destinationPosition -= this._startEdge;\n    }\n\n    let position = destinationPosition / carouselSize;\n\n    if (this._hasSlideChildren && this.isLastSlide()) {\n      // Adjust the position again if there are slide children in the last slide.\n      position = this._getPositionForSlideChildren(\n        destinationSlide,\n        destinationPosition, carouselSize,\n      );\n    }\n\n    return position;\n  }\n\n  /**\n   * Adjust the destination position again if there are slide children.\n   * @param {HTMLElement} destinationSlide Slide element.\n   * @param {number} destinationPosition Where the slide would initially go.\n   * @param {number} carouselSize Width or height of the carousel element.\n   * @return {number} New destination position.\n   * @private\n   */\n  _getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize) {\n    // Size of the combined width/height + margins of the slide children\n    // within the destination slide.\n    const childrenSum = getElementsSize(\n      this._getSlideChildren(destinationSlide),\n      this._dimensionAttr,\n    );\n\n    // width|height of the carousel slide.\n    const slideSize = getSize(destinationSlide)[this._dimensionAttr];\n\n    // The destination position minus the empty space in the next slide in px.\n    const newPosition = destinationPosition - (slideSize - childrenSum);\n\n    // Calculate the percentage from the pixel value.\n    return newPosition / carouselSize;\n  }\n\n  /**\n   * Returns the translated position based on carousel direction.\n   * @param {string} pos The position (eg \"25%\").\n   * @return {string} the css value for transform.\n   * @private\n   */\n  _getCssPosition(pos) {\n    return 'translate' + this._translateAxis + '(' + pos + ')';\n  }\n\n  /** @private */\n  _setSlidesToLogicalOrder() {\n    const frag = document.createDocumentFragment();\n\n    this._slides.forEach(frag.appendChild, frag);\n\n    this._carouselEl.appendChild(frag);\n\n    // Reset the slide indices array.\n    this._setSlideIndices();\n  }\n\n  /**\n   * If this is a jumped carousel, prepare the slides for the jump by swapping\n   * elements out and setting the `isJumped` option.\n   * @param {number} toDomIndex Index of the slide the carousel is jumping to.\n   * @return {number} If this function changed the order the slides, it returns\n   *     the new DOM index the carousel is going to. Otherwise it returns the\n   *     DOM index parameter it was given.\n   * @private\n   */\n  _setNeighborSlidesForJump(toDomIndex) {\n    const toLogicalIndex = this._getLogicalIndex(toDomIndex);\n    const currentLogicalIndex = this._getLogicalIndex(this.domIndex);\n\n    this._isJumped = true;\n\n    // Where to move the slide to. Next to the current index.\n    const destinationDomIndex = toLogicalIndex > currentLogicalIndex ?\n      this.domIndex + 1 :\n      this.domIndex - 1;\n\n    // Swap indices.\n    // Swap destination slide with current slide at the destination.\n    this._swapSlides(toLogicalIndex, this._getLogicalIndex(destinationDomIndex));\n\n    // Return the dom index the carousel is actually going to.\n    return destinationDomIndex;\n  }\n\n  /**\n   * Swap indices and DOM elements.\n   * @param {number} index1 Logical index 1.\n   * @param {number} index2 Logical index 2.\n   * @private\n   */\n  _swapSlides(index1, index2) {\n    this._swapIndexes(index1, index2);\n    swapElements(this.getSlide(index1), this.getSlide(index2));\n  }\n\n  /**\n   * This function initializes the slideshow functionality for the\n   * carousel. It sets an interval for the slideshow to continue animate\n   * based on the option slideshowSpeed.\n   */\n  startSlideshow() {\n    // Create the timer if it doesn't already exist.\n    if (!this._timer) {\n      this._timer = new Timer(\n        this._slideshowTimerExpired.bind(this),\n        this.options.slideshowSpeed, true,\n      );\n    }\n\n    this._timer.start();\n  }\n\n  /**\n   * A simple method which pauses the _timer\n   * once thats paused the slideshow will stop ticking.\n   * Can be re-initialzed by running `startSlideshow()`\n   */\n  pauseSlideshow() {\n    if (this._isSlideshowPlaying()) {\n      this._timer.stop();\n    }\n  }\n\n  /**\n   * Whether the slideshow timer exists and is currently ticking.\n   * @return {boolean}\n   * @private\n   */\n  _isSlideshowPlaying() {\n    return !!this._timer && this._timer.isTicking;\n  }\n\n  // getNthSibling returns null if it cannot find the nth sibling,\n  // but if `null` is used in `insertBefore`, it will append the element\n  // to the end.\n  getInnocentNeighbor(iterator, isNext) {\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    return isNext ?\n      getNthSibling(currentSlideEl, iterator + 1) :\n      getNthSibling(currentSlideEl, iterator, false) ||\n      this._carouselEl.firstElementChild;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNeighborInsertionIndex(iterator, isNext, currentDomIndex) {\n    return isNext ?\n      currentDomIndex + iterator + 1 :\n      currentDomIndex - iterator;\n  }\n\n  /**\n   *\n   * @param {number} iterator Neighbor index.\n   * @param {number} relativePos Neighbor index relative to the current index.\n   * @param {boolean} isNext Whether to move the slide next or previous.\n   * @private\n   */\n  _setNeighborSlide(iterator, relativePos, isNext) {\n    const index = this.getSelectedIndex();\n    const indices = this.getSlideIndices();\n\n    // Previous calls to set neighbor slide may have changed the DOM, so\n    // don't rely on stored variables.\n    const currentDomIndex = this._getDomIndex(index);\n\n    // Index of the future neighbor relative to the original DOM order.\n    const logicalNeighborIndex = this._getRelativeIndex(index, relativePos);\n\n    // Do the slides need to be rearranged? Check the current indices to see\n    // if the new neighbors are already there.\n    if (indices[currentDomIndex + relativePos] !== logicalNeighborIndex) {\n      // The slide to insert the new neighbor before.\n      const innocentNeighbor = this.getInnocentNeighbor(iterator, isNext);\n      const insertionIndex = this.getNeighborInsertionIndex(iterator, isNext, currentDomIndex);\n      const neighborEl = this.getSlide(logicalNeighborIndex);\n\n      // Move the neighbor's index to be a neighbor to the current dom index.\n      this._moveIndex(logicalNeighborIndex, insertionIndex);\n      this._carouselEl.insertBefore(neighborEl, innocentNeighbor);\n    }\n  }\n\n  /**\n   * This function makes sure that looped carousels always have a neighbor to\n   * go to. It repositions the viewport if it has to move slides around.\n   * @private\n   */\n  _setNeighborSlides() {\n    let i;\n\n    // Set the left neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, -(i + 1), false);\n    }\n\n    // Set the right neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, i + 1, true);\n    }\n  }\n\n  /**\n   * Reset the carousel back to the currently selected slide without animation.\n   */\n  _snapToCurrentSlide() {\n    this.goToSlide(this._getDomIndex(this.getSelectedIndex()), true);\n  }\n\n  /**\n   * Determine if the distance between current and destination slides is more\n   * than one slide. If it's not, there is no need to \"jump\".\n   * @param {number} domIndex DOM index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating.\n   * @return {number} DOM index of the slide to go to because moving slides\n   *     around to \"jump\" them will causes indices to change.\n   */\n  _maybeSetJumpedSlides(domIndex, noAnimation) {\n    // Determine if the distance between current and destination slides\n    // is more than one slide. If it's not, there's no need to \"jump\".\n    if (this.options.isJumped && !noAnimation && Math.abs(this.domIndex - domIndex) > 1) {\n      return this._setNeighborSlidesForJump(domIndex);\n    }\n    return domIndex;\n  }\n\n  /**\n   * Determine whether or not the carousel can navigate in its current condition.\n   * @param {number} domIndex Dom index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating there.\n   * @return {boolean}\n   */\n  _canNavigate(domIndex, noAnimation) {\n    const isSameSlideWithAnimation = domIndex === this.domIndex && !noAnimation;\n\n    // Whether the carousel would be able to move.\n    const isOffset = this.hasDragged || this._isOffset;\n\n    // 1) Whether the carousel is enabled.\n    // 2) The index is out of range and the carousel isn't set to loop. Silently\n    // exit here instead of throwing errors everywhere.\n    // 3) Trying to go to the slide it's already on with a transition and no\n    // dragging has occured or the carousel is not offset.\n    return !(\n      (!this._isEnabled) ||\n      (!this.options.isLooped && this.isIndexOutOfRange(domIndex)) ||\n      (isSameSlideWithAnimation && !isOffset));\n  }\n\n  _toNewSlide() {\n    // Set flag meaning the carousel is waiting for a transition end.\n    this.isTransitioning = true;\n\n    // Fire event saying the slide started to transition.\n    this._emitEvent(new CarouselEvent(\n      Carousel.EventType.SLIDE_START,\n      this,\n      this._getLogicalIndex(this.lastDomIndex),\n      this._getLogicalIndex(this.domIndex),\n    ));\n  }\n\n  /**\n   * Uses Css transforms to move the carousel to a new position.\n   * @param {string} position The percentage value.\n   * @param {boolean} noAnimation Whether to move with animation or not.\n   * @private\n   */\n  _moveToPosition(position, noAnimation) {\n    // Set transform.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = this._getCssPosition(position);\n\n    // Set transition speed to zero so that it happens instantly.\n    if (noAnimation) {\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n\n      // Listen for transitionend if it will animate.\n    } else {\n      // Set transition speed.\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] =\n        this.options.animationSpeed + 'ms';\n\n      // This is used as a backup to the transitionend event, which sometimes\n      // doesn't fire on iOS 7 Safari when the carousel has only been dragged a\n      // few pixels. It's set to go off ~2 frames after the transition end event\n      // should have occurred.\n      this._transitionId = onTransitionEnd(\n        this._carouselEl,\n        this._transitionDone,\n        this,\n        OdoDevice.Dom.TRANSFORM,\n        this.options.animationSpeed + Carousel.TRANSITION_END_WAIT,\n      );\n\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Calculates the offset of the carousel relative to the current slide.\n   * @return {number}\n   */\n  _getCarouselOffset() {\n    const matrix = getComputedStyle(this._carouselEl)[OdoDevice.Dom.TRANSFORM];\n\n    // Round to 1 decimal place because the `_startEdge` can be a decimal.\n    const translate = Math.round(getTranslate(matrix)[this._translateAxis.toLowerCase()] * 10) / 10;\n\n    const slideOffset = this.getSlide(this.getSelectedIndex())[this._offsetPosition];\n    return slideOffset + translate;\n  }\n\n  /**\n   * If the carousel is waiting for a transition to finish (going to a slide),\n   * but the user tells it to navigate again, the previous listener for the\n   * transition end event needs to be canceled. This allows the user to quickly\n   * click through the carousel without waiting for each navigation to finish.\n   *\n   * For jumped and looped carousels, the carousel element needs to be\n   * repositioned because setting neighbor slides will cause the elements to\n   * shift within the main carousel element. The current offset relative to\n   * the current slide is saved before moving any slide elements, then the slide\n   * elements are moved, and finally the carousel is set to appear as if the\n   * elements never moved.\n   */\n  _cancelMovement() {\n    if (!this.isTransitioning) {\n      return;\n    }\n\n    this.isTransitioning = false;\n    cancelTransitionEnd(this._transitionId);\n\n    if (this.options.isFade) {\n      // Remove the \"behind\" class which is usually removed after the on\n      // transition end.\n      this.getSlide(this._getLogicalIndex(this.lastDomIndex))\n        .classList\n        .remove(Carousel.Classes.BEHIND);\n      // Fading carousels do not need to reposition themselves, end here.\n      return;\n    }\n\n    // Save the offset relative to the current slide before slides are moved.\n    const carouselSize = getSize(this.getCarouselElement())[this._dimensionAttr];\n    const offset = this._getCarouselOffset();\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    // Now that the current slide has potentially moved in the DOM, update the\n    // carousel's offset.\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    const newSlideOffset = currentSlideEl[this._offsetPosition];\n    const position = (newSlideOffset - offset) / carouselSize;\n\n    // Setting the position here stops the browser from transitioning to the\n    // previous position, allowing the user to \"catch\" the carousel mid-nav.\n    this._moveToPosition((position * -100) + '%', true);\n    this.draggable.update();\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean} [noAnimation] Whether going to the slide should animate.\n   * @protected\n   */\n  fadeToSlide(domIndex, noAnimation) {\n    // Get next and previous slides.\n    const nextSlide = this.getSlide(domIndex);\n    const previousSlide = this.getSlide(this.domIndex);\n\n    // Listen for transitionend if it will animate.\n    if (!noAnimation) {\n      // Going to a new slide, wait for callback.\n      this._transitionId = onTransitionEnd(nextSlide, this._transitionDone, this);\n    }\n\n    // Show next slide. Put the previous behind the next.\n    nextSlide.classList.add(Carousel.Classes.VISIBLE);\n\n    if (previousSlide !== nextSlide) {\n      previousSlide.classList.add(Carousel.Classes.BEHIND);\n\n      // Delay the previous slide fading out by the specified percentage.\n      // The crossfade amount is between 0 and 1. A value of 1 means that both slides\n      // will fade at the same time. A crossfade of zero means the previous slide\n      // will wait until the next slide has completely faded in before it fades out.\n      setTimeout(() => {\n        previousSlide.classList.remove(Carousel.Classes.VISIBLE);\n      }, this._crossfadeTimeout);\n    }\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = domIndex;\n\n    // Emit event for slide start.\n    if (!noAnimation) {\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean} [noAnimation] Whether going to the slide should animate.\n   * @protected\n   */\n  goToSlide(domIndex, noAnimation) {\n    // Get the destion slide element from the current DOM order.\n    const destinationSlide = this.getSlide(this._getLogicalIndex(domIndex));\n\n    // If the carousel skips inbetween slides, reposition them.\n    // DOM index is reassinged here because if the slides are repositioned,\n    // the DOM index of the carousel changes.\n    const updatedDomIndex = this._maybeSetJumpedSlides(domIndex, noAnimation);\n\n    // The position the container will go to.\n    const adjustedPosition = (this._getNewPosition(destinationSlide) * -100) + '%';\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = updatedDomIndex;\n\n    // Set the css styles to move the carousel element. This also dispatches\n    // the slide start event if the carousel element will move with animation.\n    this._moveToPosition(adjustedPosition, noAnimation);\n  }\n\n  /**\n   * Helper function for going to a given index. This method should be used\n   * instead of the private one to abstract the DOM order stuff.\n   * @param {number} index The logical, zero based index of the slide you wish\n   *     the carousel to go to.\n   * @param {boolean} [noAnimation] Optional skip the animation in goToSlide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  setSelectedIndex(index, noAnimation) {\n    let domIndex = this._getDomIndex(index);\n    const canNavigate = this._canNavigate(domIndex, noAnimation);\n\n    // Will go the the give slide.\n    if (canNavigate) {\n      // If the event's default action was prevented, return false.\n      if (this._emitEvent(new CarouselEvent(Carousel.EventType.WILL_NAVIGATE, this))) {\n        return false;\n      }\n\n      this._cancelMovement();\n\n      this._selectedIndex = this._getSafeIndex(index);\n\n      // Convert new safe logical index to a DOM index.\n      domIndex = this._getDomIndex(this._selectedIndex);\n\n      // Set new classes on the slide elements. This is also where toggling\n      // paddles and pagination should go.\n      this._setSlidesState();\n      this._setPaddleState();\n      this._setPaginationState();\n      if (this.options.isFade) {\n        this.fadeToSlide(domIndex, noAnimation);\n      } else {\n        this.goToSlide(domIndex, noAnimation);\n      }\n    }\n\n    // Otherwise, it will not go to the give slide due to unmet conditions.\n    return canNavigate;\n  }\n\n  /**\n   * Find the nearest slide, and move the carousel to that.\n   * @param {boolean} [isNext] Whether it should go to the nearest slide, but\n   *     only in the next direction. False means it should go previous and\n   *     anything not true or false will go to the nearest slide regardless\n   *     of direction.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNearestSlide(isNext) {\n    // Gets positions relative to the wrapper element of each slide.\n    const positions = this._getPositions(this.getSlides());\n\n    // Current position (the left side of the carousel wrapper)\n    // Gets the closest value in the array to the given value.\n    // Index of the closest value.\n    let logicalIndex = positions.indexOf(closest(positions, this._startEdge));\n\n    // When going to a next or previous slide, the closest index could\n    // still be the one that's currently selected, but the carousel should\n    // still move next/previous because it has enough velocity.\n    if (logicalIndex === this.getSelectedIndex()) {\n      if (isNext === true) {\n        logicalIndex = this._getSafeIndex(logicalIndex + 1);\n      } else if (isNext === false) {\n        logicalIndex = this._getSafeIndex(logicalIndex - 1);\n      }\n    }\n\n    return this.setSelectedIndex(logicalIndex);\n  }\n\n  /**\n   * Go to the next slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNextSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() + 1);\n  }\n\n  /**\n   * Go to the previous slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToPreviousSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() - 1);\n  }\n\n  /**\n   * Sets the past, previous, active, next, and future classes to the appropriate\n   * slides.\n   * @private\n   */\n  _setSlidesState() {\n    const selectedIndex = this.getSelectedIndex();\n    const past = this._getSafeIndex(selectedIndex - 2);\n    const previous = this._getSafeIndex(selectedIndex - 1);\n    const next = this._getSafeIndex(selectedIndex + 1);\n    const future = this._getSafeIndex(selectedIndex + 2);\n\n    // This works because the _slides array does not mimic the DOM order.\n    this.getSlides().forEach((slide, i) => {\n      const isActive = i === selectedIndex;\n\n      toggleFocusability(slide, isActive);\n\n      slide.setAttribute('aria-hidden', !isActive);\n\n      // Active slide.\n      slide.classList.toggle(Carousel.Classes.ACTIVE_SLIDE, isActive);\n\n      // Previous previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PAST_SLIDE,\n        i === past && selectedIndex !== past && previous !== past,\n      );\n\n      // Previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PREVIOUS_SLIDE,\n        i === previous && selectedIndex !== previous,\n      );\n\n      // Next slide.\n      slide.classList.toggle(\n        Carousel.Classes.NEXT_SLIDE,\n        i === next && selectedIndex !== next,\n      );\n\n      // Next next slide.\n      slide.classList.toggle(\n        Carousel.Classes.FUTURE_SLIDE,\n        i === future && selectedIndex !== future && next !== future,\n      );\n    });\n  }\n\n  _setPaginationState() {\n    if (this.options.pagination) {\n      const selectedIndex = this.getSelectedIndex();\n      this._paginationDots.forEach(({ dot, i, i2 }) => {\n        const selected = selectedIndex === i || selectedIndex === i2;\n        dot.classList.toggle(Carousel.Classes.PAGINATION_DOT_SELECTED, selected);\n        dot.setAttribute('aria-selected', selected);\n      });\n    }\n  }\n\n  _setPaddleState() {\n    const notLooped = !this.options.isLooped;\n    if (notLooped && this._paddlePrevious) {\n      const first = this.isFirstSlide();\n      this._paddlePrevious.classList.toggle(Carousel.Classes.PADDLE_DISABLED, first);\n      this._paddlePrevious.setAttribute('aria-disabled', first);\n    }\n\n    if (notLooped && this._paddleNext) {\n      const last = this.isLastSlide();\n      this._paddleNext.classList.toggle(Carousel.Classes.PADDLE_DISABLED, last);\n      this._paddleNext.setAttribute('aria-disabled', last);\n    }\n  }\n\n  /**\n   * Callback for when the slideshow timer expires.\n   * @private\n   */\n  _slideshowTimerExpired() {\n    // Pause the timer if it's at the end.\n    if (!this.options.isLooped && this.isLastSlide()) {\n      this.pauseSlideshow();\n    } else {\n      this.goToNextSlide();\n    }\n  }\n\n  _transitionDone() {\n    const from = this._getLogicalIndex(this.lastDomIndex);\n    const to = this._getLogicalIndex(this.domIndex);\n\n    // Needs to come before setting neighbor slides.\n    this.isTransitioning = false;\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    // Neighboring slides must be set after each transition for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    if (this._isJumped || this._isSlidingLooped) {\n      this._snapToCurrentSlide();\n    }\n\n    if (this.options.isFade) {\n      this.getSlide(from).classList.remove(Carousel.Classes.BEHIND);\n    }\n\n    // No longer jumped.\n    this._isJumped = false;\n\n    // Dispatch slide end event.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_END, this, from, to));\n  }\n\n  /**\n   * Received the pointer end event.\n   * @param {PointerEvent} pointerEvent Pointer event object.\n   */\n  _handlePointerEnd(pointerEvent) {\n    if (this.pointer.hasVelocity(pointerEvent.velocity)) {\n      if (pointerEvent.direction === OdoPointer.Direction.RIGHT) {\n        this.goToPreviousSlide();\n      } else if (pointerEvent.direction === OdoPointer.Direction.LEFT) {\n        this.goToNextSlide();\n      }\n    }\n  }\n\n  /**\n   * The click listener is bound to the main element. Inside the handler, the target\n   * of the click is tested and if it is a pagination dot or paddle, navigation\n   * will be started.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleClick(evt) {\n    const { target } = evt;\n    let willNavigate = false;\n\n    // Determine what was clicked.\n    const dot = target.closest('.' + Carousel.Classes.PAGINATION_DOT);\n    const prev = target.closest('.' + Carousel.Classes.PADDLE_PREV);\n    const next = target.closest('.' + Carousel.Classes.PADDLE_NEXT);\n\n    // Navigation dot.\n    if (dot) {\n      willNavigate = true;\n      this.setSelectedIndex(parseInt(dot.getAttribute('data-index'), 10));\n\n    // Left paddle or child of left paddle.\n    } else if (prev) {\n      willNavigate = true;\n      this.goToPreviousSlide();\n\n    // Right paddle or child of right paddle.\n    } else if (next) {\n      willNavigate = true;\n      this.goToNextSlide();\n\n    // If the carousel slides have links in them, some browsers (Firefox), will\n    // emit the click event even after a drag if the mouse is still on the\n    // clickable element.\n    } else if (this.isTransitioning) {\n      evt.preventDefault();\n    }\n\n    if (willNavigate) {\n      evt.preventDefault();\n\n      // Pause slideshow if it's playing.\n      this.pauseSlideshow();\n    }\n  }\n\n  /**\n   * Stop animations that were ongoing when you started to drag.\n   * @private\n   */\n  _handleDragStart() {\n    this.pauseSlideshow();\n    this._cancelMovement();\n\n    // Remove transition while dragging.\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n  }\n\n  /**\n   * Pointer move event. Set a friction value if on the first/last slide and\n   * going towards the edge.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragMove({ delta }) {\n    this.hasDragged = this.isVertical ?\n      Math.abs(delta.y) > 0 :\n      Math.abs(delta.x) > 0;\n    if (!this.options.isLooped) {\n      const friction = this._isMovingTowardsEdge(delta.x, delta.y) ? 0.4 : 1;\n      this.draggable.friction = friction;\n    }\n  }\n\n  /**\n   * Depending on how fast you were dragging, either proceed to an adjacent\n   * slide or reset position to the nearest one.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    this.draggable.friction = 1;\n    this.navigateAfterDrag(evt.velocity, evt.axisDirection, evt.didMoveOnAxis);\n    this.hasDragged = false;\n    this._isOffset = false;\n  }\n\n  _shouldGoToPrevious(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isFirstSlide()) && (\n      direction === OdoPointer.Direction.RIGHT ||\n      direction === OdoPointer.Direction.DOWN);\n  }\n\n  _shouldGoToNext(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isLastSlide()) && (\n      direction === OdoPointer.Direction.LEFT ||\n      direction === OdoPointer.Direction.UP);\n  }\n\n  /**\n   * Decide what to do after the user drags the carousel.\n   * @param {Coordinate} velocity Velocity for x and y directions.\n   * @param {OdoPointer.Direction} direction Drag direction.\n   * @param {boolean} didMoveOnAxis Whether the drag direction was on the defined axis.\n   * @protected\n   */\n  navigateAfterDrag(velocity, direction, didMoveOnAxis) {\n    const hasVelocity = this.hasDragged && this.draggable.pointer.hasVelocity(velocity);\n\n    // If dragging has not occurred, the user simply clicked on the carousel.\n    // If the user is quickly navigating through the carousel, then clicks on\n    // it, the movement will be canceled, but it wouldn't go anywhere because it\n    // appears to be going to the same slide. Determine if the carousel is still\n    // between slides (offset). If it is, it needs to go to the nearest slide.\n    if (!this.hasDragged) {\n      this._isOffset =\n        Math.abs(Math.round(this._getCarouselOffset())) > Math.round(this._startEdge);\n    }\n\n    // Previous.\n    if (this._shouldGoToPrevious(hasVelocity, direction)) {\n      this.goToNearestSlide(false);\n\n    // Next.\n    } else if (this._shouldGoToNext(hasVelocity, direction)) {\n      this.goToNearestSlide(true);\n\n    // Not enough velocity, go to the nearest slide.\n    // The distance must at least be 1, otherwise gotoSlide creates an event\n    // listener for moving the element by zero pixels and the transition end\n    // event doesn't fire.\n    } else if (didMoveOnAxis || this._isOffset) {\n      this.goToNearestSlide();\n    }\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {CarouselEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Whether the carousel is being dragged towards an edge.\n   * @param {number} deltaX Change in x during drag.\n   * @param {number} deltaY Change in y during drag.\n   * @return {boolean}\n   * @private\n   */\n  _isMovingTowardsEdge(deltaX, deltaY) {\n    const toStartEdge = this.isVertical ?\n      deltaY > 0 :\n      deltaX > 0;\n    const toEndEdge = this.isVertical ?\n      deltaY < 0 :\n      deltaX < 0;\n\n    return (this.isFirstSlide() && toStartEdge) || (this.isLastSlide() && toEndEdge);\n  }\n\n  /**\n   * Remove event listeners, DOM references, inline styles, class names, paddles,\n   * and pagination added by Carousel.\n   */\n  dispose() {\n    if (this._timer) {\n      this._timer.dispose();\n    }\n\n    this._removeA11yAttributes();\n    this._removePaddles();\n    this._removePagination();\n\n    // Reset container styles.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = '';\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION] = '';\n\n    if (this.options.isFade) {\n      this.pointer.off(OdoPointer.EventType.END, this._onPointerEnd);\n      this.pointer.dispose();\n\n      this.getSlides().forEach((slide) => {\n        slide.style[OdoDevice.Dom.TRANSITION] = '';\n      });\n    } else {\n      this.draggable.off(OdoDraggable.EventType.START, this._onDragStart);\n      this.draggable.off(OdoDraggable.EventType.MOVE, this._onDragMove);\n      this.draggable.off(OdoDraggable.EventType.END, this._onDragEnd);\n\n      this.draggable.dispose();\n    }\n\n    this.element.removeEventListener('click', this._onClick);\n\n    this._slides.forEach((slide) => {\n      slide.classList.remove(\n        Carousel.Classes.PAST_SLIDE,\n        Carousel.Classes.PREVIOUS_SLIDE,\n        Carousel.Classes.ACTIVE_SLIDE,\n        Carousel.Classes.NEXT_SLIDE,\n        Carousel.Classes.FUTURE_SLIDE,\n        Carousel.Classes.VISIBLE,\n        Carousel.Classes.BEHIND,\n      );\n    });\n\n    // When the carousel is bidirectional, it has cloned the first two slides\n    // and added them to the carousel element. Remove the clones.\n    if (this._isBidirectional) {\n      this._carouselEl.removeChild(this._slides[2]);\n      this._carouselEl.removeChild(this._slides[3]);\n    }\n\n    // Null out DOM refs.\n    this.element = null;\n    this._slideContainerParentEl = null;\n    this._carouselEl = null;\n    this._paddlePrevious = null;\n    this._paddleNext = null;\n    this._paginationDots = null;\n    this.draggable = null;\n    this.pointer = null;\n    this._slides.length = 0;\n  }\n\n  /**\n   * Because Object.assign only does a shallow merge, merge the template option\n   * first and then overwrite the main Object.assign result.\n   * @param {Object} options Options object.\n   * @return {Object} Merged options object with defaults.\n   */\n  static getOptions(options) {\n    const templates = Object.assign({}, Carousel.Defaults.template, options.template);\n    const opts = Object.assign({}, Carousel.Defaults, options);\n    opts.template = templates;\n    return opts;\n  }\n}\n\nObject.assign(Carousel, settings);\n\nCarousel.template = templateEngine;\nCarousel.CarouselEvent = CarouselEvent;\n\n// Export for testing.\nCarousel._getTranslate = getTranslate;\n\nexport default Carousel;\n"],"names":["CarouselEvent","type","carousel","optFrom","optTo","target","element","from","to","hasSlideChanged","defaultPrevented","preventDefault","EventType","WILL_NAVIGATE","SLIDE_START","SLIDE_END","Classes","BASE","FADE","VERTICAL","WRAPPER","CAROUSEL_ELEMENT","SLIDE","ACTIVE_SLIDE","PREVIOUS_SLIDE","PAST_SLIDE","NEXT_SLIDE","FUTURE_SLIDE","VISIBLE","BEHIND","PAGINATION","PAGINATION_DOT","PAGINATION_DOT_SELECTED","PADDLES","PADDLE","PADDLE_NEXT","PADDLE_PREV","PADDLE_DISABLED","SLIDE_CHILD","Defaults","startIndex","isVertical","isLooped","isJumped","isFade","isCentered","neighborCount","slideshowSpeed","animationSpeed","crossfadeAmount","easing","pagination","getNavPaddleHtml","getPaginationHtml","template","paddles","paddleNext","paddlePrev","paddleNextInner","paddlePrevInner","paginationDot","paginationDotSecondary","TRANSITION_END_WAIT","str","data","replace","match","names","split","obj","property","length","i","call","undefined","getTranslate","x","y","array","parseFloat","count","uniqueId","toggleFocusability","parent","canFocus","focusableElements","elements","Array","querySelectorAll","matches","push","removeAttribute","tabIndex","Carousel","options","HTMLElement","TypeError","getOptions","_isSlidingLooped","domIndex","lastDomIndex","_selectedIndex","_slideContainerParentEl","_carouselEl","_slides","_isJumped","_isEnabled","_posAttr","_offsetPosition","capitalize","_dimensionAttr","_translateAxis","isTransitioning","_transitionId","_hasSlideChildren","_isDraggable","hasDragged","_isOffset","_timer","_crossfadeTimeout","_startEdge","draggable","pointer","_isBidirectional","resetSync","reset","decorate","getElementsByClass","className","context","getElementsByClassName","getElementByClass","_saveDomElements","_decorateBidirectionalCarousel","_setA11yAttributes","_renderPaddles","_renderPagination","_saveRenderedElements","_setSlideIndices","_decorateFadeCarousel","_decorateRegularCarousel","_onClick","_handleClick","bind","addEventListener","setSelectedIndex","_getSafeIndex","_setNeighborSlides","_snapToCurrentSlide","style","OdoDevice","Dom","TRANSITION_PROPERTY","Css","TRANSFORM","TRANSITION_TIMING_FUNCTION","_getSlideChildren","bindDragEvents","getSlides","forEach","slide","TRANSITION","classList","add","bindSwipeEvents","getCarouselElement","appendChild","cloneNode","getWrapper","setAttribute","giveId","_removeA11yAttributes","_paddlePrevious","_paddleNext","_paginationDots","map","dot","parseInt","getAttribute","i2","insertAdjacentHTML","_getNavPaddleHtml","_removePaddles","_removeByClass","parentNode","removeChild","prev","paddleInner","next","_getPaginationHtml","_removePagination","dots","_buildPaginationHtml","reduce","dotsHtml","arr","index","index1","slideId","id","secondaryIndex","hidden","OdoDraggable","axis","OdoPointer","Axis","Y","X","_onDragStart","_handleDragStart","_onDragMove","_handleDragMove","_onDragEnd","_handleDragEnd","on","START","MOVE","END","preventEventDefault","_onPointerEnd","_handlePointerEnd","addSlide","slideHtml","_setSlidesToLogicalOrder","selected","getSelectedIndex","getSlide","_getDomIndex","logicalIndex","getSlideIndices","indexOf","_getLogicalIndex","isIndexOutOfRange","_getRelativeIndex","clampIndexToSlides","displacement","wrapAroundList","clamp","isFirstSlide","isLastSlide","_slideIndices","len","optSlide","_moveIndex","currentValue","toIndex","clampedIndex","fromIndex","splice","_swapIndexes","logIndex1","logIndex2","domIndexOfLogicalIndex1","_getPositions","slideSet","bounds","getBoundingClientRect","el","_setDraggableEnabled","enabled","isEnabled","setDraggable","isDraggable","_getNewPosition","destinationSlide","destinationPosition","carouselSize","getSize","destinationSize","wrapperSize","position","_getPositionForSlideChildren","childrenSum","getElementsSize","slideSize","newPosition","_getCssPosition","pos","frag","document","createDocumentFragment","_setNeighborSlidesForJump","toDomIndex","toLogicalIndex","currentLogicalIndex","destinationDomIndex","_swapSlides","index2","swapElements","startSlideshow","Timer","_slideshowTimerExpired","start","pauseSlideshow","_isSlideshowPlaying","stop","isTicking","getInnocentNeighbor","iterator","isNext","currentSlideEl","getNthSibling","firstElementChild","getNeighborInsertionIndex","currentDomIndex","_setNeighborSlide","relativePos","indices","logicalNeighborIndex","innocentNeighbor","insertionIndex","neighborEl","insertBefore","goToSlide","_maybeSetJumpedSlides","noAnimation","Math","abs","_canNavigate","isSameSlideWithAnimation","isOffset","_toNewSlide","_emitEvent","_moveToPosition","TRANSITION_DURATION","onTransitionEnd","_transitionDone","_getCarouselOffset","matrix","getComputedStyle","translate","round","toLowerCase","slideOffset","_cancelMovement","cancelTransitionEnd","remove","offset","newSlideOffset","update","fadeToSlide","nextSlide","previousSlide","setTimeout","updatedDomIndex","adjustedPosition","canNavigate","_setSlidesState","_setPaddleState","_setPaginationState","goToNearestSlide","positions","closest","goToNextSlide","goToPreviousSlide","selectedIndex","past","previous","future","isActive","toggle","notLooped","first","last","pointerEvent","hasVelocity","velocity","direction","Direction","RIGHT","LEFT","evt","willNavigate","delta","friction","_isMovingTowardsEdge","navigateAfterDrag","axisDirection","didMoveOnAxis","_shouldGoToPrevious","DOWN","_shouldGoToNext","UP","event","emit","deltaX","deltaY","toStartEdge","toEndEdge","dispose","off","removeEventListener","templates","Object","assign","opts","TinyEmitter","settings","templateEngine","_getTranslate"],"mappings":"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"}