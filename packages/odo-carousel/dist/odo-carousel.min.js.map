{"version":3,"file":"odo-carousel.min.js","sources":["../src/carousel-event.js","../src/utils.js","../src/carousel.js","../src/settings.js","../src/template-engine.js"],"sourcesContent":["\nclass CarouselEvent {\n  /**\n   * Object representing a carousel event.\n   * @param {string} type Event type.\n   * @param {Carousel} carousel The carousel instance.\n   * @param {number=} optFrom The logical index the carousel is coming from.\n   * @param {number=} optTo The logical index the carouesl is going to.\n   * @constructor\n   */\n  constructor(type, carousel, optFrom, optTo) {\n    this.type = type;\n\n    /** @type {Element} */\n    this.target = carousel.element;\n\n    /** @type {number} carousel slid from this index. */\n    this.from = optFrom;\n\n    /** @type {number} carousel slid to this index. */\n    this.to = optTo;\n\n    /** @type {boolean} Whether the carousel actually changed slides. */\n    this.hasSlideChanged = optFrom !== optTo;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default CarouselEvent;\n","export function getTranslate(str) {\n  // If no transform is set, the computed transform will be \"none\".\n  if (str === 'none') {\n    return {\n      x: 0,\n      y: 0,\n    };\n  }\n\n  const array = str.match(/(-?[\\d.]+)/g);\n  return {\n    x: parseFloat(array[4]),\n    y: parseFloat(array[5]),\n  };\n}\n\nlet count = 0;\nexport function uniqueId() {\n  count += 1;\n  return `odo-carousel${count}`;\n}\n\n/**\n * Find every element within the parent which is focusable via tabbing and\n * enable/disable it. Ideally, some property could be set on the parent\n * element itself to prevent tabbing into it. visibility:hidden accomplishes\n * this, but there can be slides in view which are not the current slide.\n * @param {Element} parent Ancestor element to disable tabbing into.\n * @param {boolean} canFocus Whether to enable or disable focusability.\n */\nexport function toggleFocusability(parent, canFocus) {\n  const focusableElements = 'a[href],button,details,iframe,input,textarea,select,*[tabindex]';\n  const elements = Array.from(parent.querySelectorAll(focusableElements));\n\n  // Test the parent element itself. Odo Helpers polyfills `matches`.\n  if (parent.matches(focusableElements)) {\n    elements.push(parent);\n  }\n\n  for (let i = elements.length - 1; i >= 0; i--) {\n    if (canFocus) {\n      // Prefer resetting the tabIndex property by using removeAttribute to lets\n      // the browser decide if it should go back to 0 (like if it was a button)\n      // or to -1 if it wasn't originally focusable.\n      elements[i].removeAttribute('tabindex');\n    } else {\n      elements[i].tabIndex = -1;\n    }\n  }\n}\n","/**\n * @fileoverview A UI Component for creating versatile carousels. They are\n * peformant, draggable, and can ininitely loop.\n *\n * @author glen@odopod.com (Glen Cheney)\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport OdoPointer from '@odopod/odo-pointer';\nimport OdoDraggable from '@odopod/odo-draggable';\nimport {\n  cancelTransitionEnd,\n  capitalize,\n  clamp,\n  closest,\n  getElementsSize,\n  getNthSibling,\n  getSize,\n  giveId,\n  onTransitionEnd,\n  swapElements,\n  Timer,\n  wrapAroundList,\n} from '@odopod/odo-helpers';\n\nimport CarouselEvent from './carousel-event';\nimport settings from './settings';\nimport templateEngine from './template-engine';\nimport { getTranslate, toggleFocusability, uniqueId } from './utils';\n\nclass Carousel extends TinyEmitter {\n  /**\n   * @param {Element} element The outermost carousel element.\n   * @param {Object} [options] An options object.\n   * @constructor\n   * @throws {TypeError} if element isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!(element instanceof Element)) {\n      throw new TypeError(`OdoCarousel requires an element. Got: \"${element}\"`);\n    }\n\n    this.element = element;\n\n    /**\n     * Deep copy from the defaults and override defaults with options passed in.\n     * @public\n     */\n    this.options = Carousel.getOptions(options);\n\n    /**\n     * Whether the carousel is vertical or horizontal.\n     * @type {boolean}\n     * @protected\n     */\n    this.isVertical = this.options.isVertical;\n\n    /**\n     * Whether this is a looped carousel which is not a fading carousel.\n     * @type {boolean}\n     */\n    this._isSlidingLooped = this.options.isLooped && !this.options.isFade;\n\n    /**\n     * The DOM index of the current slide element within the slides' parent.\n     * @type {number}\n     * @protected\n     */\n    this.domIndex = 0;\n\n    /**\n     * The previous domIndex value.\n     * @type {number}\n     * @protected\n     */\n    this.lastDomIndex = 0;\n\n    /**\n     * Current logical index.\n     * @type {number}\n     */\n    this._selectedIndex = 0;\n\n    /**\n     * The slide container's parent.\n     * @type {Element}\n     * @private\n     */\n    this._slideContainerParentEl = null;\n\n    /**\n     * The container for the slides and the element which is moved around with\n     * transforms or absolute positioning.\n     * @type {Element}\n     * @private\n     */\n    this._carouselEl = null;\n\n    /**\n     * An array of slides (elements) in the carousel.\n     * @type {Array.<!Element>}\n     * @private\n     */\n    this._slides = [];\n\n    /**\n     * Whether the carousel is currently skipping slides. For example, going from\n     * slide 1 to 3, a jumping carousel repositions the slides so that 3 is next\n     * to 1 and only has to animate one slide length to get to it. This flag\n     * indicates a slide has been repositioned.\n     * @type {boolean}\n     * @private\n     */\n    this._isJumped = false;\n\n    /**\n     * Whether the carousel is able to be used. This can be changed with the\n     * `setEnabled` method.\n     * @type {boolean}\n     * @private\n     */\n    this._isEnabled = true;\n\n    /**\n     * Top or left.\n     * @type {string}\n     * @private\n     */\n    this._posAttr = this.isVertical ? 'top' : 'left';\n\n    /**\n     * offsetTop or offsetLeft.\n     * @type {string}\n     * @private\n     */\n    this._offsetPosition = 'offset' + capitalize(this._posAttr);\n\n    /**\n     * Height or width.\n     * @type {string}\n     * @private\n     */\n    this._dimensionAttr = this.isVertical ? 'height' : 'width';\n\n    /**\n     * Value used in `translate{X|Y}()`.\n     * @type {string}\n     */\n    this._translateAxis = this.isVertical ? 'Y' : 'X';\n\n    /**\n     * A flag indicating that the carousel is animating. It also will have\n     * a transition end event lister bound to it if the browser can\n     * transition transforms.\n     * @type {boolean}\n     * @protected\n     */\n    this.isTransitioning = false;\n\n    /**\n     * The id returned from onTransitionEnd which is used to cancel\n     * the transitionend listener.\n     * @type {string}\n     */\n    this._transitionId = null;\n\n    /**\n     * If a selector is specified, gotoSlide will look for this on the last\n     * slide and not reveal unneccesary whitespace to the right of the last\n     * matched element.\n     * @type {boolean}\n     * @private\n     */\n    this._hasSlideChildren = false;\n\n    /**\n     * Default to true for being able to drag the carousel between slides.\n     * @type {boolean}\n     * @private\n     */\n    this._isDraggable = true;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the carousel is at a resting position or between slides.\n     * @type {boolean}\n     */\n    this._isOffset = false;\n\n    /**\n     * A Timer used to make the carousel an autoplaying slideshow.\n     * @type {Timer}\n     * @private\n     */\n    this._timer = null;\n\n    /**\n     * Time, in milliseconds, to wait before adding zero opacity to the slide,\n     * which triggers the css transition. timeout = speed - (speed * %).\n     * @type {number}\n     * @private\n     */\n    this._crossfadeTimeout = this.options.animationSpeed -\n        (this.options.animationSpeed * this.options.crossfadeAmount);\n\n    /**\n     * When carousel slides are centered, they won't be aligned with the starting\n     * edge of the carousel wrapper. The starting edge (relative zero) is used\n     * to determine which slide is closest to the current position.\n     * @type {number}\n     */\n    this._startEdge = 0;\n\n    /**\n     * Draggable attached to the carousel element. Used for non-fade carousels.\n     * @type {OdoDraggable}\n     */\n    this.draggable = null;\n\n    /**\n     * Pointer attached to the main element. Used for fading carousels.\n     * @type {OdoDraggable}\n     */\n    this.pointer = null;\n\n    /**\n     * Carousels containing only two slides with looping functionality are special\n     * cases. Slides need to be duplicated and pagination needs to be rendered\n     * differently. This is because in order for the user to navigate in either\n     * direction from the active slide, the second slide would need to be present in\n     * both the 'previous' and 'next' positions. 'Bidirectional' will refer to\n     * carousels with content that unnaturally exists for the sake of navigational\n     * purposes.\n     * @type {boolean}\n     */\n    this._isBidirectional = false;\n\n    // Deprecated method.\n    this.resetSync = this.reset;\n\n    // Go.\n    this.decorate();\n  }\n\n  /**\n   * Finds an element within this class' main element based on a class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optionally provide the context (scope)\n   *     for the query. Default is the main element of the class.\n   * @return {Array.<Element>} An array which may or may not contain the element\n   *     which was searched for.\n   */\n  getElementsByClass(className, context = this.element) {\n    return Array.from(context.getElementsByClassName(className));\n  }\n\n  /**\n   * Retrieve an element by its class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optinal scope for search.\n   * @return {?Element} The element or null if it isn't found.\n   */\n  getElementByClass(className, context) {\n    return this.getElementsByClass(className, context)[0] || null;\n  }\n\n  /**\n   * Modify the DOM to be a carousel.\n   */\n  decorate() {\n    this._saveDomElements();\n\n    // After we determine the number of slides, we have enough information to decide if\n    // this carousel will be a special bidirectional one.\n    if (this.options.isLooped && this._slides.length === 2) {\n      this._decorateBidirectionalCarousel();\n    }\n\n    this._setA11yAttributes();\n    this._renderPaddles();\n\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    this._setSlideIndices();\n\n    if (this.options.isFade) {\n      this._decorateFadeCarousel();\n    } else {\n      this._decorateRegularCarousel();\n    }\n\n    this._onClick = this._handleClick.bind(this);\n    this.element.addEventListener('click', this._onClick);\n\n    // Set the selected index without animation.\n    this.setSelectedIndex(this._getSafeIndex(this.options.startIndex), true);\n\n    // Changes viewport, so it needs to come after the goto zero.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateRegularCarousel() {\n    // Add easing to container\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_PROPERTY] = OdoDevice.Css.TRANSFORM;\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_TIMING_FUNCTION] = this.options.easing;\n\n    this._hasSlideChildren = this._getSlideChildren().length > 0;\n\n    this.bindDragEvents();\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateFadeCarousel() {\n    this._isDraggable = false;\n\n    // Add transitions to each slide.\n    this.getSlides().forEach((slide, i) => {\n      slide.style[OdoDevice.Dom.TRANSITION] = 'opacity ' +\n        this.options.animationSpeed + 'ms linear';\n\n      // The first slide needs to have the visible class.\n      if (i === 0) {\n        slide.classList.add(Carousel.Classes.VISIBLE);\n      }\n    });\n\n    this.bindSwipeEvents();\n  }\n\n  /**\n   * Sets up the additional DOM modifications that will be needed for bidirectional\n   * carousels. We will essentially be duplicating both carousel slides so that no\n   * matter the current index, the active slide will alway have neighbors on either side.\n   * Then later on, we hide the additional pagination.\n   * @private\n   */\n  _decorateBidirectionalCarousel() {\n    // Bidirectional carousels automatically will need to become a jumped carousels,\n    // since we will be adding artificial slides that ruin natural navigation.\n    this._isBidirectional = true;\n    this._isJumped = true;\n\n    // Turn 2 slides into 4.\n    this._slides.forEach((slide) => {\n      this.getCarouselElement().appendChild(slide.cloneNode(true));\n    });\n\n    // Update the global slides variable to include the new elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Set static accessibility attributes.\n   */\n  _setA11yAttributes() {\n    this.getWrapper().setAttribute('aria-live', 'polite');\n    this.getCarouselElement().setAttribute('role', 'list');\n    this.getSlides().forEach((slide) => {\n      giveId(slide, uniqueId);\n      slide.setAttribute('role', 'listitem');\n    });\n  }\n\n  /**\n   * Remove static accessibility attributes.\n   */\n  _removeA11yAttributes() {\n    this.getWrapper().removeAttribute('aria-live');\n    this.getCarouselElement().removeAttribute('role');\n    this.getSlides().forEach((slide) => {\n      slide.removeAttribute('role');\n    });\n  }\n\n  /**\n   * Store references to commonly used DOM elements.\n   * @private\n   */\n  _saveDomElements() {\n    // Element which wraps the element which contains all the slides.\n    this._slideContainerParentEl = this.getElementByClass(Carousel.Classes.WRAPPER);\n\n    // Element which contains all the slides.\n    this._carouselEl = this.getElementByClass(Carousel.Classes.CAROUSEL_ELEMENT);\n\n    // Because carousels can have carousels inside them, finding elements by\n    // class retrieves too many elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Store references to generated elements. The pagination dots cannot be save in\n   * `_saveDomElements` because the number of slides is not yet known.\n   * @private\n   */\n  _saveRenderedElements() {\n    this._paddlePrevious = this.getElementByClass(Carousel.Classes.PADDLE_PREV);\n    this._paddleNext = this.getElementByClass(Carousel.Classes.PADDLE_NEXT);\n    this._paginationDots = this.getElementsByClass(Carousel.Classes.PAGINATION_DOT)\n      .map(dot => ({\n        dot,\n        i: parseInt(dot.getAttribute('data-index'), 10),\n        i2: parseInt(dot.getAttribute('data-secondary-index'), 10),\n      }));\n  }\n\n  /**\n   * Add navigation paddles (previous and next buttons) to the carousel.\n   * @private\n   */\n  _renderPaddles() {\n    this.element.insertAdjacentHTML('beforeend', this._getNavPaddleHtml());\n  }\n\n  /**\n   * Remove navigation paddles from the carousel (if they exist).\n   * @private\n   */\n  _removePaddles() {\n    this._removeByClass(Carousel.Classes.PADDLES);\n  }\n\n  /**\n   * Remove a child element by class, if it exists.\n   * @param {string} className Class name of the element to find and remove.\n   */\n  _removeByClass(className) {\n    const element = this.getElementByClass(className);\n    if (element) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  /**\n   * Retrieves the html string for the nav paddles from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getNavPaddleHtml() {\n    if (typeof this.options.getNavPaddleHtml === 'function') {\n      return this.options.getNavPaddleHtml.call(this, this);\n    }\n\n    return Carousel.template(this.options.template.paddles, {\n      prev: Carousel.template(this.options.template.paddlePrev, {\n        paddleInner: this.options.template.paddlePrevInner,\n      }),\n      next: Carousel.template(this.options.template.paddleNext, {\n        paddleInner: this.options.template.paddleNextInner,\n      }),\n    });\n  }\n\n  /**\n   * Add pagination (the dots) to the carousel.\n   * @private\n   */\n  _renderPagination() {\n    this.element.insertAdjacentHTML('beforeend', this._getPaginationHtml());\n  }\n\n  /**\n   * Remove pagination from the carousel (if they exist).\n   * @private\n   */\n  _removePagination() {\n    this._removeByClass(Carousel.Classes.PAGINATION);\n  }\n\n  /**\n   * Retrieves the html string for the pagination from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getPaginationHtml() {\n    if (typeof this.options.getPaginationHtml === 'function') {\n      return this.options.getPaginationHtml.call(this, this);\n    }\n\n    const dots = this._buildPaginationHtml();\n\n    return Carousel.template(this.options.template.pagination, {\n      dots,\n    });\n  }\n\n  /**\n   * Builds and returns the HTML string of the pagination dots.\n   * Bidirectional carousels utilize a separate template that includes\n   * secondary indices.\n   * @return {string}\n   * @private\n   */\n  _buildPaginationHtml() {\n    const template = this._isBidirectional ?\n      this.options.template.paginationDotSecondary :\n      this.options.template.paginationDot;\n\n    return this.getSlides().reduce((dotsHtml, slide, i, arr) => {\n      const data = {\n        index: i,\n        index1: i + 1,\n        slideId: slide.id,\n      };\n\n      if (this._isBidirectional) {\n        // If you are rendering pagination for a bidirectional carousel, you will need\n        // secondary indices computed. This returns the secondary index based on the primary.\n        // i.e. For 4 slides, 1 returns 3, 2 returns 4 and the inverse.\n        data.secondaryIndex = i > 1 ? i % 2 : i + 2;\n        data.hidden = i >= arr.length / 2;\n      }\n\n      return dotsHtml + Carousel.template(template, data);\n    }, '');\n  }\n\n  /**\n   * Listen for dragging events.\n   * @protected\n   */\n  bindDragEvents() {\n    this.draggable = new OdoDraggable(this._carouselEl, {\n      axis: this.isVertical ? OdoPointer.Axis.Y : OdoPointer.Axis.X,\n    });\n\n    this._onDragStart = this._handleDragStart.bind(this);\n    this._onDragMove = this._handleDragMove.bind(this);\n    this._onDragEnd = this._handleDragEnd.bind(this);\n\n    this.draggable.on(OdoDraggable.EventType.START, this._onDragStart);\n    this.draggable.on(OdoDraggable.EventType.MOVE, this._onDragMove);\n    this.draggable.on(OdoDraggable.EventType.END, this._onDragEnd);\n  }\n\n  /**\n   * Listen for the pointer to come up from the screen, then execute a callback.\n   * @protected\n   */\n  bindSwipeEvents() {\n    this.pointer = new OdoPointer(this._carouselEl, {\n      axis: OdoPointer.Axis.X,\n      preventEventDefault: true,\n    });\n\n    this._onPointerEnd = this._handlePointerEnd.bind(this);\n    this.pointer.on(OdoPointer.EventType.END, this._onPointerEnd);\n  }\n\n  /**\n   * Add a slide to the end of the carousel.\n   * @param {string} slideHtml Html string for the slide.\n   */\n  addSlide(slideHtml) {\n    // Make sure looped carousels are in the right order without any neighbors.\n    this._setSlidesToLogicalOrder();\n\n    // Insert new slide at the end.\n    this._carouselEl.insertAdjacentHTML('beforeend', slideHtml);\n\n    this.reset();\n  }\n\n  /**\n   * Synchronously reset the slides. Use this when you're sure the elements\n   * within the carousel are done changing.\n   */\n  reset() {\n    // Update the slides.\n    this._saveDomElements();\n\n    // Remove old paddles + pagination.\n    this._removePaddles();\n    this._removePagination();\n\n    this._setA11yAttributes();\n\n    // Re-render paddles and pagination.\n    this._renderPaddles();\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    // Update slide indices now that there's a new slide.\n    this._setSlideIndices();\n\n    // Go to the slide it was at before.\n    const selected = this.getSelectedIndex();\n    this.setSelectedIndex(0, true);\n\n    // Try going back to the previous one.\n    this.setSelectedIndex(selected, true);\n\n    // Set neighbors slides for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Retreives the cached carousel wrapper element.\n   * @return {Element}\n   */\n  getWrapper() {\n    return this._slideContainerParentEl;\n  }\n\n  /**\n   * Retreives the cached carousel element.\n   * @return {Element}\n   */\n  getCarouselElement() {\n    return this._carouselEl;\n  }\n\n  /**\n   * Returns the array of slides in the carousel.\n   * @return {!Array.<!Element>} The slides array.\n   */\n  getSlides() {\n    return this._slides;\n  }\n\n  /**\n   * Get the slide element at the given index.\n   * @param {number} index The logical index of the slide you want.\n   * @return {Element} The slide element.\n   */\n  getSlide(index) {\n    return this.getSlides()[index];\n  }\n\n  /**\n   * Get the index of the currently active slide.\n   * @return {number} Index of the current slide.\n   */\n  getSelectedIndex() {\n    return this._selectedIndex;\n  }\n\n  /**\n   * Translates the original index to the current DOM index.\n   * @param {number} logicalIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getDomIndex(logicalIndex) {\n    return this.getSlideIndices().indexOf(logicalIndex);\n  }\n\n  /**\n   * Translates the DOM index to the original logical index.\n   * @param {number} domIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getLogicalIndex(domIndex) {\n    return this.getSlideIndices()[domIndex];\n  }\n\n  /**\n   * Takes a logical index which could potentially be out of range and returns\n   * the logical index within range.\n   * @param {number} logicalIndex Logical index to make safe.\n   * @return {number} Safe logical index.\n   * @private\n   */\n  _getSafeIndex(logicalIndex) {\n    if (this.isIndexOutOfRange(logicalIndex)) {\n      if (this.options.isLooped) {\n        return this._getRelativeIndex(logicalIndex, 0);\n      }\n      return this.clampIndexToSlides(logicalIndex);\n    }\n    return logicalIndex;\n  }\n\n  /**\n   * Calculates the offset index for a circular list.\n   * @param {number} index Starting index.\n   * @param {number} displacement Offset from the starting index. Can be negative\n   *     or positive. For example, -2 or 2.\n   * @param {number} length Length of the list.\n   * @return {number} The index of the relative displacement, wrapping around\n   *     the end of the list to the start when the displacement is larger than\n   *     what's left in the list.\n   */\n  _getRelativeIndex(index, displacment) {\n    return wrapAroundList(index, displacment, this._slides.length);\n  }\n\n  /**\n   * @return {boolean} Whether a given index is out of range of the carousel.\n   */\n  isIndexOutOfRange(index) {\n    return index <= -1 || index >= this._slides.length;\n  }\n\n  clampIndexToSlides(index) {\n    return clamp(index, 0, this._slides.length - 1);\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the first slide.\n   */\n  isFirstSlide() {\n    return this.getSelectedIndex() === 0;\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the last slide.\n   */\n  isLastSlide() {\n    return this.getSelectedIndex() === this._slides.length - 1;\n  }\n\n  /**\n   * Generates the array which will follow the DOM order of the slides in their\n   * container and saves it.\n   * @private\n   */\n  _setSlideIndices() {\n    this._slideIndices = new Array(this._slides.length);\n\n    for (let i = 0, len = this._slides.length; i < len; i++) {\n      this._slideIndices[i] = i;\n    }\n  }\n\n  /** @return {!Array.<!number>} The slide indices array. */\n  getSlideIndices() {\n    return this._slideIndices;\n  }\n\n  /**\n   * Retrieves the slide children.\n   * @param {Element=} optSlide Slide to look within.\n   * @return {Array.<Element>} NodeList of slide children.\n   * @private\n   */\n  _getSlideChildren(optSlide) {\n    return this.getElementsByClass(Carousel.Classes.SLIDE_CHILD, optSlide);\n  }\n\n  /**\n   * Modifieds the _slideIndices array to represent the DOM order of the slides\n   * within their container.\n   * @param {number} currentValue The value to be moved. This is the same as the\n   *     logical index.\n   * @param {number} toIndex The location to move it to in the array. It will be\n   *     clamped between zero and one less than the length of the array. This is\n   *     also referred to as the DOM index.\n   * @private\n   */\n  _moveIndex(currentValue, toIndex) {\n    const clampedIndex = this.clampIndexToSlides(toIndex);\n    const fromIndex = this._getDomIndex(currentValue);\n    const arr = this._slideIndices;\n\n    // Array moveIndex.\n    arr.splice(clampedIndex, 0, arr.splice(fromIndex, 1)[0]);\n  }\n\n  /**\n   * Swaps positions of two logical indices in the slide indices array.\n   * @param {number} logIndex1 First logical index which will be swappeed.\n   * @param {number} logIndex2 Second logical index to be swapped.\n   * @private\n   */\n  _swapIndexes(logIndex1, logIndex2) {\n    const domIndexOfLogicalIndex1 = this._getDomIndex(logIndex1);\n    this._slideIndices[domIndexOfLogicalIndex1] = -1;\n    this._slideIndices[this._getDomIndex(logIndex2)] = logIndex1;\n    this._slideIndices[domIndexOfLogicalIndex1] = logIndex2;\n  }\n\n  /**\n   * Gets the slide positions (offsets from the left|top) array.\n   * @param {Array.<Element>} slideSet the slides array.\n   * @return {Array.<number>} array of slide positions.\n   * @private\n   */\n  _getPositions(slideSet) {\n    const bounds = this.getWrapper().getBoundingClientRect()[this._posAttr];\n    return slideSet.map(el => el.getBoundingClientRect()[this._posAttr] - bounds);\n  }\n\n  /**\n   * Enable or disable dragging.\n   * @param {boolean} enabled Whether it should be draggable.\n   * @private\n   */\n  _setDraggableEnabled(enabled) {\n    if (this.draggable) {\n      this.draggable.isEnabled = enabled;\n    } else {\n      this.pointer.isEnabled = enabled;\n    }\n  }\n\n  /**\n   * Enable or disable dragging of the carousel.\n   * @param {boolean} isDraggable Whether it should be draggable.\n   */\n  setDraggable(isDraggable) {\n    this._isDraggable = isDraggable;\n    this._setDraggableEnabled(isDraggable);\n  }\n\n  /**\n   * Public method which returns the enabled state.\n   * @return {boolean}\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  /**\n   * Toggle the enabled/disabled state of the carousel. When it's disabled, it\n   * will not be able to navigate slides.\n   * @param {boolean} enabled Whether to enable or disable.\n   */\n  set isEnabled(enabled) {\n    this._isEnabled = enabled;\n    this._setDraggableEnabled(enabled);\n  }\n\n  /**\n   * Gets the adjusted position.\n   * @param {Element} destinationSlide The slide the carousel is headed to.\n   * @return {number} The position it is.\n   * @private\n   */\n  _getNewPosition(destinationSlide) {\n    // Destination position.\n    let destinationPosition = destinationSlide[this._offsetPosition];\n\n    // Width or height of the carousel element.\n    const carouselSize = getSize(this.getCarouselElement())[this._dimensionAttr];\n\n    if (this.options.isCentered) {\n      const destinationSize = getSize(destinationSlide)[this._dimensionAttr];\n      const wrapperSize = getSize(this.getWrapper())[this._dimensionAttr];\n      this._startEdge = (wrapperSize - destinationSize) / 2;\n      destinationPosition -= this._startEdge;\n    }\n\n    let position = destinationPosition / carouselSize;\n\n    if (this._hasSlideChildren && this.isLastSlide()) {\n      // Adjust the position again if there are slide children in the last slide.\n      position = this._getPositionForSlideChildren(\n        destinationSlide,\n        destinationPosition, carouselSize,\n      );\n    }\n\n    return position;\n  }\n\n  /**\n   * Adjust the destination position again if there are slide children.\n   * @param {Element} destinationSlide Slide element.\n   * @param {number} destinationPosition Where the slide would initially go.\n   * @param {number} carouselSize Width or height of the carousel element.\n   * @return {number} New destination position.\n   * @private\n   */\n  _getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize) {\n    // Size of the combined width/height + margins of the slide children\n    // within the destination slide.\n    const childrenSum = getElementsSize(\n      this._getSlideChildren(destinationSlide),\n      this._dimensionAttr,\n    );\n\n    // width|height of the carousel slide.\n    const slideSize = getSize(destinationSlide)[this._dimensionAttr];\n\n    // The destination position minus the empty space in the next slide in px.\n    const newPosition = destinationPosition - (slideSize - childrenSum);\n\n    // Calculate the percentage from the pixel value.\n    return newPosition / carouselSize;\n  }\n\n  /**\n   * Returns the translated position based on carousel direction.\n   * @param {string} pos The position (eg \"25%\").\n   * @return {string} the css value for transform.\n   * @private\n   */\n  _getCssPosition(pos) {\n    return 'translate' + this._translateAxis + '(' + pos + ')';\n  }\n\n  /** @private */\n  _setSlidesToLogicalOrder() {\n    const frag = document.createDocumentFragment();\n\n    this._slides.forEach(frag.appendChild, frag);\n\n    this._carouselEl.appendChild(frag);\n\n    // Reset the slide indices array.\n    this._setSlideIndices();\n  }\n\n  /**\n   * If this is a jumped carousel, prepare the slides for the jump by swapping\n   * elements out and setting the `isJumped` option.\n   * @param {number} toDomIndex Index of the slide the carousel is jumping to.\n   * @return {number} If this function changed the order the slides, it returns\n   *     the new DOM index the carousel is going to. Otherwise it returns the\n   *     DOM index parameter it was given.\n   * @private\n   */\n  _setNeighborSlidesForJump(toDomIndex) {\n    const toLogicalIndex = this._getLogicalIndex(toDomIndex);\n    const currentLogicalIndex = this._getLogicalIndex(this.domIndex);\n\n    this._isJumped = true;\n\n    // Where to move the slide to. Next to the current index.\n    const destinationDomIndex = toLogicalIndex > currentLogicalIndex ?\n      this.domIndex + 1 :\n      this.domIndex - 1;\n\n    // Swap indices.\n    // Swap destination slide with current slide at the destination.\n    this._swapSlides(toLogicalIndex, this._getLogicalIndex(destinationDomIndex));\n\n    // Return the dom index the carousel is actually going to.\n    return destinationDomIndex;\n  }\n\n  /**\n   * Swap indices and DOM elements.\n   * @param {number} index1 Logical index 1.\n   * @param {number} index2 Logical index 2.\n   * @private\n   */\n  _swapSlides(index1, index2) {\n    this._swapIndexes(index1, index2);\n    swapElements(this.getSlide(index1), this.getSlide(index2));\n  }\n\n  /**\n   * This function initializes the slideshow functionality for the\n   * carousel. It sets an interval for the slideshow to continue animate\n   * based on the option slideshowSpeed.\n   */\n  startSlideshow() {\n    // Create the timer if it doesn't already exist.\n    if (!this._timer) {\n      this._timer = new Timer(\n        this._slideshowTimerExpired.bind(this),\n        this.options.slideshowSpeed, true,\n      );\n    }\n\n    this._timer.start();\n  }\n\n  /**\n   * A simple method which pauses the _timer\n   * once thats paused the slideshow will stop ticking.\n   * Can be re-initialzed by running `startSlideshow()`\n   */\n  pauseSlideshow() {\n    if (this._isSlideshowPlaying()) {\n      this._timer.stop();\n    }\n  }\n\n  /**\n   * Whether the slideshow timer exists and is currently ticking.\n   * @return {boolean}\n   * @private\n   */\n  _isSlideshowPlaying() {\n    return !!this._timer && this._timer.isTicking;\n  }\n\n  // getNthSibling returns null if it cannot find the nth sibling,\n  // but if `null` is used in `insertBefore`, it will append the element\n  // to the end.\n  getInnocentNeighbor(iterator, isNext) {\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    return isNext ?\n      getNthSibling(currentSlideEl, iterator + 1) :\n      getNthSibling(currentSlideEl, iterator, false) ||\n      this._carouselEl.firstElementChild;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNeighborInsertionIndex(iterator, isNext, currentDomIndex) {\n    return isNext ?\n      currentDomIndex + iterator + 1 :\n      currentDomIndex - iterator;\n  }\n\n  /**\n   *\n   * @param {number} iterator Neighbor index.\n   * @param {number} relativePos Neighbor index relative to the current index.\n   * @param {boolean} isNext Whether to move the slide next or previous.\n   * @private\n   */\n  _setNeighborSlide(iterator, relativePos, isNext) {\n    const index = this.getSelectedIndex();\n    const indices = this.getSlideIndices();\n\n    // Previous calls to set neighbor slide may have changed the DOM, so\n    // don't rely on stored variables.\n    const currentDomIndex = this._getDomIndex(index);\n\n    // Index of the future neighbor relative to the original DOM order.\n    const logicalNeighborIndex = this._getRelativeIndex(index, relativePos);\n\n    // Do the slides need to be rearranged? Check the current indices to see\n    // if the new neighbors are already there.\n    if (indices[currentDomIndex + relativePos] !== logicalNeighborIndex) {\n      // The slide to insert the new neighbor before.\n      const innocentNeighbor = this.getInnocentNeighbor(iterator, isNext);\n      const insertionIndex = this.getNeighborInsertionIndex(iterator, isNext, currentDomIndex);\n      const neighborEl = this.getSlide(logicalNeighborIndex);\n\n      // Move the neighbor's index to be a neighbor to the current dom index.\n      this._moveIndex(logicalNeighborIndex, insertionIndex);\n      this._carouselEl.insertBefore(neighborEl, innocentNeighbor);\n    }\n  }\n\n  /**\n   * This function makes sure that looped carousels always have a neighbor to\n   * go to. It repositions the viewport if it has to move slides around.\n   * @private\n   */\n  _setNeighborSlides() {\n    let i;\n\n    // Set the left neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, -(i + 1), false);\n    }\n\n    // Set the right neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, i + 1, true);\n    }\n  }\n\n  /**\n   * Reset the carousel back to the currently selected slide without animation.\n   */\n  _snapToCurrentSlide() {\n    this.goToSlide(this._getDomIndex(this.getSelectedIndex()), true);\n  }\n\n  /**\n   * Determine if the distance between current and destination slides is more\n   * than one slide. If it's not, there is no need to \"jump\".\n   * @param {number} domIndex DOM index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating.\n   * @return {number} DOM index of the slide to go to because moving slides\n   *     around to \"jump\" them will causes indices to change.\n   */\n  _maybeSetJumpedSlides(domIndex, noAnimation) {\n    // Determine if the distance between current and destination slides\n    // is more than one slide. If it's not, there's no need to \"jump\".\n    if (this.options.isJumped && !noAnimation && Math.abs(this.domIndex - domIndex) > 1) {\n      return this._setNeighborSlidesForJump(domIndex);\n    }\n    return domIndex;\n  }\n\n  /**\n   * Determine whether or not the carousel can navigate in its current condition.\n   * @param {number} domIndex Dom index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating there.\n   * @return {boolean}\n   */\n  _canNavigate(domIndex, noAnimation) {\n    const isSameSlideWithAnimation = domIndex === this.domIndex && !noAnimation;\n\n    // Whether the carousel would be able to move.\n    const isOffset = this.hasDragged || this._isOffset;\n\n    // 1) Whether the carousel is enabled.\n    // 2) The index is out of range and the carousel isn't set to loop. Silently\n    // exit here instead of throwing errors everywhere.\n    // 3) Trying to go to the slide it's already on with a transition and no\n    // dragging has occured or the carousel is not offset.\n    return !(\n      (!this._isEnabled) ||\n      (!this.options.isLooped && this.isIndexOutOfRange(domIndex)) ||\n      (isSameSlideWithAnimation && !isOffset));\n  }\n\n  _toNewSlide() {\n    // Set flag meaning the carousel is waiting for a transition end.\n    this.isTransitioning = true;\n\n    // Fire event saying the slide started to transition.\n    this._emitEvent(new CarouselEvent(\n      Carousel.EventType.SLIDE_START,\n      this,\n      this._getLogicalIndex(this.lastDomIndex),\n      this._getLogicalIndex(this.domIndex),\n    ));\n  }\n\n  /**\n   * Uses Css transforms to move the carousel to a new position.\n   * @param {string} position The percentage value.\n   * @param {boolean} noAnimation Whether to move with animation or not.\n   * @private\n   */\n  _moveToPosition(position, noAnimation) {\n    // Set transform.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = this._getCssPosition(position);\n\n    // Set transition speed to zero so that it happens instantly.\n    if (noAnimation) {\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n\n      // Listen for transitionend if it will animate.\n    } else {\n      // Set transition speed.\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] =\n        this.options.animationSpeed + 'ms';\n\n      // This is used as a backup to the transitionend event, which sometimes\n      // doesn't fire on iOS 7 Safari when the carousel has only been dragged a\n      // few pixels. It's set to go off ~2 frames after the transition end event\n      // should have occurred.\n      this._transitionId = onTransitionEnd(\n        this._carouselEl,\n        this._transitionDone,\n        this,\n        OdoDevice.Dom.TRANSFORM,\n        this.options.animationSpeed + Carousel.TRANSITION_END_WAIT,\n      );\n\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Calculates the offset of the carousel relative to the current slide.\n   * @return {number}\n   */\n  _getCarouselOffset() {\n    const matrix = getComputedStyle(this._carouselEl)[OdoDevice.Dom.TRANSFORM];\n\n    // Round to 1 decimal place because the `_startEdge` can be a decimal.\n    const translate = Math.round(getTranslate(matrix)[this._translateAxis.toLowerCase()] * 10) / 10;\n\n    const slideOffset = this.getSlide(this.getSelectedIndex())[this._offsetPosition];\n    return slideOffset + translate;\n  }\n\n  /**\n   * If the carousel is waiting for a transition to finish (going to a slide),\n   * but the user tells it to navigate again, the previous listener for the\n   * transition end event needs to be canceled. This allows the user to quickly\n   * click through the carousel without waiting for each navigation to finish.\n   *\n   * For jumped and looped carousels, the carousel element needs to be\n   * repositioned because setting neighbor slides will cause the elements to\n   * shift within the main carousel element. The current offset relative to\n   * the current slide is saved before moving any slide elements, then the slide\n   * elements are moved, and finally the carousel is set to appear as if the\n   * elements never moved.\n   */\n  _cancelMovement() {\n    if (!this.isTransitioning) {\n      return;\n    }\n\n    this.isTransitioning = false;\n    cancelTransitionEnd(this._transitionId);\n\n    // Fading carousels do not need to reposition themselves.\n    if (this.options.isFade) {\n      return;\n    }\n\n    // Save the offset relative to the current slide before slides are moved.\n    const carouselSize = getSize(this.getCarouselElement())[this._dimensionAttr];\n    const offset = this._getCarouselOffset();\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    // Now that the current slide has potentially moved in the DOM, update the\n    // carousel's offset.\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    const newSlideOffset = currentSlideEl[this._offsetPosition];\n    const position = (newSlideOffset - offset) / carouselSize;\n\n    // Setting the position here stops the browser from transitioning to the\n    // previous position, allowing the user to \"catch\" the carousel mid-nav.\n    this._moveToPosition((position * -100) + '%', true);\n    this.draggable.update();\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  fadeToSlide(domIndex, optNoAnimation) {\n    // Get next and previous slides.\n    const nextSlide = this.getSlide(domIndex, true);\n    const previousSlide = this.getSlide(this.domIndex, true);\n\n    // Listen for transitionend if it will animate.\n    if (!optNoAnimation) {\n      // Going to a new slide, wait for callback.\n      this._transitionId = onTransitionEnd(nextSlide, this._transitionDone, this);\n    }\n\n    // Show next slide. Put the previous behind the next.\n    nextSlide.classList.add(Carousel.Classes.VISIBLE);\n\n    if (previousSlide !== nextSlide) {\n      previousSlide.classList.add(Carousel.Classes.BEHIND);\n\n      // Delay the previous slide fading out by the specified percentage.\n      // The crossfade amount is between 0 and 1. A value of 1 means that both slides\n      // will fade at the same time. A crossfade of zero means the previous slide\n      // will wait until the next slide has completely faded in before it fades out.\n      setTimeout(() => {\n        previousSlide.classList.remove(Carousel.Classes.VISIBLE);\n      }, this._crossfadeTimeout);\n    }\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = domIndex;\n\n    // Emit event for slide start.\n    if (!optNoAnimation) {\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  goToSlide(domIndex, optNoAnimation) {\n    // Get the destion slide element from the current DOM order.\n    const destinationSlide = this.getSlide(this._getLogicalIndex(domIndex));\n\n    // If the carousel skips inbetween slides, reposition them.\n    // DOM index is reassinged here because if the slides are repositioned,\n    // the DOM index of the carousel changes.\n    const updatedDomIndex = this._maybeSetJumpedSlides(domIndex, optNoAnimation);\n\n    // The position the container will go to.\n    const adjustedPosition = (this._getNewPosition(destinationSlide) * -100) + '%';\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = updatedDomIndex;\n\n    // Set the css styles to move the carousel element. This also dispatches\n    // the slide start event if the carousel element will move with animation.\n    this._moveToPosition(adjustedPosition, optNoAnimation);\n  }\n\n  /**\n   * Helper function for going to a given index. This method should be used\n   * instead of the private one to abstract the DOM order stuff.\n   * @param {number} index The logical, zero based index of the slide you wish\n   *     the carousel to go to.\n   * @param {boolean=} optNoAnimation Optional skip the animation in goToSlide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  setSelectedIndex(index, optNoAnimation) {\n    let domIndex = this._getDomIndex(index);\n    const canNavigate = this._canNavigate(domIndex, optNoAnimation);\n\n    // Will go the the give slide.\n    if (canNavigate) {\n      // If the event's default action was prevented, return false.\n      if (this._emitEvent(new CarouselEvent(Carousel.EventType.WILL_NAVIGATE, this))) {\n        return false;\n      }\n\n      this._cancelMovement();\n\n      this._selectedIndex = this._getSafeIndex(index);\n\n      // Convert new safe logical index to a DOM index.\n      domIndex = this._getDomIndex(this._selectedIndex);\n\n      // Set new classes on the slide elements. This is also where toggling\n      // paddles and pagination should go.\n      this._setSlidesState();\n      this._setPaddleState();\n      this._setPaginationState();\n      if (this.options.isFade) {\n        this.fadeToSlide(domIndex, optNoAnimation);\n      } else {\n        this.goToSlide(domIndex, optNoAnimation);\n      }\n    }\n\n    // Otherwise, it will not go to the give slide due to unmet conditions.\n    return canNavigate;\n  }\n\n  /**\n   * Find the nearest slide, and move the carousel to that.\n   * @param {boolean} isNext Whether it should go to the nearest slide, but\n   *     only in the next direction. False means it should go previous and\n   *     anything not true or false will go to the nearest slide regardless\n   *     of direction.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNearestSlide(isNext) {\n    // Gets positions relative to the wrapper element of each slide.\n    const positions = this._getPositions(this.getSlides());\n\n    // Current position (the left side of the carousel wrapper)\n    // Gets the closest value in the array to the given value.\n    // Index of the closest value.\n    let logicalIndex = positions.indexOf(closest(positions, this._startEdge));\n\n    // When going to a next or previous slide, the closest index could\n    // still be the one that's currently selected, but the carousel should\n    // still move next/previous because it has enough velocity.\n    if (logicalIndex === this.getSelectedIndex()) {\n      if (isNext === true) {\n        logicalIndex = this._getSafeIndex(logicalIndex + 1);\n      } else if (isNext === false) {\n        logicalIndex = this._getSafeIndex(logicalIndex - 1);\n      }\n    }\n\n    return this.setSelectedIndex(logicalIndex);\n  }\n\n  /**\n   * Go to the next slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNextSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() + 1);\n  }\n\n  /**\n   * Go to the previous slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToPreviousSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() - 1);\n  }\n\n  /**\n   * Sets the past, previous, active, next, and future classes to the appropriate\n   * slides.\n   * @private\n   */\n  _setSlidesState() {\n    const selectedIndex = this.getSelectedIndex();\n    const past = this._getSafeIndex(selectedIndex - 2);\n    const previous = this._getSafeIndex(selectedIndex - 1);\n    const next = this._getSafeIndex(selectedIndex + 1);\n    const future = this._getSafeIndex(selectedIndex + 2);\n\n    // This works because the _slides array does not mimic the DOM order.\n    this.getSlides().forEach((slide, i) => {\n      const isActive = i === selectedIndex;\n\n      toggleFocusability(slide, isActive);\n\n      slide.setAttribute('aria-hidden', !isActive);\n\n      // Active slide.\n      slide.classList.toggle(Carousel.Classes.ACTIVE_SLIDE, isActive);\n\n      // Previous previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PAST_SLIDE,\n        i === past && selectedIndex !== past && previous !== past,\n      );\n\n      // Previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PREVIOUS_SLIDE,\n        i === previous && selectedIndex !== previous,\n      );\n\n      // Next slide.\n      slide.classList.toggle(\n        Carousel.Classes.NEXT_SLIDE,\n        i === next && selectedIndex !== next,\n      );\n\n      // Next next slide.\n      slide.classList.toggle(\n        Carousel.Classes.FUTURE_SLIDE,\n        i === future && selectedIndex !== future && next !== future,\n      );\n    });\n  }\n\n  _setPaginationState() {\n    if (this.options.pagination) {\n      const selectedIndex = this.getSelectedIndex();\n      this._paginationDots.forEach(({ dot, i, i2 }) => {\n        const selected = selectedIndex === i || selectedIndex === i2;\n        dot.classList.toggle(Carousel.Classes.PAGINATION_DOT_SELECTED, selected);\n        dot.setAttribute('aria-selected', selected);\n      });\n    }\n  }\n\n  _setPaddleState() {\n    const notLooped = !this.options.isLooped;\n    if (notLooped && this._paddlePrevious) {\n      const first = this.isFirstSlide();\n      this._paddlePrevious.classList.toggle(Carousel.Classes.PADDLE_DISABLED, first);\n      this._paddlePrevious.setAttribute('aria-disabled', first);\n    }\n\n    if (notLooped && this._paddleNext) {\n      const last = this.isLastSlide();\n      this._paddleNext.classList.toggle(Carousel.Classes.PADDLE_DISABLED, last);\n      this._paddleNext.setAttribute('aria-disabled', last);\n    }\n  }\n\n  /**\n   * Callback for when the slideshow timer expires.\n   * @private\n   */\n  _slideshowTimerExpired() {\n    // Pause the timer if it's at the end.\n    if (!this.options.isLooped && this.isLastSlide()) {\n      this.pauseSlideshow();\n    } else {\n      this.goToNextSlide();\n    }\n  }\n\n  _transitionDone() {\n    const from = this._getLogicalIndex(this.lastDomIndex);\n    const to = this._getLogicalIndex(this.domIndex);\n\n    // Needs to come before setting neighbor slides.\n    this.isTransitioning = false;\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    // Neighboring slides must be set after each transition for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    if (this._isJumped || this._isSlidingLooped) {\n      this._snapToCurrentSlide();\n    }\n\n    if (this.options.isFade) {\n      this.getSlide(from).classList.remove(Carousel.Classes.BEHIND);\n    }\n\n    // No longer jumped.\n    this._isJumped = false;\n\n    // Dispatch slide end event.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_END, this, from, to));\n  }\n\n  /**\n   * Received the pointer end event.\n   * @param {PointerEvent} pointerEvent Pointer event object.\n   */\n  _handlePointerEnd(pointerEvent) {\n    if (this.pointer.hasVelocity(pointerEvent.velocity)) {\n      if (pointerEvent.direction === OdoPointer.Direction.RIGHT) {\n        this.goToPreviousSlide();\n      } else if (pointerEvent.direction === OdoPointer.Direction.LEFT) {\n        this.goToNextSlide();\n      }\n    }\n  }\n\n  /**\n   * The click listener is bound to the main element. Inside the handler, the target\n   * of the click is tested and if it is a pagination dot or paddle, navigation\n   * will be started.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleClick(evt) {\n    const { target } = evt;\n    let willNavigate = false;\n\n    // Determine what was clicked.\n    const dot = target.closest('.' + Carousel.Classes.PAGINATION_DOT);\n    const prev = target.closest('.' + Carousel.Classes.PADDLE_PREV);\n    const next = target.closest('.' + Carousel.Classes.PADDLE_NEXT);\n\n    // Navigation dot.\n    if (dot) {\n      willNavigate = true;\n      this.setSelectedIndex(parseInt(dot.getAttribute('data-index'), 10));\n\n    // Left paddle or child of left paddle.\n    } else if (prev) {\n      willNavigate = true;\n      this.goToPreviousSlide();\n\n    // Right paddle or child of right paddle.\n    } else if (next) {\n      willNavigate = true;\n      this.goToNextSlide();\n\n    // If the carousel slides have links in them, some browsers (Firefox), will\n    // emit the click event even after a drag if the mouse is still on the\n    // clickable element.\n    } else if (this.isTransitioning) {\n      evt.preventDefault();\n    }\n\n    if (willNavigate) {\n      evt.preventDefault();\n\n      // Pause slideshow if it's playing.\n      this.pauseSlideshow();\n    }\n  }\n\n  /**\n   * Stop animations that were ongoing when you started to drag.\n   * @private\n   */\n  _handleDragStart() {\n    this.pauseSlideshow();\n    this._cancelMovement();\n\n    // Remove transition while dragging.\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n  }\n\n  /**\n   * Pointer move event. Set a friction value if on the first/last slide and\n   * going towards the edge.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragMove({ delta }) {\n    this.hasDragged = this.isVertical ?\n      Math.abs(delta.y) > 0 :\n      Math.abs(delta.x) > 0;\n    if (!this.options.isLooped) {\n      const friction = this._isMovingTowardsEdge(delta.x, delta.y) ? 0.4 : 1;\n      this.draggable.friction = friction;\n    }\n  }\n\n  /**\n   * Depending on how fast you were dragging, either proceed to an adjacent\n   * slide or reset position to the nearest one.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    this.draggable.friction = 1;\n    this.navigateAfterDrag(evt.velocity, evt.axisDirection, evt.didMoveOnAxis);\n    this.hasDragged = false;\n    this._isOffset = false;\n  }\n\n  _shouldGoToPrevious(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isFirstSlide()) && (\n      direction === OdoPointer.Direction.RIGHT ||\n      direction === OdoPointer.Direction.DOWN);\n  }\n\n  _shouldGoToNext(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isLastSlide()) && (\n      direction === OdoPointer.Direction.LEFT ||\n      direction === OdoPointer.Direction.UP);\n  }\n\n  navigateAfterDrag(velocity, direction, didMoveOnAxis) {\n    const hasVelocity = this.hasDragged && this.draggable.pointer.hasVelocity(velocity);\n\n    // If dragging has not occurred, the user simply clicked on the carousel.\n    // If the user is quickly navigating through the carousel, then clicks on\n    // it, the movement will be canceled, but it wouldn't go anywhere because it\n    // appears to be going to the same slide. Determine if the carousel is still\n    // between slides (offset). If it is, it needs to go to the nearest slide.\n    if (!this.hasDragged) {\n      this._isOffset =\n        Math.abs(Math.round(this._getCarouselOffset())) > Math.round(this._startEdge);\n    }\n\n    // Previous.\n    if (this._shouldGoToPrevious(hasVelocity, direction)) {\n      this.goToNearestSlide(false);\n\n    // Next.\n    } else if (this._shouldGoToNext(hasVelocity, direction)) {\n      this.goToNearestSlide(true);\n\n    // Not enough velocity, go to the nearest slide.\n    // The distance must at least be 1, otherwise gotoSlide creates an event\n    // listener for moving the element by zero pixels and the transition end\n    // event doesn't fire.\n    } else if (didMoveOnAxis || this._isOffset) {\n      this.goToNearestSlide();\n    }\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {CarouselEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Whether the carousel is being dragged towards an edge.\n   * @param {number} deltaX Change in x during drag.\n   * @param {number} deltaY Change in y during drag.\n   * @return {boolean}\n   * @private\n   */\n  _isMovingTowardsEdge(deltaX, deltaY) {\n    const toStartEdge = this.isVertical ?\n      deltaY > 0 :\n      deltaX > 0;\n    const toEndEdge = this.isVertical ?\n      deltaY < 0 :\n      deltaX < 0;\n\n    return (this.isFirstSlide() && toStartEdge) || (this.isLastSlide() && toEndEdge);\n  }\n\n  /**\n   * Remove event listeners, DOM references, inline styles, class names, paddles,\n   * and pagination added by Carousel.\n   */\n  dispose() {\n    if (this._timer) {\n      this._timer.dispose();\n    }\n\n    this._removeA11yAttributes();\n    this._removePaddles();\n    this._removePagination();\n\n    // Reset container styles.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = '';\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION] = '';\n\n    if (this.options.isFade) {\n      this.pointer.off(OdoPointer.EventType.END, this._onPointerEnd);\n      this.pointer.dispose();\n\n      this.getSlides().forEach((slide) => {\n        slide.style[OdoDevice.Dom.TRANSITION] = '';\n      });\n    } else {\n      this.draggable.off(OdoDraggable.EventType.START, this._onDragStart);\n      this.draggable.off(OdoDraggable.EventType.MOVE, this._onDragMove);\n      this.draggable.off(OdoDraggable.EventType.END, this._onDragEnd);\n\n      this.draggable.dispose();\n    }\n\n    this.element.removeEventListener('click', this._onClick);\n\n    this._slides.forEach((slide) => {\n      slide.classList.remove(\n        Carousel.Classes.PAST_SLIDE,\n        Carousel.Classes.PREVIOUS_SLIDE,\n        Carousel.Classes.ACTIVE_SLIDE,\n        Carousel.Classes.NEXT_SLIDE,\n        Carousel.Classes.FUTURE_SLIDE,\n        Carousel.Classes.VISIBLE,\n        Carousel.Classes.BEHIND,\n      );\n    });\n\n    // When the carousel is bidirectional, it has cloned the first two slides\n    // and added them to the carousel element. Remove the clones.\n    if (this._isBidirectional) {\n      this._carouselEl.removeChild(this._slides[2]);\n      this._carouselEl.removeChild(this._slides[3]);\n    }\n\n    // Null out DOM refs.\n    this.element = null;\n    this._slideContainerParentEl = null;\n    this._carouselEl = null;\n    this._paddlePrevious = null;\n    this._paddleNext = null;\n    this._paginationDots = null;\n    this.draggable = null;\n    this.pointer = null;\n    this._slides.length = 0;\n  }\n\n  /**\n   * Because Object.assign only does a shallow merge, merge the template option\n   * first and then overwrite the main Object.assign result.\n   * @param {Object} options Options object.\n   * @return {Object} Merged options object with defaults.\n   */\n  static getOptions(options) {\n    const templates = Object.assign({}, Carousel.Defaults.template, options.template);\n    const opts = Object.assign({}, Carousel.Defaults, options);\n    opts.template = templates;\n    return opts;\n  }\n}\n\nObject.assign(Carousel, settings);\n\nCarousel.template = templateEngine;\n\n// Export for testing.\nCarousel._getTranslate = getTranslate;\n\nexport default Carousel;\n","export default {\n\n  /**\n   * Event types emitted by the carousel.\n   * @enum {string}\n   */\n  EventType: {\n    WILL_NAVIGATE: 'odocarousel:willnavigate',\n    SLIDE_START: 'odocarousel:slidestart',\n    SLIDE_END: 'odocarousel:slideend',\n  },\n\n  /** @enum {string} */\n  Classes: {\n    BASE: 'odo-carousel',\n    FADE: 'odo-carousel--fade',\n    VERTICAL: 'odo-carousel--vertical',\n    WRAPPER: 'odo-carousel__wrapper',\n    CAROUSEL_ELEMENT: 'odo-carousel__element',\n\n    SLIDE: 'odo-carousel__slide',\n    ACTIVE_SLIDE: 'odo-carousel__slide--active',\n    PREVIOUS_SLIDE: 'odo-carousel__slide--previous',\n    PAST_SLIDE: 'odo-carousel__slide--past',\n    NEXT_SLIDE: 'odo-carousel__slide--next',\n    FUTURE_SLIDE: 'odo-carousel__slide--future',\n\n    VISIBLE: 'odo-carousel__slide--visible',\n    BEHIND: 'odo-carousel__slide--behind',\n\n    PAGINATION: 'odo-carousel__pagination',\n    PAGINATION_DOT: 'odo-carousel__pagination-dot',\n    PAGINATION_DOT_SELECTED: 'is-selected',\n\n    PADDLES: 'odo-carousel__nav-paddles',\n    PADDLE: 'odo-carousel__nav-paddle',\n    PADDLE_NEXT: 'odo-carousel__nav-next',\n    PADDLE_PREV: 'odo-carousel__nav-prev',\n    PADDLE_DISABLED: 'is-disabled',\n\n    SLIDE_CHILD: 'odo-carousel__slide-child',\n  },\n\n  Defaults: {\n    startIndex: 0,\n    isVertical: false,\n    isLooped: false,\n    isJumped: false,\n    isFade: false,\n    isCentered: false,\n    neighborCount: 1,\n    slideshowSpeed: 1000,\n    animationSpeed: 400,\n    crossfadeAmount: 0.875,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    pagination: false,\n    getNavPaddleHtml: null,\n    getPaginationHtml: null,\n    template: {\n      paddles: '<nav class=\"odo-carousel__nav-paddles\">{{ prev }}{{ next }}</nav>',\n      paddleNext: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"next slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-next\">{{ paddleInner }}</a>',\n      paddlePrev: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"previous slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-prev\">{{ paddleInner }}</a>',\n      paddleNextInner: '<svg viewBox=\"75.4 27 461.2 738\"><path d=\"M167.7 27l368.9 369-368.9 369-92.3-92.3 276.7-276.7-276.7-276.7z\"/></svg>',\n      paddlePrevInner: '<svg viewBox=\"75.396 26.994 461.208 738.012\"><path d=\"M444.336 765.006l-368.94-369.006 368.94-369.006 92.268 92.268-276.738 276.738 276.738 276.738z\"/></svg>',\n      pagination: '<nav class=\"odo-carousel__pagination\" role=\"tablist\">{{ dots }}</nav>',\n      paginationDot: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\"></a>',\n      paginationDotSecondary: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\" data-secondary-index=\"{{ secondaryIndex }}\" aria-hidden=\"{{ hidden }}\"></a>',\n    },\n  },\n\n  TRANSITION_END_WAIT: 32,\n};\n","/**\n * A simple string replacement template with double curly braces. You can use\n * nested objects and functions too.\n *\n * Usage:\n *     template(\"Today is {{ day }}\", {\n *       day: 'Friday'\n *     }); // \"Today is Friday\"\n *\n *     template(\"Today is {{ month.day }}\", {\n *       month: {\n *         day: \"Friday\"\n *       }\n *     }); // \"Today is Friday\n *\n *     template(\"Today is {{ day }}\", {\n *       dayOfTheWeek: 'Friday',\n *       day: function() {\n *         return this.dayOfTheWeek;\n *       }\n *     }); // \"Today is Friday\"\n *\n *\n * @param {string} str Template.\n * @param {Object} data Data object with keys which match your template.\n * @return {string}\n */\nexport default function template(str, data) {\n  // A modified version of Malsup's template method for Cycle.\n  // https://github.com/malsup/cycle2/blob/master/src/jquery.cycle2.tmpl.js\n\n  // Regex which matches {{cool}} or {{ cool }} where `cool` is what should\n  // be replaced.\n  return str.replace(/{{\\s?((.)?.*?)\\s?}}/g, (match, str) => {\n    const names = str.split('.');\n    let obj = data;\n    let property;\n\n    // If the name has dots in it, \"person.name\", loop through each one.\n    if (names.length > 1) {\n      property = obj;\n      for (let i = 0; i < names.length; i++) {\n        obj = property;\n        property = property[names[i]] || str;\n      }\n\n    // Otherwise, it's a simple assignment from the data object.\n    } else {\n      property = obj[str];\n    }\n\n    // If they passed a function, use that.\n    if (typeof property === 'function') {\n      return property.call(obj);\n    }\n\n    // Return the string if it exists.\n    if (property !== undefined && property !== null && property !== str) {\n      return property;\n    }\n\n    // Otherwise, return the original string.\n    return str;\n  });\n}\n"],"names":["CarouselEvent","type","carousel","optFrom","optTo","target","element","from","to","hasSlideChanged","defaultPrevented","preventDefault","getTranslate","str","array","match","parseFloat","count","uniqueId","Carousel","options","_TinyEmitter","Element","TypeError","getOptions","isVertical","_this","_isSlidingLooped","isLooped","isFade","domIndex","lastDomIndex","_selectedIndex","_slideContainerParentEl","_carouselEl","_slides","_isJumped","_isEnabled","_posAttr","_offsetPosition","capitalize","_dimensionAttr","_translateAxis","isTransitioning","_transitionId","_hasSlideChildren","_isDraggable","hasDragged","_isOffset","_timer","_crossfadeTimeout","animationSpeed","crossfadeAmount","_startEdge","draggable","pointer","_isBidirectional","resetSync","reset","decorate","getElementsByClass","className","context","this","Array","getElementsByClassName","getElementByClass","_saveDomElements","length","_decorateBidirectionalCarousel","_setA11yAttributes","_renderPaddles","pagination","_renderPagination","_saveRenderedElements","_setSlideIndices","_decorateFadeCarousel","_decorateRegularCarousel","_onClick","_handleClick","bind","addEventListener","setSelectedIndex","_getSafeIndex","startIndex","_setNeighborSlides","_snapToCurrentSlide","style","OdoDevice","Dom","TRANSITION_PROPERTY","Css","TRANSFORM","TRANSITION_TIMING_FUNCTION","easing","_getSlideChildren","bindDragEvents","getSlides","forEach","slide","i","TRANSITION","_this2","classList","add","Classes","VISIBLE","bindSwipeEvents","getCarouselElement","appendChild","cloneNode","SLIDE","getWrapper","setAttribute","_removeA11yAttributes","removeAttribute","WRAPPER","CAROUSEL_ELEMENT","_paddlePrevious","PADDLE_PREV","_paddleNext","PADDLE_NEXT","_paginationDots","PAGINATION_DOT","map","parseInt","dot","getAttribute","insertAdjacentHTML","_getNavPaddleHtml","_removePaddles","_removeByClass","PADDLES","parentNode","removeChild","getNavPaddleHtml","call","template","paddles","paddlePrev","paddlePrevInner","paddleNext","paddleNextInner","_getPaginationHtml","_removePagination","PAGINATION","getPaginationHtml","dots","_buildPaginationHtml","paginationDotSecondary","paginationDot","reduce","dotsHtml","arr","data","id","_this4","secondaryIndex","hidden","OdoDraggable","OdoPointer","Axis","Y","X","_onDragStart","_handleDragStart","_onDragMove","_handleDragMove","_onDragEnd","_handleDragEnd","on","EventType","START","MOVE","END","_onPointerEnd","_handlePointerEnd","addSlide","slideHtml","_setSlidesToLogicalOrder","selected","getSelectedIndex","getSlide","index","_getDomIndex","logicalIndex","getSlideIndices","indexOf","_getLogicalIndex","isIndexOutOfRange","_getRelativeIndex","clampIndexToSlides","displacment","wrapAroundList","clamp","isFirstSlide","isLastSlide","_slideIndices","len","optSlide","SLIDE_CHILD","_moveIndex","currentValue","toIndex","clampedIndex","fromIndex","splice","_swapIndexes","logIndex1","logIndex2","domIndexOfLogicalIndex1","_getPositions","slideSet","bounds","getBoundingClientRect","el","_this5","_setDraggableEnabled","enabled","isEnabled","setDraggable","isDraggable","_getNewPosition","destinationSlide","destinationPosition","carouselSize","getSize","isCentered","destinationSize","wrapperSize","position","_getPositionForSlideChildren","childrenSum","getElementsSize","_getCssPosition","pos","frag","document","createDocumentFragment","_setNeighborSlidesForJump","toDomIndex","toLogicalIndex","currentLogicalIndex","destinationDomIndex","_swapSlides","index1","index2","startSlideshow","Timer","_slideshowTimerExpired","slideshowSpeed","start","pauseSlideshow","_isSlideshowPlaying","stop","isTicking","getInnocentNeighbor","iterator","isNext","currentSlideEl","getNthSibling","firstElementChild","getNeighborInsertionIndex","currentDomIndex","_setNeighborSlide","relativePos","indices","logicalNeighborIndex","innocentNeighbor","insertionIndex","neighborEl","insertBefore","neighborCount","goToSlide","_maybeSetJumpedSlides","noAnimation","isJumped","Math","abs","_canNavigate","isSameSlideWithAnimation","isOffset","_toNewSlide","_emitEvent","SLIDE_START","_moveToPosition","TRANSITION_DURATION","onTransitionEnd","_transitionDone","TRANSITION_END_WAIT","_getCarouselOffset","matrix","getComputedStyle","translate","round","toLowerCase","_cancelMovement","offset","update","fadeToSlide","optNoAnimation","nextSlide","previousSlide","BEHIND","remove","updatedDomIndex","adjustedPosition","canNavigate","WILL_NAVIGATE","_setSlidesState","_setPaddleState","_setPaginationState","goToNearestSlide","positions","closest","goToNextSlide","goToPreviousSlide","selectedIndex","past","previous","next","future","isActive","parent","canFocus","focusableElements","elements","querySelectorAll","matches","push","tabIndex","toggle","ACTIVE_SLIDE","PAST_SLIDE","PREVIOUS_SLIDE","NEXT_SLIDE","FUTURE_SLIDE","i2","PAGINATION_DOT_SELECTED","notLooped","first","PADDLE_DISABLED","last","SLIDE_END","pointerEvent","hasVelocity","velocity","direction","Direction","RIGHT","LEFT","evt","willNavigate","prev","delta","y","x","friction","_isMovingTowardsEdge","navigateAfterDrag","axisDirection","didMoveOnAxis","_shouldGoToPrevious","DOWN","_shouldGoToNext","UP","event","emit","deltaX","deltaY","toStartEdge","toEndEdge","dispose","off","removeEventListener","templates","Object","assign","Defaults","opts","TinyEmitter","replace","names","split","obj","property","undefined","_getTranslate"],"mappings":"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"}