{"version":3,"file":"odo-carousel.min.js","sources":["../src/utils.js","../src/carousel-event.js","../src/settings.js","../src/carousel.js","../src/template-engine.js"],"sourcesContent":["\nexport function getTranslate(str) {\n  const array = str.match(/(-?[\\d.]+)/g);\n  return {\n    x: parseFloat(array[4]),\n    y: parseFloat(array[5]),\n  };\n}\n\nlet count = 0;\nexport function uniqueId() {\n  count += 1;\n  return `odo-carousel${count}`;\n}\n\n/**\n * Find every element within the parent which is focusable via tabbing and\n * enable/disable it. Ideally, some property could be set on the parent\n * element itself to prevent tabbing into it. visibility:hidden accomplishes\n * this, but there can be slides in view which are not the current slide.\n * @param {Element} parent Ancestor element to disable tabbing into.\n * @param {boolean} canFocus Whether to enable or disable focusability.\n */\nexport function toggleFocusability(parent, canFocus) {\n  const focusableElements = 'a[href],button,details,iframe,input,textarea,select,*[tabindex]';\n  const elements = Array.from(parent.querySelectorAll(focusableElements));\n\n  // Test the parent element itself. Odo Helpers polyfills `matches`.\n  if (parent.matches(focusableElements)) {\n    elements.push(parent);\n  }\n\n  for (let i = elements.length - 1; i >= 0; i--) {\n    if (canFocus) {\n      // Prefer resetting the tabIndex property by using removeAttribute to lets\n      // the browser decide if it should go back to 0 (like if it was a button)\n      // or to -1 if it wasn't originally focusable.\n      elements[i].removeAttribute('tabindex');\n    } else {\n      elements[i].tabIndex = -1;\n    }\n  }\n}\n","\nclass CarouselEvent {\n  /**\n   * Object representing a carousel event.\n   * @param {string} type Event type.\n   * @param {Carousel} carousel The carousel instance.\n   * @param {number=} optFrom The logical index the carousel is coming from.\n   * @param {number=} optTo The logical index the carouesl is going to.\n   * @constructor\n   */\n  constructor(type, carousel, optFrom, optTo) {\n    this.type = type;\n\n    /** @type {Element} */\n    this.target = carousel.element;\n\n    /** @type {number} carousel slid from this index. */\n    this.from = optFrom;\n\n    /** @type {number} carousel slid to this index. */\n    this.to = optTo;\n\n    /** @type {boolean} Whether the carousel actually changed slides. */\n    this.hasSlideChanged = optFrom !== optTo;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default CarouselEvent;\n","export default {\n\n  /**\n   * Event types emitted by the carousel.\n   * @enum {string}\n   */\n  EventType: {\n    WILL_NAVIGATE: 'odocarousel:willnavigate',\n    SLIDE_START: 'odocarousel:slidestart',\n    SLIDE_END: 'odocarousel:slideend',\n  },\n\n  /** @enum {string} */\n  Classes: {\n    BASE: 'odo-carousel',\n    FADE: 'odo-carousel--fade',\n    VERTICAL: 'odo-carousel--vertical',\n    WRAPPER: 'odo-carousel__wrapper',\n    CAROUSEL_ELEMENT: 'odo-carousel__element',\n\n    SLIDE: 'odo-carousel__slide',\n    ACTIVE_SLIDE: 'odo-carousel__slide--active',\n    PREVIOUS_SLIDE: 'odo-carousel__slide--previous',\n    PAST_SLIDE: 'odo-carousel__slide--past',\n    NEXT_SLIDE: 'odo-carousel__slide--next',\n    FUTURE_SLIDE: 'odo-carousel__slide--future',\n\n    VISIBLE: 'odo-carousel__slide--visible',\n    BEHIND: 'odo-carousel__slide--behind',\n\n    PAGINATION: 'odo-carousel__pagination',\n    PAGINATION_DOT: 'odo-carousel__pagination-dot',\n    PAGINATION_DOT_SELECTED: 'is-selected',\n\n    PADDLES: 'odo-carousel__nav-paddles',\n    PADDLE: 'odo-carousel__nav-paddle',\n    PADDLE_NEXT: 'odo-carousel__nav-next',\n    PADDLE_PREV: 'odo-carousel__nav-prev',\n    PADDLE_DISABLED: 'is-disabled',\n\n    SLIDE_CHILD: 'odo-carousel__slide-child',\n  },\n\n  Defaults: {\n    startIndex: 0,\n    isVertical: false,\n    isLooped: false,\n    isJumped: false,\n    isFade: false,\n    isCentered: false,\n    neighborCount: 1,\n    slideshowSpeed: 1000,\n    animationSpeed: 400,\n    crossfadeAmount: 0.875,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    pagination: false,\n    getNavPaddleHtml: null,\n    getPaginationHtml: null,\n    template: {\n      paddles: '<nav class=\"odo-carousel__nav-paddles\">{{ prev }}{{ next }}</nav>',\n      paddleNext: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"next slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-next\">{{ paddleInner }}</a>',\n      paddlePrev: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"previous slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-prev\">{{ paddleInner }}</a>',\n      paddleNextInner: '<svg viewBox=\"75.4 27 461.2 738\"><path d=\"M167.7 27l368.9 369-368.9 369-92.3-92.3 276.7-276.7-276.7-276.7z\"/></svg>',\n      paddlePrevInner: '<svg viewBox=\"75.396 26.994 461.208 738.012\"><path d=\"M444.336 765.006l-368.94-369.006 368.94-369.006 92.268 92.268-276.738 276.738 276.738 276.738z\"/></svg>',\n      pagination: '<nav class=\"odo-carousel__pagination\" role=\"tablist\">{{ dots }}</nav>',\n      paginationDot: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\"></a>',\n      paginationDotSecondary: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\" data-secondary-index=\"{{ secondaryIndex }}\" aria-hidden=\"{{ hidden }}\"></a>',\n    },\n  },\n\n  TRANSITION_END_WAIT: 32,\n};\n","/**\n * @fileoverview A UI Component for creating versatile carousels. They are\n * peformant, draggable, and can ininitely loop.\n *\n * @author glen@odopod.com (Glen Cheney)\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport OdoPointer from '@odopod/odo-pointer';\nimport OdoDraggable from '@odopod/odo-draggable';\nimport {\n  animation,\n  array,\n  dom,\n  math,\n  string,\n  style,\n  Timer,\n} from '@odopod/odo-helpers';\n\nimport CarouselEvent from './carousel-event';\nimport settings from './settings';\nimport templateEngine from './template-engine';\nimport { getTranslate, toggleFocusability, uniqueId } from './utils';\n\nclass Carousel extends TinyEmitter {\n  /**\n   * @param {Element} element The outermost carousel element.\n   * @param {Object} [options] An options object.\n   * @constructor\n   * @throws {TypeError} if element isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!(element instanceof Element)) {\n      throw new TypeError(`OdoCarousel requires an element. Got: \"${element}\"`);\n    }\n\n    this.element = element;\n\n    /**\n     * Deep copy from the defaults and override defaults with options passed in.\n     * @public\n     */\n    this.options = Carousel.getOptions(options);\n\n    /**\n     * Whether the carousel is vertical or horizontal.\n     * @type {boolean}\n     * @protected\n     */\n    this.isVertical = this.options.isVertical;\n\n    /**\n     * Whether this is a looped carousel which is not a fading carousel.\n     * @type {boolean}\n     */\n    this._isSlidingLooped = this.options.isLooped && !this.options.isFade;\n\n    /**\n     * The DOM index of the current slide element within the slides' parent.\n     * @type {number}\n     * @protected\n     */\n    this.domIndex = 0;\n\n    /**\n     * The previous domIndex value.\n     * @type {number}\n     * @protected\n     */\n    this.lastDomIndex = 0;\n\n    /**\n     * Current logical index.\n     * @type {number}\n     */\n    this._selectedIndex = 0;\n\n    /**\n     * The slide container's parent.\n     * @type {Element}\n     * @private\n     */\n    this._slideContainerParentEl = null;\n\n    /**\n     * The container for the slides and the element which is moved around with\n     * transforms or absolute positioning.\n     * @type {Element}\n     * @private\n     */\n    this._carouselEl = null;\n\n    /**\n     * An array of slides (elements) in the carousel.\n     * @type {Array.<!Element>}\n     * @private\n     */\n    this._slides = [];\n\n    /**\n     * Whether the carousel is currently skipping slides. For example, going from\n     * slide 1 to 3, a jumping carousel repositions the slides so that 3 is next\n     * to 1 and only has to animate one slide length to get to it. This flag\n     * indicates a slide has been repositioned.\n     * @type {boolean}\n     * @private\n     */\n    this._isJumped = false;\n\n    /**\n     * Whether the carousel is able to be used. This can be changed with the\n     * `setEnabled` method.\n     * @type {boolean}\n     * @private\n     */\n    this._isEnabled = true;\n\n    /**\n     * Top or left.\n     * @type {string}\n     * @private\n     */\n    this._posAttr = this.isVertical ? 'top' : 'left';\n\n    /**\n     * offsetTop or offsetLeft.\n     * @type {string}\n     * @private\n     */\n    this._offsetPosition = 'offset' + string.capitalize(this._posAttr);\n\n    /**\n     * Height or width.\n     * @type {string}\n     * @private\n     */\n    this._dimensionAttr = this.isVertical ? 'height' : 'width';\n\n    /**\n     * Value used in `translate{X|Y}()`.\n     * @type {string}\n     */\n    this._translateAxis = this.isVertical ? 'Y' : 'X';\n\n    /**\n     * A flag indicating that the carousel is animating. It also will have\n     * a transition end event lister bound to it if the browser can\n     * transition transforms.\n     * @type {boolean}\n     * @protected\n     */\n    this.isTransitioning = false;\n\n    /**\n     * The id returned from animation.onTransitionEnd which is used to cancel\n     * the transitionend listener.\n     * @type {string}\n     */\n    this._transitionId = null;\n\n    /**\n     * If a selector is specified, gotoSlide will look for this on the last\n     * slide and not reveal unneccesary whitespace to the right of the last\n     * matched element.\n     * @type {boolean}\n     * @private\n     */\n    this._hasSlideChildren = false;\n\n    /**\n     * Default to true for being able to drag the carousel between slides.\n     * @type {boolean}\n     * @private\n     */\n    this._isDraggable = true;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the carousel is at a resting position or between slides.\n     * @type {boolean}\n     */\n    this._isOffset = false;\n\n    /**\n     * A Timer used to make the carousel an autoplaying slideshow.\n     * @type {Timer}\n     * @private\n     */\n    this._timer = null;\n\n    /**\n     * Time, in milliseconds, to wait before adding zero opacity to the slide,\n     * which triggers the css transition. timeout = speed - (speed * %).\n     * @type {number}\n     * @private\n     */\n    this._crossfadeTimeout = this.options.animationSpeed -\n        (this.options.animationSpeed * this.options.crossfadeAmount);\n\n    /**\n     * When carousel slides are centered, they won't be aligned with the starting\n     * edge of the carousel wrapper. The starting edge (relative zero) is used\n     * to determine which slide is closest to the current position.\n     * @type {number}\n     */\n    this._startEdge = 0;\n\n    /**\n     * Draggable attached to the carousel element. Used for non-fade carousels.\n     * @type {OdoDraggable}\n     */\n    this.draggable = null;\n\n    /**\n     * Pointer attached to the main element. Used for fading carousels.\n     * @type {OdoDraggable}\n     */\n    this.pointer = null;\n\n    /**\n     * Carousels containing only two slides with looping functionality are special\n     * cases. Slides need to be duplicated and pagination needs to be rendered\n     * differently. This is because in order for the user to navigate in either\n     * direction from the active slide, the second slide would need to be present in\n     * both the 'previous' and 'next' positions. 'Bidirectional' will refer to\n     * carousels with content that unnaturally exists for the sake of navigational\n     * purposes.\n     * @type {boolean}\n     */\n    this._isBidirectional = false;\n\n    // Deprecated method.\n    this.resetSync = this.reset;\n\n    // Go.\n    this.decorate();\n  }\n\n  /**\n   * Finds an element within this class' main element based on a class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optionally provide the context (scope)\n   *     for the query. Default is the main element of the class.\n   * @return {Array.<Element>} An array which may or may not contain the element\n   *     which was searched for.\n   */\n  getElementsByClass(className, context = this.element) {\n    return Array.from(context.getElementsByClassName(className));\n  }\n\n  /**\n   * Retrieve an element by its class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optinal scope for search.\n   * @return {?Element} The element or null if it isn't found.\n   */\n  getElementByClass(className, context) {\n    return this.getElementsByClass(className, context)[0] || null;\n  }\n\n  /**\n   * Modify the DOM to be a carousel.\n   */\n  decorate() {\n    this._saveDomElements();\n\n    // After we determine the number of slides, we have enough information to decide if\n    // this carousel will be a special bidirectional one.\n    if (this.options.isLooped && this._slides.length === 2) {\n      this._decorateBidirectionalCarousel();\n    }\n\n    this._setA11yAttributes();\n    this._renderPaddles();\n\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    this._setSlideIndices();\n\n    if (this.options.isFade) {\n      this._decorateFadeCarousel();\n    } else {\n      this._decorateRegularCarousel();\n    }\n\n    this._onClick = this._handleClick.bind(this);\n    this.element.addEventListener('click', this._onClick);\n\n    // Set the selected index without animation.\n    this.setSelectedIndex(this._getSafeIndex(this.options.startIndex), true);\n\n    // Changes viewport, so it needs to come after the goto zero.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateRegularCarousel() {\n    // Add easing to container\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_PROPERTY] = OdoDevice.Css.TRANSFORM;\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_TIMING_FUNCTION] = this.options.easing;\n\n    this._hasSlideChildren = this._getSlideChildren().length > 0;\n\n    this.bindDragEvents();\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateFadeCarousel() {\n    this._isDraggable = false;\n\n    // Add transitions to each slide.\n    this.getSlides().forEach((slide, i) => {\n      slide.style[OdoDevice.Dom.TRANSITION] = 'opacity ' +\n        this.options.animationSpeed + 'ms linear';\n\n      // The first slide needs to have the visible class.\n      if (i === 0) {\n        slide.classList.add(Carousel.Classes.VISIBLE);\n      }\n    });\n\n    this.bindSwipeEvents();\n  }\n\n  /**\n   * Sets up the additional DOM modifications that will be needed for bidirectional\n   * carousels. We will essentially be duplicating both carousel slides so that no\n   * matter the current index, the active slide will alway have neighbors on either side.\n   * Then later on, we hide the additional pagination.\n   * @private\n   */\n  _decorateBidirectionalCarousel() {\n    // Bidirectional carousels automatically will need to become a jumped carousels,\n    // since we will be adding artificial slides that ruin natural navigation.\n    this._isBidirectional = true;\n    this._isJumped = true;\n\n    // Turn 2 slides into 4.\n    this._slides.forEach((slide) => {\n      this.getCarouselElement().appendChild(slide.cloneNode(true));\n    });\n\n    // Update the global slides variable to include the new elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Set static accessibility attributes.\n   */\n  _setA11yAttributes() {\n    this.getWrapper().setAttribute('aria-live', 'polite');\n    this.getCarouselElement().setAttribute('role', 'list');\n    this.getSlides().forEach((slide) => {\n      dom.giveId(slide, uniqueId);\n      slide.setAttribute('role', 'listitem');\n    });\n  }\n\n  /**\n   * Remove static accessibility attributes.\n   */\n  _removeA11yAttributes() {\n    this.getWrapper().removeAttribute('aria-live');\n    this.getCarouselElement().removeAttribute('role');\n    this.getSlides().forEach((slide) => {\n      slide.removeAttribute('role');\n    });\n  }\n\n  /**\n   * Store references to commonly used DOM elements.\n   * @private\n   */\n  _saveDomElements() {\n    // Element which wraps the element which contains all the slides.\n    this._slideContainerParentEl = this.getElementByClass(Carousel.Classes.WRAPPER);\n\n    // Element which contains all the slides.\n    this._carouselEl = this.getElementByClass(Carousel.Classes.CAROUSEL_ELEMENT);\n\n    // Because carousels can have carousels inside them, finding elements by\n    // class retrieves too many elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Store references to generated elements. The pagination dots cannot be save in\n   * `_saveDomElements` because the number of slides is not yet known.\n   * @private\n   */\n  _saveRenderedElements() {\n    this._paddlePrevious = this.getElementByClass(Carousel.Classes.PADDLE_PREV);\n    this._paddleNext = this.getElementByClass(Carousel.Classes.PADDLE_NEXT);\n    this._paginationDots = this.getElementsByClass(Carousel.Classes.PAGINATION_DOT)\n      .map(dot => ({\n        dot,\n        i: parseInt(dot.getAttribute('data-index'), 10),\n        i2: parseInt(dot.getAttribute('data-secondary-index'), 10),\n      }));\n  }\n\n  /**\n   * Add navigation paddles (previous and next buttons) to the carousel.\n   * @private\n   */\n  _renderPaddles() {\n    this.element.insertAdjacentHTML('beforeend', this._getNavPaddleHtml());\n  }\n\n  /**\n   * Remove navigation paddles from the carousel (if they exist).\n   * @private\n   */\n  _removePaddles() {\n    this._removeByClass(Carousel.Classes.PADDLES);\n  }\n\n  /**\n   * Remove a child element by class, if it exists.\n   * @param {string} className Class name of the element to find and remove.\n   */\n  _removeByClass(className) {\n    const element = this.getElementByClass(className);\n    if (element) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  /**\n   * Retrieves the html string for the nav paddles from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getNavPaddleHtml() {\n    if (typeof this.options.getNavPaddleHtml === 'function') {\n      return this.options.getNavPaddleHtml.call(this, this);\n    }\n\n    return Carousel.template(this.options.template.paddles, {\n      prev: Carousel.template(this.options.template.paddlePrev, {\n        paddleInner: this.options.template.paddlePrevInner,\n      }),\n      next: Carousel.template(this.options.template.paddleNext, {\n        paddleInner: this.options.template.paddleNextInner,\n      }),\n    });\n  }\n\n  /**\n   * Add pagination (the dots) to the carousel.\n   * @private\n   */\n  _renderPagination() {\n    this.element.insertAdjacentHTML('beforeend', this._getPaginationHtml());\n  }\n\n  /**\n   * Remove pagination from the carousel (if they exist).\n   * @private\n   */\n  _removePagination() {\n    this._removeByClass(Carousel.Classes.PAGINATION);\n  }\n\n  /**\n   * Retrieves the html string for the pagination from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getPaginationHtml() {\n    if (typeof this.options.getPaginationHtml === 'function') {\n      return this.options.getPaginationHtml.call(this, this);\n    }\n\n    const dots = this._buildPaginationHtml();\n\n    return Carousel.template(this.options.template.pagination, {\n      dots,\n    });\n  }\n\n  /**\n   * Builds and returns the HTML string of the pagination dots.\n   * Bidirectional carousels utilize a separate template that includes\n   * secondary indices.\n   * @return {string}\n   * @private\n   */\n  _buildPaginationHtml() {\n    const template = this._isBidirectional ?\n      this.options.template.paginationDotSecondary :\n      this.options.template.paginationDot;\n\n    return this.getSlides().reduce((dotsHtml, slide, i, arr) => {\n      const data = {\n        index: i,\n        index1: i + 1,\n        slideId: slide.id,\n      };\n\n      if (this._isBidirectional) {\n        // If you are rendering pagination for a bidirectional carousel, you will need\n        // secondary indices computed. This returns the secondary index based on the primary.\n        // i.e. For 4 slides, 1 returns 3, 2 returns 4 and the inverse.\n        data.secondaryIndex = i > 1 ? i % 2 : i + 2;\n        data.hidden = i >= arr.length / 2;\n      }\n\n      return dotsHtml + Carousel.template(template, data);\n    }, '');\n  }\n\n  /**\n   * Listen for dragging events.\n   * @protected\n   */\n  bindDragEvents() {\n    this.draggable = new OdoDraggable(this._carouselEl, {\n      axis: this.isVertical ? OdoPointer.Axis.Y : OdoPointer.Axis.X,\n    });\n\n    this._onDragStart = this._handleDragStart.bind(this);\n    this._onDragMove = this._handleDragMove.bind(this);\n    this._onDragEnd = this._handleDragEnd.bind(this);\n\n    this.draggable.on(OdoDraggable.EventType.START, this._onDragStart);\n    this.draggable.on(OdoDraggable.EventType.MOVE, this._onDragMove);\n    this.draggable.on(OdoDraggable.EventType.END, this._onDragEnd);\n  }\n\n  /**\n   * Listen for the pointer to come up from the screen, then execute a callback.\n   * @protected\n   */\n  bindSwipeEvents() {\n    this.pointer = new OdoPointer(this._carouselEl, {\n      axis: OdoPointer.Axis.X,\n      preventEventDefault: true,\n    });\n\n    this._onPointerEnd = this._handlePointerEnd.bind(this);\n    this.pointer.on(OdoPointer.EventType.END, this._onPointerEnd);\n  }\n\n  /**\n   * Add a slide to the end of the carousel.\n   * @param {string} slideHtml Html string for the slide.\n   */\n  addSlide(slideHtml) {\n    // Make sure looped carousels are in the right order without any neighbors.\n    this._setSlidesToLogicalOrder();\n\n    // Insert new slide at the end.\n    this._carouselEl.insertAdjacentHTML('beforeend', slideHtml);\n\n    this.reset();\n  }\n\n  /**\n   * Synchronously reset the slides. Use this when you're sure the elements\n   * within the carousel are done changing.\n   */\n  reset() {\n    // Update the slides.\n    this._saveDomElements();\n\n    // Remove old paddles + pagination.\n    this._removePaddles();\n    this._removePagination();\n\n    this._setA11yAttributes();\n\n    // Re-render paddles and pagination.\n    this._renderPaddles();\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    // Update slide indices now that there's a new slide.\n    this._setSlideIndices();\n\n    // Go to the slide it was at before.\n    const selected = this.getSelectedIndex();\n    this.setSelectedIndex(0, true);\n\n    // Try going back to the previous one.\n    this.setSelectedIndex(selected, true);\n\n    // Set neighbors slides for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Retreives the cached carousel wrapper element.\n   * @return {Element}\n   */\n  getWrapper() {\n    return this._slideContainerParentEl;\n  }\n\n  /**\n   * Retreives the cached carousel element.\n   * @return {Element}\n   */\n  getCarouselElement() {\n    return this._carouselEl;\n  }\n\n  /**\n   * Returns the array of slides in the carousel.\n   * @return {!Array.<!Element>} The slides array.\n   */\n  getSlides() {\n    return this._slides;\n  }\n\n  /**\n   * Get the slide element at the given index.\n   * @param {number} index The logical index of the slide you want.\n   * @return {Element} The slide element.\n   */\n  getSlide(index) {\n    return this.getSlides()[index];\n  }\n\n  /**\n   * Get the index of the currently active slide.\n   * @return {number} Index of the current slide.\n   */\n  getSelectedIndex() {\n    return this._selectedIndex;\n  }\n\n  /**\n   * Translates the original index to the current DOM index.\n   * @param {number} logicalIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getDomIndex(logicalIndex) {\n    return this.getSlideIndices().indexOf(logicalIndex);\n  }\n\n  /**\n   * Translates the DOM index to the original logical index.\n   * @param {number} domIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getLogicalIndex(domIndex) {\n    return this.getSlideIndices()[domIndex];\n  }\n\n  /**\n   * Takes a logical index which could potentially be out of range and returns\n   * the logical index within range.\n   * @param {number} logicalIndex Logical index to make safe.\n   * @return {number} Safe logical index.\n   * @private\n   */\n  _getSafeIndex(logicalIndex) {\n    if (this.isIndexOutOfRange(logicalIndex)) {\n      if (this.options.isLooped) {\n        return this._getRelativeIndex(logicalIndex, 0);\n      }\n      return this.clampIndexToSlides(logicalIndex);\n    }\n    return logicalIndex;\n  }\n\n  /**\n   * Calculates the offset index for a circular list.\n   * @param {number} index Starting index.\n   * @param {number} displacement Offset from the starting index. Can be negative\n   *     or positive. For example, -2 or 2.\n   * @param {number} length Length of the list.\n   * @return {number} The index of the relative displacement, wrapping around\n   *     the end of the list to the start when the displacement is larger than\n   *     what's left in the list.\n   */\n  _getRelativeIndex(index, displacment) {\n    return math.wrapAroundList(index, displacment, this._slides.length);\n  }\n\n  /**\n   * @return {boolean} Whether a given index is out of range of the carousel.\n   */\n  isIndexOutOfRange(index) {\n    return index <= -1 || index >= this._slides.length;\n  }\n\n  clampIndexToSlides(index) {\n    return math.clamp(index, 0, this._slides.length - 1);\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the first slide.\n   */\n  isFirstSlide() {\n    return this.getSelectedIndex() === 0;\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the last slide.\n   */\n  isLastSlide() {\n    return this.getSelectedIndex() === this._slides.length - 1;\n  }\n\n  /**\n   * Generates the array which will follow the DOM order of the slides in their\n   * container and saves it.\n   * @private\n   */\n  _setSlideIndices() {\n    this._slideIndices = new Array(this._slides.length);\n\n    for (let i = 0, len = this._slides.length; i < len; i++) {\n      this._slideIndices[i] = i;\n    }\n  }\n\n  /** @return {!Array.<!number>} The slide indices array. */\n  getSlideIndices() {\n    return this._slideIndices;\n  }\n\n  /**\n   * Retrieves the slide children.\n   * @param {Element=} optSlide Slide to look within.\n   * @return {Array.<Element>} NodeList of slide children.\n   * @private\n   */\n  _getSlideChildren(optSlide) {\n    return this.getElementsByClass(Carousel.Classes.SLIDE_CHILD, optSlide);\n  }\n\n  /**\n   * Modifieds the _slideIndices array to represent the DOM order of the slides\n   * within their container.\n   * @param {number} currentValue The value to be moved. This is the same as the\n   *     logical index.\n   * @param {number} toIndex The location to move it to in the array. It will be\n   *     clamped between zero and one less than the length of the array. This is\n   *     also referred to as the DOM index.\n   * @private\n   */\n  _moveIndex(currentValue, toIndex) {\n    const clampedIndex = this.clampIndexToSlides(toIndex);\n    const fromIndex = this._getDomIndex(currentValue);\n    const arr = this._slideIndices;\n\n    // Array moveIndex.\n    arr.splice(clampedIndex, 0, arr.splice(fromIndex, 1)[0]);\n  }\n\n  /**\n   * Swaps positions of two logical indices in the slide indices array.\n   * @param {number} logIndex1 First logical index which will be swappeed.\n   * @param {number} logIndex2 Second logical index to be swapped.\n   * @private\n   */\n  _swapIndexes(logIndex1, logIndex2) {\n    const domIndexOfLogicalIndex1 = this._getDomIndex(logIndex1);\n    this._slideIndices[domIndexOfLogicalIndex1] = -1;\n    this._slideIndices[this._getDomIndex(logIndex2)] = logIndex1;\n    this._slideIndices[domIndexOfLogicalIndex1] = logIndex2;\n  }\n\n  /**\n   * Gets the slide positions (offsets from the left|top) array.\n   * @param {Array.<Element>} slideSet the slides array.\n   * @return {Array.<number>} array of slide positions.\n   * @private\n   */\n  _getPositions(slideSet) {\n    const bounds = this.getWrapper().getBoundingClientRect()[this._posAttr];\n    return slideSet.map(el => el.getBoundingClientRect()[this._posAttr] - bounds);\n  }\n\n  /**\n   * Enable or disable dragging.\n   * @param {boolean} enabled Whether it should be draggable.\n   * @private\n   */\n  _setDraggableEnabled(enabled) {\n    if (this.draggable) {\n      this.draggable.isEnabled = enabled;\n    } else {\n      this.pointer.isEnabled = enabled;\n    }\n  }\n\n  /**\n   * Enable or disable dragging of the carousel.\n   * @param {boolean} isDraggable Whether it should be draggable.\n   */\n  setDraggable(isDraggable) {\n    this._isDraggable = isDraggable;\n    this._setDraggableEnabled(isDraggable);\n  }\n\n  /**\n   * Public method which returns the enabled state.\n   * @return {boolean}\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  /**\n   * Toggle the enabled/disabled state of the carousel. When it's disabled, it\n   * will not be able to navigate slides.\n   * @param {boolean} enabled Whether to enable or disable.\n   */\n  set isEnabled(enabled) {\n    this._isEnabled = enabled;\n    this._setDraggableEnabled(enabled);\n  }\n\n  /**\n   * Gets the adjusted position.\n   * @param {Element} destinationSlide The slide the carousel is headed to.\n   * @return {number} The position it is.\n   * @private\n   */\n  _getNewPosition(destinationSlide) {\n    // Destination position.\n    let destinationPosition = destinationSlide[this._offsetPosition];\n\n    // Width or height of the carousel element.\n    const carouselSize = style.getSize(this.getCarouselElement())[this._dimensionAttr];\n\n    if (this.options.isCentered) {\n      const destinationSize = style.getSize(destinationSlide)[this._dimensionAttr];\n      const wrapperSize = style.getSize(this.getWrapper())[this._dimensionAttr];\n      this._startEdge = (wrapperSize - destinationSize) / 2;\n      destinationPosition -= this._startEdge;\n    }\n\n    let position = destinationPosition / carouselSize;\n\n    if (this._hasSlideChildren && this.isLastSlide()) {\n      // Adjust the position again if there are slide children in the last slide.\n      position = this._getPositionForSlideChildren(destinationSlide,\n        destinationPosition, carouselSize);\n    }\n\n    return position;\n  }\n\n  /**\n   * Adjust the destination position again if there are slide children.\n   * @param {Element} destinationSlide Slide element.\n   * @param {number} destinationPosition Where the slide would initially go.\n   * @param {number} carouselSize Width or height of the carousel element.\n   * @return {number} New destination position.\n   * @private\n   */\n  _getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize) {\n    // Size of the combined width/height + margins of the slide children\n    // within the destination slide.\n    const childrenSum = style.getElementsSize(\n      this._getSlideChildren(destinationSlide), this._dimensionAttr);\n\n    // width|height of the carousel slide.\n    const slideSize = style.getSize(destinationSlide)[this._dimensionAttr];\n\n    // The destination position minus the empty space in the next slide in px.\n    const newPosition = destinationPosition - (slideSize - childrenSum);\n\n    // Calculate the percentage from the pixel value.\n    return newPosition / carouselSize;\n  }\n\n  /**\n   * Returns the translated position based on carousel direction.\n   * @param {string} pos The position (eg \"25%\").\n   * @return {string} the css value for transform.\n   * @private\n   */\n  _getCssPosition(pos) {\n    return 'translate' + this._translateAxis + '(' + pos + ')';\n  }\n\n  /** @private */\n  _setSlidesToLogicalOrder() {\n    const frag = document.createDocumentFragment();\n\n    this._slides.forEach(frag.appendChild, frag);\n\n    this._carouselEl.appendChild(frag);\n\n    // Reset the slide indices array.\n    this._setSlideIndices();\n  }\n\n  /**\n   * If this is a jumped carousel, prepare the slides for the jump by swapping\n   * elements out and setting the `isJumped` option.\n   * @param {number} toDomIndex Index of the slide the carousel is jumping to.\n   * @return {number} If this function changed the order the slides, it returns\n   *     the new DOM index the carousel is going to. Otherwise it returns the\n   *     DOM index parameter it was given.\n   * @private\n   */\n  _setNeighborSlidesForJump(toDomIndex) {\n    const toLogicalIndex = this._getLogicalIndex(toDomIndex);\n    const currentLogicalIndex = this._getLogicalIndex(this.domIndex);\n\n    this._isJumped = true;\n\n    // Where to move the slide to. Next to the current index.\n    const destinationDomIndex = toLogicalIndex > currentLogicalIndex ?\n      this.domIndex + 1 :\n      this.domIndex - 1;\n\n    // Swap indices.\n    // Swap destination slide with current slide at the destination.\n    this._swapSlides(toLogicalIndex, this._getLogicalIndex(destinationDomIndex));\n\n    // Return the dom index the carousel is actually going to.\n    return destinationDomIndex;\n  }\n\n  /**\n   * Swap indices and DOM elements.\n   * @param {number} index1 Logical index 1.\n   * @param {number} index2 Logical index 2.\n   * @private\n   */\n  _swapSlides(index1, index2) {\n    this._swapIndexes(index1, index2);\n    dom.swapElements(this.getSlide(index1), this.getSlide(index2));\n  }\n\n  /**\n   * This function initializes the slideshow functionality for the\n   * carousel. It sets an interval for the slideshow to continue animate\n   * based on the option slideshowSpeed.\n   */\n  startSlideshow() {\n    // Create the timer if it doesn't already exist.\n    if (!this._timer) {\n      this._timer = new Timer(this._slideshowTimerExpired.bind(this),\n        this.options.slideshowSpeed, true);\n    }\n\n    this._timer.start();\n  }\n\n  /**\n   * A simple method which pauses the _timer\n   * once thats paused the slideshow will stop ticking.\n   * Can be re-initialzed by running `startSlideshow()`\n   */\n  pauseSlideshow() {\n    if (this._isSlideshowPlaying()) {\n      this._timer.stop();\n    }\n  }\n\n  /**\n   * Whether the slideshow timer exists and is currently ticking.\n   * @return {boolean}\n   * @private\n   */\n  _isSlideshowPlaying() {\n    return !!this._timer && this._timer.isTicking;\n  }\n\n  // getNthSibling returns null if it cannot find the nth sibling,\n  // but if `null` is used in `insertBefore`, it will append the element\n  // to the end.\n  getInnocentNeighbor(iterator, isNext) {\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    return isNext ?\n      dom.getNthSibling(currentSlideEl, iterator + 1) :\n      dom.getNthSibling(currentSlideEl, iterator, false) ||\n      dom.getFirstElementChild(this._carouselEl);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNeighborInsertionIndex(iterator, isNext, currentDomIndex) {\n    return isNext ?\n      currentDomIndex + iterator + 1 :\n      currentDomIndex - iterator;\n  }\n\n  /**\n   *\n   * @param {number} iterator Neighbor index.\n   * @param {number} relativePos Neighbor index relative to the current index.\n   * @param {boolean} isNext Whether to move the slide next or previous.\n   * @private\n   */\n  _setNeighborSlide(iterator, relativePos, isNext) {\n    const index = this.getSelectedIndex();\n    const indices = this.getSlideIndices();\n\n    // Previous calls to set neighbor slide may have changed the DOM, so\n    // don't rely on stored variables.\n    const currentDomIndex = this._getDomIndex(index);\n\n    // Index of the future neighbor relative to the original DOM order.\n    const logicalNeighborIndex = this._getRelativeIndex(index, relativePos);\n\n    // Do the slides need to be rearranged? Check the current indices to see\n    // if the new neighbors are already there.\n    if (indices[currentDomIndex + relativePos] !== logicalNeighborIndex) {\n      // The slide to insert the new neighbor before.\n      const innocentNeighbor = this.getInnocentNeighbor(iterator, isNext);\n      const insertionIndex = this.getNeighborInsertionIndex(iterator, isNext, currentDomIndex);\n      const neighborEl = this.getSlide(logicalNeighborIndex);\n\n      // Move the neighbor's index to be a neighbor to the current dom index.\n      this._moveIndex(logicalNeighborIndex, insertionIndex);\n      this._carouselEl.insertBefore(neighborEl, innocentNeighbor);\n    }\n  }\n\n  /**\n   * This function makes sure that looped carousels always have a neighbor to\n   * go to. It repositions the viewport if it has to move slides around.\n   * @private\n   */\n  _setNeighborSlides() {\n    let i;\n\n    // Set the left neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, -(i + 1), false);\n    }\n\n    // Set the right neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, i + 1, true);\n    }\n  }\n\n  /**\n   * Reset the carousel back to the currently selected slide without animation.\n   */\n  _snapToCurrentSlide() {\n    this.goToSlide(this._getDomIndex(this.getSelectedIndex()), true);\n  }\n\n  /**\n   * Determine if the distance between current and destination slides is more\n   * than one slide. If it's not, there is no need to \"jump\".\n   * @param {number} domIndex DOM index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating.\n   * @return {number} DOM index of the slide to go to because moving slides\n   *     around to \"jump\" them will causes indices to change.\n   */\n  _maybeSetJumpedSlides(domIndex, noAnimation) {\n    // Determine if the distance between current and destination slides\n    // is more than one slide. If it's not, there's no need to \"jump\".\n    if (this.options.isJumped && !noAnimation && Math.abs(this.domIndex - domIndex) > 1) {\n      return this._setNeighborSlidesForJump(domIndex);\n    }\n    return domIndex;\n  }\n\n  /**\n   * Determine whether or not the carousel can navigate in its current condition.\n   * @param {number} domIndex Dom index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating there.\n   * @return {boolean}\n   */\n  _canNavigate(domIndex, noAnimation) {\n    const isSameSlideWithAnimation = domIndex === this.domIndex && !noAnimation;\n\n    // Whether the carousel would be able to move.\n    const isOffset = this.hasDragged || this._isOffset;\n\n    // 1) Whether the carousel is enabled.\n    // 2) The index is out of range and the carousel isn't set to loop. Silently\n    // exit here instead of throwing errors everywhere.\n    // 3) Trying to go to the slide it's already on with a transition and no\n    // dragging has occured or the carousel is not offset.\n    return !(\n      (!this._isEnabled) ||\n      (!this.options.isLooped && this.isIndexOutOfRange(domIndex)) ||\n      (isSameSlideWithAnimation && !isOffset));\n  }\n\n  _toNewSlide() {\n    // Set flag meaning the carousel is waiting for a transition end.\n    this.isTransitioning = true;\n\n    // Fire event saying the slide started to transition.\n    this._emitEvent(new CarouselEvent(\n      Carousel.EventType.SLIDE_START,\n      this,\n      this._getLogicalIndex(this.lastDomIndex),\n      this._getLogicalIndex(this.domIndex)));\n  }\n\n  /**\n   * Uses Css transforms to move the carousel to a new position.\n   * @param {string} position The percentage value.\n   * @param {boolean} noAnimation Whether to move with animation or not.\n   * @private\n   */\n  _moveToPosition(position, noAnimation) {\n    // Set transform.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = this._getCssPosition(position);\n\n    // Set transition speed to zero so that it happens instantly.\n    if (noAnimation) {\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n\n      // Listen for transitionend if it will animate.\n    } else {\n      // Set transition speed.\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] =\n        this.options.animationSpeed + 'ms';\n\n      // This is used as a backup to the transitionend event, which sometimes\n      // doesn't fire on iOS 7 Safari when the carousel has only been dragged a\n      // few pixels. It's set to go off ~2 frames after the transition end event\n      // should have occurred.\n      this._transitionId = animation.onTransitionEnd(this._carouselEl,\n        this._transitionDone,\n        this,\n        OdoDevice.Dom.TRANSFORM,\n        this.options.animationSpeed + Carousel.TRANSITION_END_WAIT);\n\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Calculates the offset of the carousel relative to the current slide.\n   * @return {number}\n   */\n  _getCarouselOffset() {\n    const matrix = getComputedStyle(this._carouselEl)[OdoDevice.Dom.TRANSFORM];\n\n    // Round to 1 decimal place because the `_startEdge` can be a decimal.\n    const translate = Math.round(\n      getTranslate(matrix)[this._translateAxis.toLowerCase()] * 10,\n    ) / 10;\n\n    const slideOffset = this.getSlide(this.getSelectedIndex())[this._offsetPosition];\n    return slideOffset + translate;\n  }\n\n  /**\n   * If the carousel is waiting for a transition to finish (going to a slide),\n   * but the user tells it to navigate again, the previous listener for the\n   * transition end event needs to be canceled. This allows the user to quickly\n   * click through the carousel without waiting for each navigation to finish.\n   *\n   * For jumped and looped carousels, the carousel element needs to be\n   * repositioned because setting neighbor slides will cause the elements to\n   * shift within the main carousel element. The current offset relative to\n   * the current slide is saved before moving any slide elements, then the slide\n   * elements are moved, and finally the carousel is set to appear as if the\n   * elements never moved.\n   */\n  _cancelMovement() {\n    if (!this.isTransitioning) {\n      return;\n    }\n\n    this.isTransitioning = false;\n    animation.cancelTransitionEnd(this._transitionId);\n\n    // Fading carousels do not need to reposition themselves.\n    if (this.options.isFade) {\n      return;\n    }\n\n    // Save the offset relative to the current slide before slides are moved.\n    const carouselSize = style.getSize(this.getCarouselElement())[this._dimensionAttr];\n    const offset = this._getCarouselOffset();\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    // Now that the current slide has potentially moved in the DOM, update the\n    // carousel's offset.\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    const newSlideOffset = currentSlideEl[this._offsetPosition];\n    const position = (newSlideOffset - offset) / carouselSize;\n\n    // Setting the position here stops the browser from transitioning to the\n    // previous position, allowing the user to \"catch\" the carousel mid-nav.\n    this._moveToPosition((position * -100) + '%', true);\n    this.draggable.update();\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  fadeToSlide(domIndex, optNoAnimation) {\n    // Get next and previous slides.\n    const nextSlide = this.getSlide(domIndex, true);\n    const previousSlide = this.getSlide(this.domIndex, true);\n\n    // Listen for transitionend if it will animate.\n    if (!optNoAnimation) {\n      // Going to a new slide, wait for callback.\n      this._transitionId = animation.onTransitionEnd(nextSlide, this._transitionDone, this);\n    }\n\n    // Show next slide. Put the previous behind the next.\n    nextSlide.classList.add(Carousel.Classes.VISIBLE);\n\n    if (previousSlide !== nextSlide) {\n      previousSlide.classList.add(Carousel.Classes.BEHIND);\n\n      // Delay the previous slide fading out by the specified percentage.\n      // The crossfade amount is between 0 and 1. A value of 1 means that both slides\n      // will fade at the same time. A crossfade of zero means the previous slide\n      // will wait until the next slide has completely faded in before it fades out.\n      setTimeout(() => {\n        previousSlide.classList.remove(Carousel.Classes.VISIBLE);\n      }, this._crossfadeTimeout);\n    }\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = domIndex;\n\n    // Emit event for slide start.\n    if (!optNoAnimation) {\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  goToSlide(domIndex, optNoAnimation) {\n    // Get the destion slide element from the current DOM order.\n    const destinationSlide = this.getSlide(this._getLogicalIndex(domIndex));\n\n    // If the carousel skips inbetween slides, reposition them.\n    // DOM index is reassinged here because if the slides are repositioned,\n    // the DOM index of the carousel changes.\n    const updatedDomIndex = this._maybeSetJumpedSlides(domIndex, optNoAnimation);\n\n    // The position the container will go to.\n    const adjustedPosition = (this._getNewPosition(destinationSlide) * -100) + '%';\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = updatedDomIndex;\n\n    // Set the css styles to move the carousel element. This also dispatches\n    // the slide start event if the carousel element will move with animation.\n    this._moveToPosition(adjustedPosition, optNoAnimation);\n  }\n\n  /**\n   * Helper function for going to a given index. This method should be used\n   * instead of the private one to abstract the DOM order stuff.\n   * @param {number} index The logical, zero based index of the slide you wish\n   *     the carousel to go to.\n   * @param {boolean=} optNoAnimation Optional skip the animation in goToSlide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  setSelectedIndex(index, optNoAnimation) {\n    let domIndex = this._getDomIndex(index);\n    const canNavigate = this._canNavigate(domIndex, optNoAnimation);\n\n    // Will go the the give slide.\n    if (canNavigate) {\n      // If the event's default action was prevented, return false.\n      if (this._emitEvent(new CarouselEvent(Carousel.EventType.WILL_NAVIGATE, this))) {\n        return false;\n      }\n\n      this._cancelMovement();\n\n      this._selectedIndex = this._getSafeIndex(index);\n\n      // Convert new safe logical index to a DOM index.\n      domIndex = this._getDomIndex(this._selectedIndex);\n\n      // Set new classes on the slide elements. This is also where toggling\n      // paddles and pagination should go.\n      this._setSlidesState();\n      this._setPaddleState();\n      this._setPaginationState();\n      if (this.options.isFade) {\n        this.fadeToSlide(domIndex, optNoAnimation);\n      } else {\n        this.goToSlide(domIndex, optNoAnimation);\n      }\n    }\n\n    // Otherwise, it will not go to the give slide due to unmet conditions.\n    return canNavigate;\n  }\n\n  /**\n   * Find the nearest slide, and move the carousel to that.\n   * @param {boolean} isNext Whether it should go to the nearest slide, but\n   *     only in the next direction. False means it should go previous and\n   *     anything not true or false will go to the nearest slide regardless\n   *     of direction.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNearestSlide(isNext) {\n    // Gets positions relative to the wrapper element of each slide.\n    const positions = this._getPositions(this.getSlides());\n\n    // Current position (the left side of the carousel wrapper)\n    // Gets the closest value in the array to the given value.\n    // Index of the closest value.\n    let logicalIndex = positions.indexOf(array.closest(positions, this._startEdge));\n\n    // When going to a next or previous slide, the closest index could\n    // still be the one that's currently selected, but the carousel should\n    // still move next/previous because it has enough velocity.\n    if (logicalIndex === this.getSelectedIndex()) {\n      if (isNext === true) {\n        logicalIndex = this._getSafeIndex(logicalIndex + 1);\n      } else if (isNext === false) {\n        logicalIndex = this._getSafeIndex(logicalIndex - 1);\n      }\n    }\n\n    return this.setSelectedIndex(logicalIndex);\n  }\n\n  /**\n   * Go to the next slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNextSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() + 1);\n  }\n\n  /**\n   * Go to the previous slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToPreviousSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() - 1);\n  }\n\n  /**\n   * Sets the past, previous, active, next, and future classes to the appropriate\n   * slides.\n   * @private\n   */\n  _setSlidesState() {\n    const selectedIndex = this.getSelectedIndex();\n    const past = this._getSafeIndex(selectedIndex - 2);\n    const previous = this._getSafeIndex(selectedIndex - 1);\n    const next = this._getSafeIndex(selectedIndex + 1);\n    const future = this._getSafeIndex(selectedIndex + 2);\n\n    // This works because the _slides array does not mimic the DOM order.\n    this.getSlides().forEach((slide, i) => {\n      const isActive = i === selectedIndex;\n\n      toggleFocusability(slide, isActive);\n\n      slide.setAttribute('aria-hidden', !isActive);\n\n      // Active slide.\n      slide.classList.toggle(Carousel.Classes.ACTIVE_SLIDE, isActive);\n\n      // Previous previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PAST_SLIDE,\n        i === past && selectedIndex !== past && previous !== past);\n\n      // Previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PREVIOUS_SLIDE,\n        i === previous && selectedIndex !== previous);\n\n      // Next slide.\n      slide.classList.toggle(\n        Carousel.Classes.NEXT_SLIDE,\n        i === next && selectedIndex !== next);\n\n      // Next next slide.\n      slide.classList.toggle(\n        Carousel.Classes.FUTURE_SLIDE,\n        i === future && selectedIndex !== future && next !== future);\n    });\n  }\n\n  _setPaginationState() {\n    if (this.options.pagination) {\n      const selectedIndex = this.getSelectedIndex();\n      this._paginationDots.forEach(({ dot, i, i2 }) => {\n        const selected = selectedIndex === i || selectedIndex === i2;\n        dot.classList.toggle(Carousel.Classes.PAGINATION_DOT_SELECTED, selected);\n        dot.setAttribute('aria-selected', selected);\n      });\n    }\n  }\n\n  _setPaddleState() {\n    const notLooped = !this.options.isLooped;\n    if (notLooped && this._paddlePrevious) {\n      const first = this.isFirstSlide();\n      this._paddlePrevious.classList.toggle(Carousel.Classes.PADDLE_DISABLED, first);\n      this._paddlePrevious.setAttribute('aria-disabled', first);\n    }\n\n    if (notLooped && this._paddleNext) {\n      const last = this.isLastSlide();\n      this._paddleNext.classList.toggle(Carousel.Classes.PADDLE_DISABLED, last);\n      this._paddleNext.setAttribute('aria-disabled', last);\n    }\n  }\n\n  /**\n   * Callback for when the slideshow timer expires.\n   * @private\n   */\n  _slideshowTimerExpired() {\n    // Pause the timer if it's at the end.\n    if (!this.options.isLooped && this.isLastSlide()) {\n      this.pauseSlideshow();\n    } else {\n      this.goToNextSlide();\n    }\n  }\n\n  _transitionDone() {\n    const from = this._getLogicalIndex(this.lastDomIndex);\n    const to = this._getLogicalIndex(this.domIndex);\n\n    // Needs to come before setting neighbor slides.\n    this.isTransitioning = false;\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    // Neighboring slides must be set after each transition for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    if (this._isJumped || this._isSlidingLooped) {\n      this._snapToCurrentSlide();\n    }\n\n    if (this.options.isFade) {\n      this.getSlide(from).classList.remove(Carousel.Classes.BEHIND);\n    }\n\n    // No longer jumped.\n    this._isJumped = false;\n\n    // Dispatch slide end event.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_END, this, from, to));\n  }\n\n  /**\n   * Received the pointer end event.\n   * @param {PointerEvent} pointerEvent Pointer event object.\n   */\n  _handlePointerEnd(pointerEvent) {\n    if (this.pointer.hasVelocity(pointerEvent.velocity)) {\n      if (pointerEvent.direction === OdoPointer.Direction.RIGHT) {\n        this.goToPreviousSlide();\n      } else if (pointerEvent.direction === OdoPointer.Direction.LEFT) {\n        this.goToNextSlide();\n      }\n    }\n  }\n\n  /**\n   * The click listener is bound to the main element. Inside the handler, the target\n   * of the click is tested and if it is a pagination dot or paddle, navigation\n   * will be started.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleClick(evt) {\n    const target = evt.target;\n    let willNavigate = false;\n\n    // Determine what was clicked.\n    const dot = target.closest('.' + Carousel.Classes.PAGINATION_DOT);\n    const prev = target.closest('.' + Carousel.Classes.PADDLE_PREV);\n    const next = target.closest('.' + Carousel.Classes.PADDLE_NEXT);\n\n    // Navigation dot.\n    if (dot) {\n      willNavigate = true;\n      this.setSelectedIndex(parseInt(dot.getAttribute('data-index'), 10));\n\n    // Left paddle or child of left paddle.\n    } else if (prev) {\n      willNavigate = true;\n      this.goToPreviousSlide();\n\n    // Right paddle or child of right paddle.\n    } else if (next) {\n      willNavigate = true;\n      this.goToNextSlide();\n\n    // If the carousel slides have links in them, some browsers (Firefox), will\n    // emit the click event even after a drag if the mouse is still on the\n    // clickable element.\n    } else if (this.isTransitioning) {\n      evt.preventDefault();\n    }\n\n    if (willNavigate) {\n      evt.preventDefault();\n\n      // Pause slideshow if it's playing.\n      this.pauseSlideshow();\n    }\n  }\n\n  /**\n   * Stop animations that were ongoing when you started to drag.\n   * @private\n   */\n  _handleDragStart() {\n    this.pauseSlideshow();\n    this._cancelMovement();\n\n    // Remove transition while dragging.\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n  }\n\n  /**\n   * Pointer move event. Set a friction value if on the first/last slide and\n   * going towards the edge.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragMove({ delta }) {\n    this.hasDragged = this.isVertical ?\n      Math.abs(delta.y) > 0 :\n      Math.abs(delta.x) > 0;\n    if (!this.options.isLooped) {\n      const friction = this._isMovingTowardsEdge(delta.x, delta.y) ? 0.4 : 1;\n      this.draggable.friction = friction;\n    }\n  }\n\n  /**\n   * Depending on how fast you were dragging, either proceed to an adjacent\n   * slide or reset position to the nearest one.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    this.draggable.friction = 1;\n    this.navigateAfterDrag(evt.velocity, evt.axisDirection, evt.didMoveOnAxis);\n    this.hasDragged = false;\n    this._isOffset = false;\n  }\n\n  _shouldGoToPrevious(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isFirstSlide()) && (\n      direction === OdoPointer.Direction.RIGHT ||\n      direction === OdoPointer.Direction.DOWN);\n  }\n\n  _shouldGoToNext(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isLastSlide()) && (\n      direction === OdoPointer.Direction.LEFT ||\n      direction === OdoPointer.Direction.UP);\n  }\n\n  navigateAfterDrag(velocity, direction, didMoveOnAxis) {\n    const hasVelocity = this.hasDragged && this.draggable.pointer.hasVelocity(velocity);\n\n    // If dragging has not occurred, the user simply clicked on the carousel.\n    // If the user is quickly navigating through the carousel, then clicks on\n    // it, the movement will be canceled, but it wouldn't go anywhere because it\n    // appears to be going to the same slide. Determine if the carousel is still\n    // between slides (offset). If it is, it needs to go to the nearest slide.\n    if (!this.hasDragged) {\n      this._isOffset =\n        Math.abs(Math.round(this._getCarouselOffset())) > Math.round(this._startEdge);\n    }\n\n    // Previous.\n    if (this._shouldGoToPrevious(hasVelocity, direction)) {\n      this.goToNearestSlide(false);\n\n    // Next.\n    } else if (this._shouldGoToNext(hasVelocity, direction)) {\n      this.goToNearestSlide(true);\n\n    // Not enough velocity, go to the nearest slide.\n    // The distance must at least be 1, otherwise gotoSlide creates an event\n    // listener for moving the element by zero pixels and the transition end\n    // event doesn't fire.\n    } else if (didMoveOnAxis || this._isOffset) {\n      this.goToNearestSlide();\n    }\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {CarouselEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Whether the carousel is being dragged towards an edge.\n   * @param {number} deltaX Change in x during drag.\n   * @param {number} deltaY Change in y during drag.\n   * @return {boolean}\n   * @private\n   */\n  _isMovingTowardsEdge(deltaX, deltaY) {\n    const toStartEdge = this.isVertical ?\n      deltaY > 0 :\n      deltaX > 0;\n    const toEndEdge = this.isVertical ?\n      deltaY < 0 :\n      deltaX < 0;\n\n    return (this.isFirstSlide() && toStartEdge) || (this.isLastSlide() && toEndEdge);\n  }\n\n  /**\n   * Remove event listeners, DOM references, inline styles, class names, paddles,\n   * and pagination added by Carousel.\n   */\n  dispose() {\n    if (this._timer) {\n      this._timer.dispose();\n    }\n\n    this._removeA11yAttributes();\n    this._removePaddles();\n    this._removePagination();\n\n    // Reset container styles.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = '';\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION] = '';\n\n    if (this.options.isFade) {\n      this.pointer.off(OdoPointer.EventType.END, this._onPointerEnd);\n      this.pointer.dispose();\n\n      this.getSlides().forEach((slide) => {\n        slide.style[OdoDevice.Dom.TRANSITION] = '';\n      });\n    } else {\n      this.draggable.off(OdoDraggable.EventType.START, this._onDragStart);\n      this.draggable.off(OdoDraggable.EventType.MOVE, this._onDragMove);\n      this.draggable.off(OdoDraggable.EventType.END, this._onDragEnd);\n\n      this.draggable.dispose();\n    }\n\n    this.element.removeEventListener('click', this._onClick);\n\n    this._slides.forEach((slide) => {\n      slide.classList.remove(\n        Carousel.Classes.PAST_SLIDE,\n        Carousel.Classes.PREVIOUS_SLIDE,\n        Carousel.Classes.ACTIVE_SLIDE,\n        Carousel.Classes.NEXT_SLIDE,\n        Carousel.Classes.FUTURE_SLIDE,\n        Carousel.Classes.VISIBLE,\n        Carousel.Classes.BEHIND,\n      );\n    });\n\n    // When the carousel is bidirectional, it has cloned the first two slides\n    // and added them to the carousel element. Remove the clones.\n    if (this._isBidirectional) {\n      this._carouselEl.removeChild(this._slides[2]);\n      this._carouselEl.removeChild(this._slides[3]);\n    }\n\n    // Null out DOM refs.\n    this.element = null;\n    this._slideContainerParentEl = null;\n    this._carouselEl = null;\n    this._paddlePrevious = null;\n    this._paddleNext = null;\n    this._paginationDots = null;\n    this.draggable = null;\n    this.pointer = null;\n    this._slides.length = 0;\n  }\n\n  /**\n   * Because Object.assign only does a shallow merge, merge the template option\n   * first and then overwrite the main Object.assign result.\n   * @param {Object} options Options object.\n   * @return {Object} Merged options object with defaults.\n   */\n  static getOptions(options) {\n    const templates = Object.assign({}, Carousel.Defaults.template, options.template);\n    const opts = Object.assign({}, Carousel.Defaults, options);\n    opts.template = templates;\n    return opts;\n  }\n}\n\nObject.assign(Carousel, settings);\n\nCarousel.template = templateEngine;\n\nexport default Carousel;\n","/**\n * A simple string replacement template with double curly braces. You can use\n * nested objects and functions too.\n *\n * Usage:\n *     template(\"Today is {{ day }}\", {\n *       day: 'Friday'\n *     }); // \"Today is Friday\"\n *\n *     template(\"Today is {{ month.day }}\", {\n *       month: {\n *         day: \"Friday\"\n *       }\n *     }); // \"Today is Friday\n *\n *     template(\"Today is {{ day }}\", {\n *       dayOfTheWeek: 'Friday',\n *       day: function() {\n *         return this.dayOfTheWeek;\n *       }\n *     }); // \"Today is Friday\"\n *\n *\n * @param {string} str Template.\n * @param {Object} data Data object with keys which match your template.\n * @return {string}\n */\nexport default function template(str, data) {\n  // A modified version of Malsup's template method for Cycle.\n  // https://github.com/malsup/cycle2/blob/master/src/jquery.cycle2.tmpl.js\n\n  // Regex which matches {{cool}} or {{ cool }} where `cool` is what should\n  // be replaced.\n  return str.replace(/{{\\s?((.)?.*?)\\s?}}/g, (match, str) => {\n    const names = str.split('.');\n    let obj = data;\n    let property;\n\n    // If the name has dots in it, \"person.name\", loop through each one.\n    if (names.length > 1) {\n      property = obj;\n      for (let i = 0; i < names.length; i++) {\n        obj = property;\n        property = property[names[i]] || str;\n      }\n\n    // Otherwise, it's a simple assignment from the data object.\n    } else {\n      property = obj[str];\n    }\n\n    // If they passed a function, use that.\n    if (typeof property === 'function') {\n      return property.call(obj);\n    }\n\n    // Return the string if it exists.\n    if (property !== undefined && property !== null && property !== str) {\n      return property;\n    }\n\n    // Otherwise, return the original string.\n    return str;\n  });\n}\n"],"names":["getTranslate","str","array","match","parseFloat","uniqueId","toggleFocusability","parent","canFocus","focusableElements","elements","Array","from","querySelectorAll","matches","push","i","length","removeAttribute","tabIndex","CarouselEvent","type","carousel","optFrom","optTo","target","element","to","hasSlideChanged","defaultPrevented","preventDefault","count","Carousel","options","_TinyEmitter","Element","TypeError","getOptions","isVertical","_this","_isSlidingLooped","isLooped","isFade","domIndex","lastDomIndex","_selectedIndex","_slideContainerParentEl","_carouselEl","_slides","_isJumped","_isEnabled","_posAttr","_offsetPosition","string","capitalize","_dimensionAttr","_translateAxis","isTransitioning","_transitionId","_hasSlideChildren","_isDraggable","hasDragged","_isOffset","_timer","_crossfadeTimeout","animationSpeed","crossfadeAmount","_startEdge","draggable","pointer","_isBidirectional","resetSync","reset","decorate","getElementsByClass","className","context","this","getElementsByClassName","getElementByClass","_saveDomElements","_decorateBidirectionalCarousel","_setA11yAttributes","_renderPaddles","pagination","_renderPagination","_saveRenderedElements","_setSlideIndices","_decorateFadeCarousel","_decorateRegularCarousel","_onClick","_handleClick","bind","addEventListener","setSelectedIndex","_getSafeIndex","startIndex","_setNeighborSlides","_snapToCurrentSlide","style","OdoDevice","Dom","TRANSITION_PROPERTY","Css","TRANSFORM","TRANSITION_TIMING_FUNCTION","easing","_getSlideChildren","bindDragEvents","getSlides","forEach","slide","TRANSITION","_this2","classList","add","Classes","VISIBLE","bindSwipeEvents","getCarouselElement","appendChild","cloneNode","SLIDE","getWrapper","setAttribute","giveId","_removeA11yAttributes","WRAPPER","CAROUSEL_ELEMENT","_paddlePrevious","PADDLE_PREV","_paddleNext","PADDLE_NEXT","_paginationDots","PAGINATION_DOT","map","parseInt","dot","getAttribute","insertAdjacentHTML","_getNavPaddleHtml","_removePaddles","_removeByClass","PADDLES","parentNode","removeChild","getNavPaddleHtml","call","template","paddles","paddlePrev","paddlePrevInner","paddleNext","paddleNextInner","_getPaginationHtml","_removePagination","PAGINATION","getPaginationHtml","dots","_buildPaginationHtml","paginationDotSecondary","paginationDot","reduce","dotsHtml","arr","data","id","_this4","secondaryIndex","hidden","OdoDraggable","OdoPointer","Axis","Y","X","_onDragStart","_handleDragStart","_onDragMove","_handleDragMove","_onDragEnd","_handleDragEnd","on","EventType","START","MOVE","END","_onPointerEnd","_handlePointerEnd","addSlide","slideHtml","_setSlidesToLogicalOrder","selected","getSelectedIndex","getSlide","index","_getDomIndex","logicalIndex","getSlideIndices","indexOf","_getLogicalIndex","isIndexOutOfRange","_getRelativeIndex","clampIndexToSlides","displacment","math","wrapAroundList","clamp","isFirstSlide","isLastSlide","_slideIndices","len","optSlide","SLIDE_CHILD","_moveIndex","currentValue","toIndex","clampedIndex","fromIndex","splice","_swapIndexes","logIndex1","logIndex2","domIndexOfLogicalIndex1","_getPositions","slideSet","bounds","getBoundingClientRect","el","_this5","_setDraggableEnabled","enabled","isEnabled","setDraggable","isDraggable","_getNewPosition","destinationSlide","destinationPosition","carouselSize","getSize","isCentered","destinationSize","wrapperSize","position","_getPositionForSlideChildren","childrenSum","getElementsSize","_getCssPosition","pos","frag","document","createDocumentFragment","_setNeighborSlidesForJump","toDomIndex","toLogicalIndex","currentLogicalIndex","destinationDomIndex","_swapSlides","index1","index2","swapElements","startSlideshow","Timer","_slideshowTimerExpired","slideshowSpeed","start","pauseSlideshow","_isSlideshowPlaying","stop","isTicking","getInnocentNeighbor","iterator","isNext","currentSlideEl","dom","getNthSibling","getFirstElementChild","getNeighborInsertionIndex","currentDomIndex","_setNeighborSlide","relativePos","indices","logicalNeighborIndex","innocentNeighbor","insertionIndex","neighborEl","insertBefore","neighborCount","goToSlide","_maybeSetJumpedSlides","noAnimation","isJumped","Math","abs","_canNavigate","isSameSlideWithAnimation","isOffset","_toNewSlide","_emitEvent","SLIDE_START","_moveToPosition","TRANSITION_DURATION","animation","onTransitionEnd","_transitionDone","TRANSITION_END_WAIT","_getCarouselOffset","matrix","getComputedStyle","translate","round","toLowerCase","_cancelMovement","cancelTransitionEnd","offset","update","fadeToSlide","optNoAnimation","nextSlide","previousSlide","BEHIND","remove","updatedDomIndex","adjustedPosition","canNavigate","WILL_NAVIGATE","_setSlidesState","_setPaddleState","_setPaginationState","goToNearestSlide","positions","closest","goToNextSlide","goToPreviousSlide","selectedIndex","past","previous","next","future","isActive","toggle","ACTIVE_SLIDE","PAST_SLIDE","PREVIOUS_SLIDE","NEXT_SLIDE","FUTURE_SLIDE","i2","PAGINATION_DOT_SELECTED","notLooped","first","PADDLE_DISABLED","last","SLIDE_END","pointerEvent","hasVelocity","velocity","direction","Direction","RIGHT","LEFT","evt","willNavigate","prev","delta","y","x","friction","_isMovingTowardsEdge","navigateAfterDrag","axisDirection","didMoveOnAxis","_shouldGoToPrevious","DOWN","_shouldGoToNext","UP","event","emit","deltaX","deltaY","toStartEdge","toEndEdge","dispose","off","removeEventListener","templates","Object","assign","Defaults","opts","TinyEmitter","settings","replace","names","split","obj","property","undefined"],"mappings":"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"}