{"version":3,"file":"odo-viewport.js","sources":["../src/viewport-item.js","../src/viewport.js"],"sourcesContent":["class ViewportItem {\n  /**\n   * A viewport item represents an element being watched by the Viewport component.\n   * @param {Object} options Viewport item options.\n   * @param {Viewport} parent A reference to the viewport.\n   * @constructor\n   */\n  constructor(options, parent) {\n    this.parent = parent;\n    this.id = Math.random().toString(36).substring(7);\n    this.triggered = false;\n    this.threshold = 200;\n    this.isThresholdPercentage = false;\n\n    // Override defaults with options.\n    Object.assign(this, options);\n\n    // The whole point is to have a callback function. Don't do anything if it's not given.\n    if (typeof this.enter !== 'function') {\n      throw new TypeError('Viewport.add :: No `enter` function provided in Viewport options.');\n    }\n\n    this.parseThreshold();\n\n    this.hasExitCallback = typeof this.exit === 'function';\n\n    // Cache element's offsets and dimensions.\n    this.update();\n  }\n\n  // Use getter for `this.offset` so that the tests don't have to assign\n  // a threshold and an offset.\n  get offset() {\n    return this.isThresholdPercentage ?\n      this.threshold * this.parent.viewportHeight :\n      this.threshold;\n  }\n\n  /**\n   * Update offset and size values.\n   */\n  update() {\n    const box = this.element.getBoundingClientRect();\n    this.height = this.element.offsetHeight;\n    this.width = this.element.offsetWidth;\n    this.top = box.top + window.pageYOffset;\n    this.left = box.left + window.pageXOffset;\n    this.right = this.width + this.left;\n    this.bottom = this.height + this.top;\n  }\n\n  /**\n   * Determine the threshold setting.\n   */\n  parseThreshold() {\n    const value = this.threshold;\n    this.threshold = parseFloat(value);\n\n    // Threshold can be a percentage. Parse it.\n    if ((typeof value === 'string' && value.indexOf('%') > -1)) {\n      this.isThresholdPercentage = true;\n      this.threshold = this.threshold / 100;\n    } else if (this.threshold < 1 && this.threshold > 0) {\n      this.isThresholdPercentage = true;\n    }\n  }\n\n  /**\n   * Nullify references so they're garbage collected.\n   */\n  dispose() {\n    this.element = null;\n    this.enter = null;\n    this.exit = null;\n    this.parent = null;\n  }\n}\n\nexport default ViewportItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport ViewportItem from './viewport-item';\n\nlet instance = null;\n\nfunction inRange(value, min, max) {\n  return min <= value && value <= max;\n}\n\nclass Viewport {\n  /**\n   * Viewport singleton.\n   * @constructor\n   */\n  constructor() {\n    this.addId = null;\n    this.hasActiveHandlers = false;\n    this.items = new Map();\n\n    // Assume there is no horizontal scrollbar. documentElement.clientHeight\n    // is incorrect on iOS 8 because it includes toolbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n    this.viewportTop = 0;\n\n    // What's nice here is that rAF won't execute until the user is on this tab,\n    // so if they open the page in a new tab which they aren't looking at,\n    // this will execute when they come back to that tab.\n    requestAnimationFrame(this.handleScroll.bind(this));\n  }\n\n  get viewportBottom() {\n    return this.viewportTop + this.viewportHeight;\n  }\n\n  /**\n   * Listen for scroll and resize.\n   */\n  bindEvents() {\n    // Listen for global debounced resize.\n    this.resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n\n    // Throttle scrolling because it doesn't need to be super accurate.\n    this.scrollId = OdoWindowEvents.onFastScroll(this.handleScroll.bind(this));\n\n    this.hasActiveHandlers = true;\n  }\n\n  /**\n   * Remove event listeners when there are no longer any viewport items to watch.\n   */\n  unbindEvents() {\n    if (this.items.size === 0) {\n      OdoWindowEvents.remove(this.resizeId);\n      OdoWindowEvents.remove(this.scrollId);\n\n      this.hasActiveHandlers = false;\n    }\n  }\n\n  /**\n   * Watch another item.\n   * @param {Object} options Viewport item options.\n   * @return {string} The new item's id which is used to remove it.\n   */\n  add(options) {\n    const item = new ViewportItem(options, this);\n    this.items.set(item.id, item);\n\n    // Event handlers are removed if a callback is triggered and the\n    // watch list is empty. Because modules are instantiated asynchronously,\n    // another module could potentially add itself to the watch list when the events\n    // have been unbound.\n    // Check here if events have been unbound and bind them again if they have\n    if (!this.hasActiveHandlers) {\n      this.bindEvents();\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Update each item's width/height/top/left values and the viewport size.\n   */\n  saveDimensions() {\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    // Window width and height without scrollbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n\n    return this;\n  }\n\n  /**\n   * Throttled scroll event. Update the viewport top position and process items.\n   */\n  handleScroll() {\n    return this.setScrollTop().process();\n  }\n\n  /**\n   * Update offsets and process items.\n   */\n  update() {\n    return this.saveDimensions().process();\n  }\n\n  /**\n   * Notify the viewport item it has entered view.\n   * @param {ViewportItem} item item.\n   */\n  triggerEnter(item) {\n    item.enter.call(item.element, item);\n\n    if (item.hasExitCallback) {\n      item.triggered = true;\n\n      // If the exit property is not a function, the module no longer needs to\n      // watch it, so remove from list of viewport items.\n    } else {\n      Viewport.remove(item.id);\n\n      // If there are no more, unbind from scroll and resize events\n      this.unbindEvents();\n    }\n  }\n\n  /**\n   * Notify the viewport item it has exited view.\n   * @param {ViewportItem} item item.\n   */\n  triggerExit(item) {\n    item.exit.call(item.element, item);\n    item.triggered = false;\n  }\n\n  /**\n   * Save the new scroll top\n   */\n  setScrollTop() {\n    this.viewportTop = window.pageYOffset;\n    return this;\n  }\n\n  /**\n   * Process each viewport item to see if it is now in view (or out of view).\n   */\n  process() {\n    this.items.forEach(this._processItem, this);\n    this.addId = null;\n\n    return this;\n  }\n\n  /**\n   * Determine if enter or exit callbacks should be executed for a viewport item.\n   * @param {ViewportItem} item Item to test.\n   */\n  _processItem(item) {\n    const isVisible = this.isVisible(item);\n    const isInView = isVisible && this.isInViewport(item);\n\n    // Whether the item is not in the viewport and doesn't have an exit\n    // callback. In this case, the enter callback should be executed\n    // because the browser has already scrolled past the trigger point.\n    const isTopPastView = isVisible && !item.hasExitCallback && this.isTopPastViewport(item);\n\n    // If the enter callback hasn't been triggered and it's in the viewport,\n    // trigger the enter callback.\n    if (!item.triggered && (isInView || isTopPastView)) {\n      this.triggerEnter(item);\n      return;\n    }\n\n    // This viewport has already come into view once (viewport item has been\n    // triggered) and now the bottom is out of view.\n    if (!isInView && item.triggered && item.hasExitCallback &&\n      !this.isBottomInViewport(item)) {\n      this.triggerExit(item);\n    }\n  }\n\n  /**\n   * Whether a viewport item is considered to be in view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isInViewport(item) {\n    const isTopInView = this.isTopInViewport(item);\n\n    // If the item has not come into view, ignore checking to see if the bottom\n    // is in view because this can conflict with the top being in view when the\n    // offset is greater than the height of the watched element.\n    let isBottomInView;\n    if (item.offset >= 0) {\n      if (item.triggered) {\n        isBottomInView = this.isBottomInViewport(item);\n      } else {\n        isBottomInView = false;\n      }\n    } else {\n      // If the offset is negative, assume that it shouldn't wait until the top\n      // is in view before checking the bottom again.\n      isBottomInView = this.isBottomInViewport(item);\n    }\n\n    const isViewPastBottom = this.isViewportPastBottom(item);\n    const spanningViewport = !isTopInView && !isBottomInView && this.doesSpanViewport(item);\n\n    const isSideInView = this.isSideInViewport(item);\n\n    return (isTopInView || isBottomInView || spanningViewport) && !isViewPastBottom && isSideInView;\n  }\n\n  /**\n   * Determine whether a side of the viewport item is within the viewport. A side\n   * is also considered to be in view if the viewport item is wider than the viewport\n   * and its left and right sides are out of view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isSideInViewport(item) {\n    const isLeftInView = inRange(item.left, 0, this.viewportWidth);\n    const isRightInView = inRange(item.right, 0, this.viewportWidth);\n\n    // To span the viewport, it must:\n    // * Wider than the viewport.\n    // * Left side not in view.\n    // * left side less than zero.\n    // * Right side not in view.\n    // * Right side greater than window width.\n    const spansViewport = item.width >= this.viewportWidth && !isLeftInView && !isRightInView &&\n      item.left < 0 && item.right > this.viewportWidth;\n\n    return isLeftInView || isRightInView || spansViewport;\n  }\n\n  /**\n   * If an element is hidden (has a parent with display:none), getBoundingClientRect\n   * will return all zeros\n   * @param {ViewportItem} item item Item to test.\n   * @return {boolean}\n   */\n  isVisible(item) {\n    return !(item.width === 0 && item.height === 0);\n  }\n\n  isTopPastViewport(item) {\n    return this.viewportTop > item.top;\n  }\n\n  isViewportPastBottom(item) {\n    return this.viewportTop >= item.bottom;\n  }\n\n  isTopInViewport(item) {\n    const elementTop = item.top + item.offset;\n    return inRange(elementTop, this.viewportTop, this.viewportBottom);\n  }\n\n  isBottomInViewport(item) {\n    // Account for threshold only from the element top. Otherwise the element\n    // won't be \"out of view\" from the bottom until after the extra threshold.\n    return inRange(item.bottom, this.viewportTop, this.viewportBottom);\n  }\n\n  doesSpanViewport(item) {\n    const elementTop = item.top + item.offset;\n    const elementBottom = item.bottom;\n    return item.height >= this.viewportHeight &&\n      elementTop < this.viewportTop && elementBottom > this.viewportBottom;\n  }\n\n  /**\n   * Remove all viewport items and unbind events.\n   */\n  static flush() {\n    const instance = Viewport.getInstance();\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n      instance.addId = null;\n    }\n\n    instance.items.forEach((item, id) => {\n      Viewport.remove(id);\n    });\n\n    instance.items.clear();\n    instance.unbindEvents();\n  }\n\n  /**\n   * Add a viewport item to watch.\n   * @param {object|object[]} options Optional options object or array of\n   *     options objects to initialize.\n   * @param {Element} options.element Element to watch.\n   * @param {number|string} [options.threshold] Optional - either a number representing\n   *     the threshold offset (like 100), a float between zero and one representing\n   *     a percentage, or a string like '50%' for a percentage.\n   * @param {function} options.enter Callback when the element enters view.\n   * @param {function} [options.exit] Optional callback when the element exits view.\n   * @return {string|string[]} Viewport item id or array of item ids if\n   *     `options` is an array.\n   */\n  static add(options) {\n    const instance = Viewport.getInstance();\n\n    let id;\n    if (Array.isArray(options)) {\n      id = options.map(option => instance.add(option));\n    } else {\n      id = instance.add(options);\n    }\n\n    // Avoid adding multiple rAFs when it should really only be processed once.\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n    }\n\n    instance.addId = requestAnimationFrame(instance.process.bind(instance));\n\n    return id;\n  }\n\n  /**\n   * Remove a viewport item from the list of viewport items to watch.\n   * @param {string} id The id returned from adding the viewport item.\n   */\n  static remove(id) {\n    const instance = Viewport.getInstance();\n    if (instance.items.has(id)) {\n      instance.items.get(id).dispose();\n      instance.items.delete(id);\n    }\n  }\n\n  /**\n   * Tell the viewport instance that offsets need to be updated.\n   */\n  static update() {\n    Viewport.getInstance().update();\n  }\n\n  /**\n   * Retrieve the viewport instance.\n   * @return {Viewport}\n   */\n  static getInstance() {\n    if (!instance) {\n      instance = new Viewport();\n    }\n\n    return instance;\n  }\n}\n\nexport default Viewport;\n"],"names":["ViewportItem","options","parent","id","Math","random","toString","substring","triggered","threshold","isThresholdPercentage","Object","assign","enter","TypeError","parseThreshold","hasExitCallback","exit","update","box","element","getBoundingClientRect","height","offsetHeight","width","offsetWidth","top","window","pageYOffset","left","pageXOffset","right","bottom","value","parseFloat","indexOf","dispose","viewportHeight","instance","inRange","min","max","Viewport","addId","hasActiveHandlers","items","Map","innerHeight","viewportWidth","document","documentElement","clientWidth","viewportTop","requestAnimationFrame","handleScroll","bind","bindEvents","resizeId","OdoWindowEvents","onResize","scrollId","onFastScroll","unbindEvents","size","remove","add","item","set","saveDimensions","forEach","setScrollTop","process","triggerEnter","call","triggerExit","_processItem","isVisible","isInView","isInViewport","isTopPastView","isTopPastViewport","isBottomInViewport","isTopInView","isTopInViewport","isBottomInView","offset","isViewPastBottom","isViewportPastBottom","spanningViewport","doesSpanViewport","isSideInView","isSideInViewport","isLeftInView","isRightInView","spansViewport","elementTop","viewportBottom","elementBottom","flush","getInstance","cancelAnimationFrame","clear","Array","isArray","map","option","has","get","delete"],"mappings":"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"}