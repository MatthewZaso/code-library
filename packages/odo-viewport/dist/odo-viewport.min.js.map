{"version":3,"file":"odo-viewport.min.js","sources":["../src/viewport.js","../src/viewport-item.js"],"sourcesContent":["import OdoWindowEvents from '@odopod/odo-window-events';\nimport ViewportItem from './viewport-item';\n\nlet instance = null;\n\nfunction inRange(value, min, max) {\n  return min <= value && value <= max;\n}\n\nclass Viewport {\n  /**\n   * Viewport singleton.\n   * @constructor\n   */\n  constructor() {\n    this.addId = null;\n    this.hasActiveHandlers = false;\n    this.items = new Map();\n\n    // Assume there is no horizontal scrollbar. documentElement.clientHeight\n    // is incorrect on iOS 8 because it includes toolbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n    this.viewportTop = 0;\n\n    // What's nice here is that rAF won't execute until the user is on this tab,\n    // so if they open the page in a new tab which they aren't looking at,\n    // this will execute when they come back to that tab.\n    requestAnimationFrame(this.handleScroll.bind(this));\n  }\n\n  get viewportBottom() {\n    return this.viewportTop + this.viewportHeight;\n  }\n\n  /**\n   * Listen for scroll and resize.\n   */\n  bindEvents() {\n    // Listen for global debounced resize.\n    this.resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n\n    // Throttle scrolling because it doesn't need to be super accurate.\n    this.scrollId = OdoWindowEvents.onFastScroll(this.handleScroll.bind(this));\n\n    this.hasActiveHandlers = true;\n  }\n\n  /**\n   * Remove event listeners when there are no longer any viewport items to watch.\n   */\n  unbindEvents() {\n    if (this.items.size === 0) {\n      OdoWindowEvents.remove(this.resizeId);\n      OdoWindowEvents.remove(this.scrollId);\n\n      this.hasActiveHandlers = false;\n    }\n  }\n\n  /**\n   * Watch another item.\n   * @param {Object} options Viewport item options.\n   * @return {string} The new item's id which is used to remove it.\n   */\n  add(options) {\n    const item = new ViewportItem(options, this);\n    this.items.set(item.id, item);\n\n    // Event handlers are removed if a callback is triggered and the\n    // watch list is empty. Because modules are instantiated asynchronously,\n    // another module could potentially add itself to the watch list when the events\n    // have been unbound.\n    // Check here if events have been unbound and bind them again if they have\n    if (!this.hasActiveHandlers) {\n      this.bindEvents();\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Update each item's width/height/top/left values and the viewport size.\n   */\n  saveDimensions() {\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    // Window width and height without scrollbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n\n    return this;\n  }\n\n  /**\n   * Throttled scroll event. Update the viewport top position and process items.\n   */\n  handleScroll() {\n    return this.setScrollTop().process();\n  }\n\n  /**\n   * Update offsets and process items.\n   */\n  update() {\n    return this.saveDimensions().process();\n  }\n\n  /**\n   * Notify the viewport item it has entered view.\n   * @param {ViewportItem} item item.\n   */\n  triggerEnter(item) {\n    item.enter.call(item.element, item);\n\n    if (item.hasExitCallback) {\n      item.triggered = true;\n\n      // If the exit property is not a function, the module no longer needs to\n      // watch it, so remove from list of viewport items.\n    } else {\n      Viewport.remove(item.id);\n\n      // If there are no more, unbind from scroll and resize events\n      this.unbindEvents();\n    }\n  }\n\n  /**\n   * Notify the viewport item it has exited view.\n   * @param {ViewportItem} item item.\n   */\n  triggerExit(item) {\n    item.exit.call(item.element, item);\n    item.triggered = false;\n  }\n\n  /**\n   * Save the new scroll top\n   */\n  setScrollTop() {\n    this.viewportTop = window.pageYOffset;\n    return this;\n  }\n\n  /**\n   * Process each viewport item to see if it is now in view (or out of view).\n   */\n  process() {\n    this.items.forEach(this._processItem, this);\n    this.addId = null;\n\n    return this;\n  }\n\n  /**\n   * Determine if enter or exit callbacks should be executed for a viewport item.\n   * @param {ViewportItem} item Item to test.\n   */\n  _processItem(item) {\n    const isVisible = this.isVisible(item);\n    const isInView = isVisible && this.isInViewport(item);\n\n    // Whether the item is not in the viewport and doesn't have an exit\n    // callback. In this case, the enter callback should be executed\n    // because the browser has already scrolled past the trigger point.\n    const isTopPastView = isVisible && !item.hasExitCallback && this.isTopPastViewport(item);\n\n    // If the enter callback hasn't been triggered and it's in the viewport,\n    // trigger the enter callback.\n    if (!item.triggered && (isInView || isTopPastView)) {\n      this.triggerEnter(item);\n      return;\n    }\n\n    // This viewport has already come into view once (viewport item has been\n    // triggered) and now the bottom is out of view.\n    if (!isInView && item.triggered && item.hasExitCallback &&\n      !this.isBottomInViewport(item)) {\n      this.triggerExit(item);\n    }\n  }\n\n  /**\n   * Whether a viewport item is considered to be in view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isInViewport(item) {\n    const isTopInView = this.isTopInViewport(item);\n\n    // If the item has not come into view, ignore checking to see if the bottom\n    // is in view because this can conflict with the top being in view when the\n    // offset is greater than the height of the watched element.\n    let isBottomInView;\n    if (item.offset >= 0) {\n      if (item.triggered) {\n        isBottomInView = this.isBottomInViewport(item);\n      } else {\n        isBottomInView = false;\n      }\n    } else {\n      // If the offset is negative, assume that it shouldn't wait until the top\n      // is in view before checking the bottom again.\n      isBottomInView = this.isBottomInViewport(item);\n    }\n\n    const isViewPastBottom = this.isViewportPastBottom(item);\n    const spanningViewport = !isTopInView && !isBottomInView && this.doesSpanViewport(item);\n\n    const isSideInView = this.isSideInViewport(item);\n\n    return (isTopInView || isBottomInView || spanningViewport) && !isViewPastBottom && isSideInView;\n  }\n\n  /**\n   * Determine whether a side of the viewport item is within the viewport. A side\n   * is also considered to be in view if the viewport item is wider than the viewport\n   * and its left and right sides are out of view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isSideInViewport(item) {\n    const isLeftInView = inRange(item.left, 0, this.viewportWidth);\n    const isRightInView = inRange(item.right, 0, this.viewportWidth);\n\n    // To span the viewport, it must:\n    // * Wider than the viewport.\n    // * Left side not in view.\n    // * left side less than zero.\n    // * Right side not in view.\n    // * Right side greater than window width.\n    const spansViewport = item.width >= this.viewportWidth && !isLeftInView && !isRightInView &&\n      item.left < 0 && item.right > this.viewportWidth;\n\n    return isLeftInView || isRightInView || spansViewport;\n  }\n\n  /**\n   * If an element is hidden (has a parent with display:none), getBoundingClientRect\n   * will return all zeros\n   * @param {ViewportItem} item item Item to test.\n   * @return {boolean}\n   */\n  isVisible(item) {\n    return !(item.width === 0 && item.height === 0);\n  }\n\n  isTopPastViewport(item) {\n    return this.viewportTop > item.top;\n  }\n\n  isViewportPastBottom(item) {\n    return this.viewportTop >= item.bottom;\n  }\n\n  isTopInViewport(item) {\n    const elementTop = item.top + item.offset;\n    return inRange(elementTop, this.viewportTop, this.viewportBottom);\n  }\n\n  isBottomInViewport(item) {\n    // Account for threshold only from the element top. Otherwise the element\n    // won't be \"out of view\" from the bottom until after the extra threshold.\n    return inRange(item.bottom, this.viewportTop, this.viewportBottom);\n  }\n\n  doesSpanViewport(item) {\n    const elementTop = item.top + item.offset;\n    const elementBottom = item.bottom;\n    return item.height >= this.viewportHeight &&\n      elementTop < this.viewportTop && elementBottom > this.viewportBottom;\n  }\n\n  /**\n   * Remove all viewport items and unbind events.\n   */\n  static flush() {\n    const instance = Viewport.getInstance();\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n      instance.addId = null;\n    }\n\n    instance.items.forEach((item, id) => {\n      Viewport.remove(id);\n    });\n\n    instance.items.clear();\n    instance.unbindEvents();\n  }\n\n  /**\n   * Add a viewport item to watch.\n   * @param {Object|Array.<Object>} options Optional options object or array of\n   *     options objects to initialize.\n   * @param {Element} options.element Element to watch.\n   * @param {number|string} [options.threshold] Optional - either a number representing\n   *     the threshold offset (like 100), a float between zero and one representing\n   *     a percentage, or a string like '50%' for a percentage.\n   * @param {function} options.enter Callback when the element enters view.\n   * @param {function} [options.exit] Optional callback when the element exits view.\n   * @return {string|Array.<string>} Viewport item id or array of item ids if\n   *     `options` is an array.\n   */\n  static add(options) {\n    const instance = Viewport.getInstance();\n\n    let id;\n    if (Array.isArray(options)) {\n      id = options.map(option => instance.add(option));\n    } else {\n      id = instance.add(options);\n    }\n\n    // Avoid adding multiple rAFs when it should really only be processed once.\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n    }\n\n    instance.addId = requestAnimationFrame(instance.process.bind(instance));\n\n    return id;\n  }\n\n  /**\n   * Remove a viewport item from the list of viewport items to watch.\n   * @param {string} id The id returned from adding the viewport item.\n   */\n  static remove(id) {\n    const instance = Viewport.getInstance();\n    if (instance.items.has(id)) {\n      instance.items.get(id).dispose();\n      instance.items.delete(id);\n    }\n  }\n\n  /**\n   * Tell the viewport instance that offsets need to be updated.\n   */\n  static update() {\n    Viewport.getInstance().update();\n  }\n\n  /**\n   * Retrieve the viewport instance.\n   * @return {Viewport}\n   */\n  static getInstance() {\n    if (!instance) {\n      instance = new Viewport();\n    }\n\n    return instance;\n  }\n}\n\nexport default Viewport;\n","class ViewportItem {\n  /**\n   * A viewport item represents an element being watched by the Viewport component.\n   * @param {Object} options Viewport item options.\n   * @param {Viewport} parent A reference to the viewport.\n   * @constructor\n   */\n  constructor(options, parent) {\n    this.parent = parent;\n    this.id = Math.random().toString(36).substring(7);\n    this.triggered = false;\n    this.threshold = 200;\n    this.isThresholdPercentage = false;\n\n    // Override defaults with options.\n    Object.assign(this, options);\n\n    // The whole point is to have a callback function. Don't do anything if it's not given.\n    if (typeof this.enter !== 'function') {\n      throw new TypeError('Viewport.add :: No `enter` function provided in Viewport options.');\n    }\n\n    this.parseThreshold();\n\n    this.hasExitCallback = typeof this.exit === 'function';\n\n    // Cache element's offsets and dimensions.\n    this.update();\n  }\n\n  // Use getter for `this.offset` so that the tests don't have to assign\n  // a threshold and an offset.\n  get offset() {\n    return this.isThresholdPercentage ?\n      this.threshold * this.parent.viewportHeight :\n      this.threshold;\n  }\n\n  /**\n   * Update offset and size values.\n   */\n  update() {\n    const box = this.element.getBoundingClientRect();\n    this.height = this.element.offsetHeight;\n    this.width = this.element.offsetWidth;\n    this.top = box.top + window.pageYOffset;\n    this.left = box.left + window.pageXOffset;\n    this.right = this.width + this.left;\n    this.bottom = this.height + this.top;\n  }\n\n  /**\n   * Determine the threshold setting.\n   */\n  parseThreshold() {\n    const value = this.threshold;\n    this.threshold = parseFloat(value);\n\n    // Threshold can be a percentage. Parse it.\n    if ((typeof value === 'string' && value.indexOf('%') > -1)) {\n      this.isThresholdPercentage = true;\n      this.threshold = this.threshold / 100;\n    } else if (this.threshold < 1 && this.threshold > 0) {\n      this.isThresholdPercentage = true;\n    }\n  }\n\n  /**\n   * Nullify references so they're garbage collected.\n   */\n  dispose() {\n    this.element = null;\n    this.enter = null;\n    this.exit = null;\n    this.parent = null;\n  }\n}\n\nexport default ViewportItem;\n"],"names":["inRange","value","min","max","ViewportItem","options","parent","id","Math","random","toString","substring","triggered","threshold","isThresholdPercentage","assign","this","enter","TypeError","parseThreshold","hasExitCallback","exit","update","box","element","getBoundingClientRect","height","offsetHeight","width","offsetWidth","top","window","pageYOffset","left","pageXOffset","right","bottom","parseFloat","indexOf","dispose","viewportHeight","instance","addId","hasActiveHandlers","items","Map","innerHeight","viewportWidth","document","documentElement","clientWidth","viewportTop","handleScroll","bind","bindEvents","resizeId","OdoWindowEvents","onResize","scrollId","onFastScroll","unbindEvents","size","remove","add","item","set","saveDimensions","forEach","setScrollTop","process","triggerEnter","call","triggerExit","_processItem","isVisible","isInView","isInViewport","isTopPastView","isTopPastViewport","isBottomInViewport","isTopInView","isTopInViewport","isBottomInView","offset","isViewPastBottom","isViewportPastBottom","spanningViewport","doesSpanViewport","isSideInView","isSideInViewport","isLeftInView","isRightInView","spansViewport","viewportBottom","elementTop","elementBottom","flush","Viewport","getInstance","clear","Array","isArray","map","option","requestAnimationFrame","has","get","delete"],"mappings":"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"}