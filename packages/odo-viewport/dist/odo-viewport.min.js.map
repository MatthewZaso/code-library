{"version":3,"file":"odo-viewport.min.js","sources":["../src/viewport-item.js","../src/viewport.js"],"sourcesContent":["class ViewportItem {\n  /**\n   * A viewport item represents an element being watched by the Viewport component.\n   * @param {Object} options Viewport item options.\n   * @param {Viewport} parent A reference to the viewport.\n   * @constructor\n   */\n  constructor(options, parent) {\n    this.parent = parent;\n    this.id = Math.random().toString(36).substring(7);\n    this.triggered = false;\n    this.threshold = 200;\n    this.isThresholdPercentage = false;\n\n    // Override defaults with options.\n    Object.assign(this, options);\n\n    // The whole point is to have a callback function. Don't do anything if it's not given.\n    if (typeof this.enter !== 'function') {\n      throw new TypeError('Viewport.add :: No `enter` function provided in Viewport options.');\n    }\n\n    this.parseThreshold();\n\n    this.hasExitCallback = typeof this.exit === 'function';\n\n    // Cache element's offsets and dimensions.\n    this.update();\n  }\n\n  // Use getter for `this.offset` so that the tests don't have to assign\n  // a threshold and an offset.\n  get offset() {\n    return this.isThresholdPercentage ?\n      this.threshold * this.parent.viewportHeight :\n      this.threshold;\n  }\n\n  /**\n   * Update offset and size values.\n   */\n  update() {\n    const box = this.element.getBoundingClientRect();\n    this.height = this.element.offsetHeight;\n    this.width = this.element.offsetWidth;\n    this.top = box.top + window.pageYOffset;\n    this.left = box.left + window.pageXOffset;\n    this.right = this.width + this.left;\n    this.bottom = this.height + this.top;\n  }\n\n  /**\n   * Determine the threshold setting.\n   */\n  parseThreshold() {\n    const value = this.threshold;\n    this.threshold = parseFloat(value);\n\n    // Threshold can be a percentage. Parse it.\n    if ((typeof value === 'string' && value.indexOf('%') > -1)) {\n      this.isThresholdPercentage = true;\n      this.threshold = this.threshold / 100;\n    } else if (this.threshold < 1 && this.threshold > 0) {\n      this.isThresholdPercentage = true;\n    }\n  }\n\n  /**\n   * Nullify references so they're garbage collected.\n   */\n  dispose() {\n    this.element = null;\n    this.enter = null;\n    this.exit = null;\n    this.parent = null;\n  }\n}\n\nexport default ViewportItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport ViewportItem from './viewport-item';\n\nlet instance = null;\n\nfunction inRange(value, min, max) {\n  return min <= value && value <= max;\n}\n\nclass Viewport {\n  /**\n   * Viewport singleton.\n   * @constructor\n   */\n  constructor() {\n    this.addId = null;\n    this.hasActiveHandlers = false;\n    this.items = new Map();\n\n    // Assume there is no horizontal scrollbar. documentElement.clientHeight\n    // is incorrect on iOS 8 because it includes toolbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n    this.viewportTop = 0;\n\n    // What's nice here is that rAF won't execute until the user is on this tab,\n    // so if they open the page in a new tab which they aren't looking at,\n    // this will execute when they come back to that tab.\n    requestAnimationFrame(this.handleScroll.bind(this));\n  }\n\n  get viewportBottom() {\n    return this.viewportTop + this.viewportHeight;\n  }\n\n  /**\n   * Listen for scroll and resize.\n   */\n  bindEvents() {\n    // Listen for global debounced resize.\n    this.resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n\n    // Throttle scrolling because it doesn't need to be super accurate.\n    this.scrollId = OdoWindowEvents.onFastScroll(this.handleScroll.bind(this));\n\n    this.hasActiveHandlers = true;\n  }\n\n  /**\n   * Remove event listeners when there are no longer any viewport items to watch.\n   */\n  unbindEvents() {\n    if (this.items.size === 0) {\n      OdoWindowEvents.remove(this.resizeId);\n      OdoWindowEvents.remove(this.scrollId);\n\n      this.hasActiveHandlers = false;\n    }\n  }\n\n  /**\n   * Watch another item.\n   * @param {Object} options Viewport item options.\n   * @return {string} The new item's id which is used to remove it.\n   */\n  add(options) {\n    const item = new ViewportItem(options, this);\n    this.items.set(item.id, item);\n\n    // Event handlers are removed if a callback is triggered and the\n    // watch list is empty. Because modules are instantiated asynchronously,\n    // another module could potentially add itself to the watch list when the events\n    // have been unbound.\n    // Check here if events have been unbound and bind them again if they have\n    if (!this.hasActiveHandlers) {\n      this.bindEvents();\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Update each item's width/height/top/left values and the viewport size.\n   */\n  saveDimensions() {\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    // Window width and height without scrollbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n\n    return this;\n  }\n\n  /**\n   * Throttled scroll event. Update the viewport top position and process items.\n   */\n  handleScroll() {\n    return this.setScrollTop().process();\n  }\n\n  /**\n   * Update offsets and process items.\n   */\n  update() {\n    return this.saveDimensions().process();\n  }\n\n  /**\n   * Notify the viewport item it has entered view.\n   * @param {ViewportItem} item item.\n   */\n  triggerEnter(item) {\n    item.enter.call(item.element, item);\n\n    if (item.hasExitCallback) {\n      item.triggered = true;\n\n      // If the exit property is not a function, the module no longer needs to\n      // watch it, so remove from list of viewport items.\n    } else {\n      Viewport.remove(item.id);\n\n      // If there are no more, unbind from scroll and resize events\n      this.unbindEvents();\n    }\n  }\n\n  /**\n   * Notify the viewport item it has exited view.\n   * @param {ViewportItem} item item.\n   */\n  triggerExit(item) {\n    item.exit.call(item.element, item);\n    item.triggered = false;\n  }\n\n  /**\n   * Save the new scroll top\n   */\n  setScrollTop() {\n    this.viewportTop = window.pageYOffset;\n    return this;\n  }\n\n  /**\n   * Process each viewport item to see if it is now in view (or out of view).\n   */\n  process() {\n    this.items.forEach(this._processItem, this);\n    this.addId = null;\n\n    return this;\n  }\n\n  /**\n   * Determine if enter or exit callbacks should be executed for a viewport item.\n   * @param {ViewportItem} item Item to test.\n   */\n  _processItem(item) {\n    const isVisible = this.isVisible(item);\n    const isInView = isVisible && this.isInViewport(item);\n\n    // Whether the item is not in the viewport and doesn't have an exit\n    // callback. In this case, the enter callback should be executed\n    // because the browser has already scrolled past the trigger point.\n    const isTopPastView = isVisible && !item.hasExitCallback && this.isTopPastViewport(item);\n\n    // If the enter callback hasn't been triggered and it's in the viewport,\n    // trigger the enter callback.\n    if (!item.triggered && (isInView || isTopPastView)) {\n      this.triggerEnter(item);\n      return;\n    }\n\n    // This viewport has already come into view once (viewport item has been\n    // triggered) and now the bottom is out of view.\n    if (!isInView && item.triggered && item.hasExitCallback &&\n      !this.isBottomInViewport(item)) {\n      this.triggerExit(item);\n    }\n  }\n\n  /**\n   * Whether a viewport item is considered to be in view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isInViewport(item) {\n    const isTopInView = this.isTopInViewport(item);\n\n    // If the item has not come into view, ignore checking to see if the bottom\n    // is in view because this can conflict with the top being in view when the\n    // offset is greater than the height of the watched element.\n    let isBottomInView;\n    if (item.offset >= 0) {\n      if (item.triggered) {\n        isBottomInView = this.isBottomInViewport(item);\n      } else {\n        isBottomInView = false;\n      }\n    } else {\n      // If the offset is negative, assume that it shouldn't wait until the top\n      // is in view before checking the bottom again.\n      isBottomInView = this.isBottomInViewport(item);\n    }\n\n    const isViewPastBottom = this.isViewportPastBottom(item);\n    const spanningViewport = !isTopInView && !isBottomInView && this.doesSpanViewport(item);\n\n    const isSideInView = this.isSideInViewport(item);\n\n    return (isTopInView || isBottomInView || spanningViewport) && !isViewPastBottom && isSideInView;\n  }\n\n  /**\n   * Determine whether a side of the viewport item is within the viewport. A side\n   * is also considered to be in view if the viewport item is wider than the viewport\n   * and its left and right sides are out of view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isSideInViewport(item) {\n    const isLeftInView = inRange(item.left, 0, this.viewportWidth);\n    const isRightInView = inRange(item.right, 0, this.viewportWidth);\n\n    // To span the viewport, it must:\n    // * Wider than the viewport.\n    // * Left side not in view.\n    // * left side less than zero.\n    // * Right side not in view.\n    // * Right side greater than window width.\n    const spansViewport = item.width >= this.viewportWidth && !isLeftInView && !isRightInView &&\n      item.left < 0 && item.right > this.viewportWidth;\n\n    return isLeftInView || isRightInView || spansViewport;\n  }\n\n  /**\n   * If an element is hidden (has a parent with display:none), getBoundingClientRect\n   * will return all zeros\n   * @param {ViewportItem} item item Item to test.\n   * @return {boolean}\n   */\n  isVisible(item) {\n    return !(item.width === 0 && item.height === 0);\n  }\n\n  isTopPastViewport(item) {\n    return this.viewportTop > item.top;\n  }\n\n  isViewportPastBottom(item) {\n    return this.viewportTop >= item.bottom;\n  }\n\n  isTopInViewport(item) {\n    const elementTop = item.top + item.offset;\n    return inRange(elementTop, this.viewportTop, this.viewportBottom);\n  }\n\n  isBottomInViewport(item) {\n    // Account for threshold only from the element top. Otherwise the element\n    // won't be \"out of view\" from the bottom until after the extra threshold.\n    return inRange(item.bottom, this.viewportTop, this.viewportBottom);\n  }\n\n  doesSpanViewport(item) {\n    const elementTop = item.top + item.offset;\n    const elementBottom = item.bottom;\n    return item.height >= this.viewportHeight &&\n      elementTop < this.viewportTop && elementBottom > this.viewportBottom;\n  }\n\n  /**\n   * Remove all viewport items and unbind events.\n   */\n  static flush() {\n    const instance = Viewport.getInstance();\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n      instance.addId = null;\n    }\n\n    instance.items.forEach((item, id) => {\n      Viewport.remove(id);\n    });\n\n    instance.items.clear();\n    instance.unbindEvents();\n  }\n\n  /**\n   * Add a viewport item to watch.\n   * @param {object|object[]} options Optional options object or array of\n   *     options objects to initialize.\n   * @param {Element} options.element Element to watch.\n   * @param {number|string} [options.threshold] Optional - either a number representing\n   *     the threshold offset (like 100), a float between zero and one representing\n   *     a percentage, or a string like '50%' for a percentage.\n   * @param {function} options.enter Callback when the element enters view.\n   * @param {function} [options.exit] Optional callback when the element exits view.\n   * @return {string|string[]} Viewport item id or array of item ids if\n   *     `options` is an array.\n   */\n  static add(options) {\n    const instance = Viewport.getInstance();\n\n    let id;\n    if (Array.isArray(options)) {\n      id = options.map(option => instance.add(option));\n    } else {\n      id = instance.add(options);\n    }\n\n    // Avoid adding multiple rAFs when it should really only be processed once.\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n    }\n\n    instance.addId = requestAnimationFrame(instance.process.bind(instance));\n\n    return id;\n  }\n\n  /**\n   * Remove a viewport item from the list of viewport items to watch.\n   * @param {string} id The id returned from adding the viewport item.\n   */\n  static remove(id) {\n    const instance = Viewport.getInstance();\n    if (instance.items.has(id)) {\n      instance.items.get(id).dispose();\n      instance.items.delete(id);\n    }\n  }\n\n  /**\n   * Tell the viewport instance that offsets need to be updated.\n   */\n  static update() {\n    Viewport.getInstance().update();\n  }\n\n  /**\n   * Retrieve the viewport instance.\n   * @return {Viewport}\n   */\n  static getInstance() {\n    if (!instance) {\n      instance = new Viewport();\n    }\n\n    return instance;\n  }\n}\n\nexport default Viewport;\n"],"names":["ViewportItem","options","parent","id","Math","random","toString","substring","triggered","threshold","isThresholdPercentage","assign","this","enter","TypeError","parseThreshold","hasExitCallback","exit","update","box","element","getBoundingClientRect","height","offsetHeight","width","offsetWidth","top","window","pageYOffset","left","pageXOffset","right","bottom","value","parseFloat","indexOf","dispose","viewportHeight","instance","inRange","min","max","addId","hasActiveHandlers","items","Map","innerHeight","viewportWidth","document","documentElement","clientWidth","viewportTop","handleScroll","bind","bindEvents","resizeId","OdoWindowEvents","onResize","scrollId","onFastScroll","unbindEvents","size","remove","add","item","set","saveDimensions","forEach","setScrollTop","process","triggerEnter","call","triggerExit","_processItem","isVisible","isInView","isInViewport","isTopPastView","isTopPastViewport","isBottomInViewport","isTopInView","isTopInViewport","isBottomInView","offset","isViewPastBottom","isViewportPastBottom","spanningViewport","doesSpanViewport","isSideInView","isSideInViewport","isLeftInView","isRightInView","spansViewport","viewportBottom","elementTop","elementBottom","flush","Viewport","getInstance","clear","Array","isArray","map","option","requestAnimationFrame","has","get","delete"],"mappings":"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"}