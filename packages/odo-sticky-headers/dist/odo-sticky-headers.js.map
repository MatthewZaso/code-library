{"version":3,"file":"odo-sticky-headers.js","sources":["../src/sticky-item.js","../src/sticky-headers.js"],"sourcesContent":["/**\n * @fileoverview This class describes a sticky header element. It caches the\n * offsets for the element and has methods to stick, affix, and unstick the\n * sticky element.\n */\n\nfunction applyCss(element, css) {\n  Object.keys(css).forEach((property) => {\n    element.style[property] = css[property];\n  });\n}\n\nclass StickyItem {\n  /**\n   * Create a new sticky item.\n   * @param {Element} element Element to stick.\n   * @constructor\n   */\n  constructor(element) {\n    /**\n     * Main sticky element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the element is position:fixed.\n     * @type {boolean}\n     */\n    this.isFixed = false;\n\n    /**\n     * Whether the element is affixed to the bottom.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the element is layer promoted.\n     * @type {boolean}\n     */\n    this.isPromoted = false;\n\n    this._wrapStickyElement();\n    this.update();\n  }\n\n  /**\n   * Initialize by wrapping in an element to take up space while the main\n   * element is positin:fixed.\n   * @private\n   */\n  _wrapStickyElement() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = StickyItem.Classes.WRAPPER;\n    this.element.parentNode.insertBefore(this.wrapper, this.element);\n\n    applyCss(this.element, {\n      position: StickyItem.INITIAL_POSITION,\n      zIndex: 1,\n      top: 0,\n      left: 0,\n      width: '100%',\n      overflow: 'hidden',\n    });\n\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.wrapper.appendChild(this.element);\n  }\n\n  /**\n   * Remove the placeholder element added when this sticky item is initialized.\n   * @private\n   */\n  _unwrapStickyElement() {\n    const container = this.wrapper.parentNode;\n    container.appendChild(this.element);\n    container.removeChild(this.wrapper);\n  }\n\n  /**\n   * Save the dimensions of the sticky item.\n   */\n  update() {\n    const rect = this.element.getBoundingClientRect();\n    this.top = rect.top + window.pageYOffset;\n    this.height = Math.round(rect.height);\n  }\n\n  /**\n   * Stick the sticky item to a specific value.\n   * @param {number} stackHeight The current stack height of sticky elements.\n   * @param {Element} [parent] Optional element to put the sticky within.\n   */\n  stick(stackHeight, parent) {\n    this.wrapper.style.height = this.height + 'px';\n    this.element.style.position = 'fixed';\n    this.element.style.top = stackHeight + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    if (parent) {\n      parent.appendChild(this.element);\n    }\n\n    this.isAtBottom = false;\n    this.isFixed = true;\n  }\n\n  /**\n   * Remove stickiness of sticky item.\n   */\n  unstick() {\n    this.wrapper.style.height = '';\n    this.element.style.position = StickyItem.INITIAL_POSITION;\n    this.element.style.top = '';\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n\n    if (this.element.parentNode !== this.wrapper) {\n      this.wrapper.appendChild(this.element);\n    }\n\n    this.isFixed = false;\n    this.isAtBottom = false;\n  }\n\n  stickToBottom(placement) {\n    this.element.style.position = 'absolute';\n    this.element.style.top = placement + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    // When the sticky is position absolute, it has to be absolute relative\n    // to the page, not another fixed-position element.\n    document.body.appendChild(this.element);\n\n    this.isFixed = false;\n    this.isAtBottom = true;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Get rid of this sticky item instance.\n   */\n  dispose() {\n    this.unstick();\n    this._unwrapStickyElement();\n\n    applyCss(this.element, {\n      position: '',\n      zIndex: '',\n      top: '',\n      left: '',\n      width: '',\n      overflow: '',\n      willChange: '',\n      transform: '',\n    });\n\n    this.element = null;\n    this.wrapper = null;\n  }\n}\n\nStickyItem.INITIAL_POSITION = 'relative';\n\nStickyItem.Classes = {\n  BASE: 'odo-sticky-headers__item',\n  WRAPPER: 'odo-sticky-headers__item-wrapper',\n  IS_FIXED: 'is-fixed',\n  IS_AT_TOP: 'is-at-top',\n  IS_AT_BOTTOM: 'is-at-bottom',\n};\n\nexport default StickyItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\nimport StickyItem from './sticky-item';\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nfunction withinRange(value, min, max, threshold) {\n  return value >= min - threshold && value <= max + threshold;\n}\n\nclass StickyHeaders {\n  /**\n   * Create a new Sticky instance.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Mapping of elements to StickyItem instances.\n     * @type {Map.<Element, StickyItem>}\n     */\n    this.items = new Map();\n\n    /**\n     * Items sorted in order they appear on the page.\n     * @type {Array}\n     */\n    this._orderedItems = [];\n\n    /**\n     * Scroll event listener id.\n     * @type {?string}\n     */\n    this._scrollId = null;\n\n    /**\n     * Window resize id.\n     * @type {?string}\n     * @private\n     */\n    this._resizeId = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Where to start positioning new sticky items.\n     * @type {number}\n     * @private\n     */\n    this._startingOffset = 0;\n\n    /**\n     * Element which holds sticky elements.\n     * @type {Element}\n     * @private\n     */\n    this._holder = null;\n\n    /**\n     * Custom overlap getter. Can be overridden by setting `uiOverlap`.\n     * @type {?function}\n     * @private\n     */\n    this._customOverlap = null;\n\n    /**\n     * Custom offset getter. Can be overridden by setting `uiOffset`.\n     * @type {?function}\n     * @private\n     */\n    this._customOffset = null;\n\n    /**\n     * Which mode to handle sticky headers.\n     * @type {StickyHeaders.Mode}\n     * @private\n     */\n    this._mode = StickyHeaders.Mode.PUSH;\n  }\n\n  /**\n   * Track a sticky item.\n   * @param {Element[]|Element} element An array of elements or a single\n   *    element which will become sticky.\n   * @return {Element} The key to the items map for this new StickyItem.\n   */\n  add(element) {\n    const elements = Array.isArray(element) ? element : [element];\n\n    elements.forEach((element) => {\n      if (!isElement(element)) {\n        throw new TypeError(`StickyHeaders requires an element. Got: \"${element}\"`);\n      }\n\n      // Avoid adding duplicate items.\n      if (!this.items.has(element)) {\n        this.items.set(element, new StickyItem(element));\n      }\n    });\n\n    // Add event listeners if they aren't already added.\n    if (this._scrollId) {\n      this._cacheItemValues();\n    } else {\n      this._resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n      this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n      this._cacheStyles();\n    }\n\n    this.process();\n\n    return element;\n  }\n\n  /**\n   * Stop tracking a sticky item.\n   * @param {Element} element Element which was added to the sticky headers.\n   */\n  remove(element) {\n    if (this.items.has(element)) {\n      this.items.get(element).dispose();\n      this.items.delete(element);\n\n      // Remove event listeners when there aren't any instances to watch.\n      if (this.items.size === 0) {\n        OdoScrollAnimation.remove(this._scrollId);\n        OdoWindowEvents.remove(this._resizeId);\n        this._scrollId = null;\n        this._resizeId = null;\n      }\n    }\n  }\n\n  /**\n   * On every scroll event, push or stack sticky headers, depending on the mode.\n   * @param {number} scrollTop Page scroll position.\n   */\n  process(scrollTop = window.pageYOffset) {\n    if (this.mode === StickyHeaders.Mode.STACK) {\n      this._processStack(scrollTop);\n    } else {\n      this._processPush(scrollTop);\n    }\n  }\n\n  /**\n   * Depending on the position of the viewport, make sticky headers position\n   * fixed. If multiple sticky headers are \"fixed\", they will stack on each other.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processStack(scrollTop) {\n    this._orderedItems.forEach((item) => {\n      // Because the stack height can change inside the loop, it must be updated.\n      const stackHeight = this._getStackHeight();\n      const top = scrollTop + this._overlap + stackHeight;\n\n      if (!item.isFixed && top >= item.top) {\n        item.stick(this._startingOffset + stackHeight, this._holder);\n      } else if (item.isFixed && top < item.top + item.height) {\n        item.unstick();\n      }\n    });\n  }\n\n  /**\n   * Like the Contacts app on iPhone, as new headers come into view, they \"push\"\n   * out the old header and then become stuck at the top until its section has\n   * been scrolled through.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processPush(scrollTop) {\n    const top = scrollTop + this._overlap;\n\n    this._orderedItems.forEach((item) => {\n      // Stick (position fixed).\n      if (!item.isFixed && top >= item.top && top < item.bottom) {\n        item.stick(this._startingOffset, this._holder);\n\n      // Affix. Item has reached the end of its view-length, stick it to the bottom.\n      } else if (!item.isAtBottom && top >= item.bottom) {\n        item.stickToBottom(item.bottom);\n\n      // Above the position where the sticky element should be position fixed, so unstick it.\n      } else if (item.isFixed && top < item.top) {\n        item.unstick();\n      }\n\n      this._itemPositionCouldChange(item, top);\n    });\n  }\n\n  /**\n   * Sort items by their position on the page.\n   * @return {StickyItem[]} Sorted array of StickyItems.\n   */\n  _sortItemsByOffset() {\n    return Array.from(this.items.values()).sort((a, b) => a.top > b.top);\n  }\n\n  /**\n   * Add up the heights of all the currrently \"stacked\" sticky items.\n   * @return {number}\n   */\n  _getStackHeight() {\n    return this._orderedItems.reduce((h, i) => (i.isFixed ? h + i.height : h), 0);\n  }\n\n  /**\n   * When the sticky-element's position is soon going to change, promote it to a\n   * new layer so that the browser does not have to paint it on every scroll.\n   * Having the sticky-element layer promoted all the time is inefficient and greedy.\n   * @param {StickyItem} item Item to check.\n   * @param {number} top Current top position (with any overlap).\n   */\n  _itemPositionCouldChange(item, top) {\n    const isInRange = withinRange(top, item.top, item.bottom, StickyHeaders.PROMOTION_RANGE);\n    if (!item.isPromoted && isInRange) {\n      item.layerPromote();\n    } else if (item.isPromoted && !isInRange) {\n      item.layerDemote();\n    }\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   */\n  _cacheStyles() {\n    this._overlap = this.uiOverlap;\n    this._startingOffset = this.uiOffset;\n    this._cacheItemValues();\n  }\n\n  /**\n   * Cache values related to sticky items.\n   */\n  _cacheItemValues() {\n    this._orderedItems = this._sortItemsByOffset();\n\n    if (this.mode === StickyHeaders.Mode.PUSH) {\n      this._saveBottomPositionForItems();\n    }\n  }\n\n  /**\n   * Determine the page offset at which each item should become position absolute.\n   */\n  _saveBottomPositionForItems() {\n    this._orderedItems.forEach((item, i, array) => {\n      const next = array[i + 1];\n      item.bottom = (next && next.top - item.height) || StickyHeaders.LAST_ITEM_BOTTOM;\n    });\n  }\n\n  /**\n   * Re-cache element positions and reposition all sticky headers.\n   */\n  update() {\n    this.items.forEach((item) => {\n      item.unstick();\n    });\n\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    this._cacheStyles();\n\n    this.process();\n  }\n\n  /**\n   * The amount that the ui overlaps the top of the page. A sticky navigation,\n   * for example, would cause an overlap equal to its height.\n   * @return {number}\n   */\n  get uiOverlap() {\n    if (this._customOverlap) {\n      return this._customOverlap();\n    }\n\n    return 0;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._customOverlap = fn;\n    this.update();\n  }\n\n  /**\n  * Where to start positioning new sticky items. By default it's the same as\n  * the ui overlap, but can be customized.\n  * @return {number}\n  */\n  get uiOffset() {\n    if (this._customOffset) {\n      return this._customOffset();\n    }\n\n    return this.uiOverlap;\n  }\n\n  /**\n   * Define a custom getter to determine offset.\n   * @param {function():number} fn\n   */\n  set uiOffset(fn) {\n    this._customOffset = fn;\n  }\n\n  /**\n   * The location of sticky elements to be placed in the DOM.\n   * @return {?Element}\n   */\n  get stickyHolder() {\n    return this._holder;\n  }\n\n  /**\n   * Set the location of sticky elements to be placed in the DOM.\n   * @param {?Element} element Element which sticky items will be appended to.\n   */\n  set stickyHolder(element) {\n    this._holder = isElement(element) ? element : null;\n  }\n\n  /**\n   * Retrieve the current mode of StickyHeaders.\n   * @return {StickyHeaders.Mode}\n   */\n  get mode() {\n    return this._mode;\n  }\n\n  /**\n   * Change how the service treats multiple sticky items.\n   * @param {StickyHeaders.Mode} mode A mode.\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n\n  /**\n   * Remove element references and event listeners.\n   */\n  dispose() {\n    this.items.forEach((item, element) => {\n      this.remove(element);\n    });\n\n    this._orderedItems.length = 0;\n  }\n}\n\nStickyHeaders.PROMOTION_RANGE = 200;\nStickyHeaders.LAST_ITEM_BOTTOM = Infinity;\n\nStickyHeaders.Mode = {\n  PUSH: 1,\n  STACK: 2,\n};\n\nStickyHeaders.StickyItem = StickyItem;\n\nexport default StickyHeaders;\n"],"names":["applyCss","element","css","keys","forEach","property","style","StickyItem","isFixed","isAtBottom","isPromoted","_wrapStickyElement","update","wrapper","document","createElement","className","Classes","WRAPPER","parentNode","insertBefore","INITIAL_POSITION","classList","add","IS_AT_TOP","appendChild","_unwrapStickyElement","container","removeChild","rect","getBoundingClientRect","top","window","pageYOffset","height","Math","round","stick","stackHeight","parent","position","IS_FIXED","remove","IS_AT_BOTTOM","unstick","stickToBottom","placement","body","layerPromote","willChange","transform","layerDemote","dispose","isElement","thing","nodeType","withinRange","value","min","max","threshold","StickyHeaders","items","Map","_orderedItems","_scrollId","_resizeId","_overlap","_startingOffset","_holder","_customOverlap","_customOffset","_mode","Mode","PUSH","elements","Array","isArray","TypeError","has","set","_cacheItemValues","OdoWindowEvents","onResize","bind","OdoScrollAnimation","process","_cacheStyles","get","delete","size","scrollTop","mode","STACK","_processStack","_processPush","item","_getStackHeight","bottom","_itemPositionCouldChange","_sortItemsByOffset","from","values","sort","a","b","reduce","h","i","isInRange","PROMOTION_RANGE","uiOverlap","uiOffset","_saveBottomPositionForItems","array","next","LAST_ITEM_BOTTOM","length","fn","Infinity"],"mappings":"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"}