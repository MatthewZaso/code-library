{"version":3,"file":"odo-affix.min.js","sources":["../src/affix.js"],"sourcesContent":["/**\n * @fileoverview Emulates `position:sticky` to make an element fixed position\n * while its within a container. This is best for sidebars so that they follow\n * the content, without overlapping sections below it.\n */\n\nimport OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\n\nclass Affix {\n  constructor(element) {\n    /**\n     * Main element.\n     * @type {HTMLElement}\n     */\n    this.element = element;\n\n    /**\n     * Parent containing element.\n     * @type {Element}\n     */\n    this._anchor = document.getElementById(element.getAttribute('data-anchor'));\n\n    if (!this._anchor) {\n      throw new Error(`Unable to find element with id=\"${element.getAttribute('data-anchor')}\"`);\n    }\n\n    /**\n     * Whether the main element is position fixed.\n     * @type {boolean}\n     */\n    this.isStuck = false;\n\n    /**\n     * Whether the main element is stuck to the bottom of its container.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the main element has been promoted to its own layer for the GPU.\n     * @type {boolean}\n     * @protected\n     */\n    this.isPromoted = false;\n\n    /**\n     * The amount that the ui overlaps the top of the page. A sticky navigation,\n     * for example, would cause an overlap equal to its height.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOverlap = () => 0;\n\n    /**\n     * Current UI overlap.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Current maximum height for the main sticky element.\n     * @type {number}\n     * @private\n     */\n    this._maxHeight = 0;\n\n    /**\n     * Main element's top margin.\n     * @type {number}\n     * @private\n     */\n    this._marginTop = 0;\n\n    /**\n     * Main element's bottom margin.\n     * @type {number}\n     * @private\n     */\n    this._marginBottom = 0;\n\n    /**\n     * Top offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._top = 0;\n\n    /**\n     * Bottom offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._bottom = 0;\n\n    /**\n     * Height of the anchor (container).\n     * @type {number}\n     */\n    this.containerHeight = 0;\n\n    /**\n     * Unique id for the throttled scroll event listener.\n     * @type {string}\n     * @private\n     */\n    this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n\n    this.element.classList.add(Affix.Classes.BASE);\n    this.element.style.overflowY = 'auto';\n\n    // Keep track of instances so they can be batch-processed.\n    Affix.instances.push(this);\n\n    this.update();\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   * @protected\n   */\n  read() {\n    const rect = this._anchor.getBoundingClientRect();\n    const scrollY = window.pageYOffset;\n    const viewportHeight = window.innerHeight;\n    const asideHeight = this.element.offsetHeight;\n    this._asideWidth = this.element.offsetWidth;\n    const styles = getComputedStyle(this.element, null);\n    this._marginTop = parseFloat(styles.marginTop);\n    this._marginBottom = parseFloat(styles.marginBottom);\n\n    this._overlap = this._getUiOverlap();\n    this._maxHeight = viewportHeight - this._overlap - this._marginTop - this._marginBottom;\n\n    this.containerHeight = Math.round(rect.height);\n    this._top = rect.top + scrollY;\n    this._bottom = rect.bottom + scrollY - Math.min(asideHeight, this._maxHeight);\n  }\n\n  /** @protected */\n  write() {\n    this.element.style.maxHeight = this._maxHeight + 'px';\n    this.element.style.width = this._asideWidth + 'px';\n  }\n\n  /**\n   * This method runs on every frame to update the placement of the sticky element.\n   * @param {number} scrollTop Scroll top of the page.\n   */\n  process(scrollTop = window.pageYOffset) {\n    // Stick (position fixed).\n    if ((!this.isStuck && scrollTop >= this.top && scrollTop < this.bottom) ||\n        (this.isAtBottom && scrollTop < this.bottom)) {\n      this.stick();\n\n    // Affix. Item has reached the end of its view-length, stick it to the bottom.\n    } else if (!this.isAtBottom && scrollTop >= this.bottom) {\n      this.stickToBottom();\n\n    // Above the position where the sticky element should be position fixed, so unstick it.\n    } else if (this.isStuck && scrollTop < this.top) {\n      this.unstick();\n    }\n\n    // When the affix-element's position is soon going to change, promote it\n    // to a new layer so that the browser does not have to paint it on every scroll.\n    // Having the affix-element layer promoted all the time is inefficient and greedy.\n    const isInRange = this.isInPromotionRange(scrollTop);\n    if (!this.isPromoted && isInRange) {\n      this.layerPromote();\n    } else if (this.isPromoted && !isInRange) {\n      this.layerDemote();\n    }\n  }\n\n  /**\n   * Whether the browser's scroll position is within promotion range.\n   */\n  isInPromotionRange(scrollTop) {\n    return scrollTop >= this.top - Affix.PROMOTION_RANGE &&\n        scrollTop <= this.bottom + Affix.PROMOTION_RANGE;\n  }\n\n  /** @protected */\n  stick() {\n    this.element.style.position = 'fixed';\n    this.element.style.top = Math.round(this._overlap) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.isStuck = true;\n    this.isAtBottom = false;\n  }\n\n  /** @protected */\n  stickToBottom() {\n    this.element.style.position = 'absolute';\n    this.element.style.top = Math.round(this._bottom - this._top - this._marginBottom) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.element.classList.add(Affix.Classes.AT_BOTTOM);\n    this.isAtBottom = true;\n  }\n\n  /** @protected */\n  unstick() {\n    this.element.style.position = '';\n    this.element.classList.add(Affix.Classes.AT_TOP);\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.isStuck = false;\n    this.isAtBottom = false;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   * @protected\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   * @protected\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Reset values that are set with `write` so that they can be read again.\n   * @protected\n   */\n  reset() {\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n   * @return {function():number}\n   */\n  get uiOverlap() {\n    return this._getUiOverlap;\n  }\n\n  /**\n   * Define a custom getter to determine overlap.\n   * @param {function():number} fn\n   */\n  set uiOverlap(fn) {\n    this._getUiOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * The offset when this component becomes sticky.\n   * @return {number}\n   */\n  get top() {\n    return this._top - this._overlap;\n  }\n\n  /**\n   * The offset when this component sticks to the bottom of its container.\n   * @return {number}\n   */\n  get bottom() {\n    return this._bottom - this._marginBottom;\n  }\n\n  /**\n   * Reset everything, cache offsets, and recalculate.\n   */\n  update() {\n    const { scrollTop } = this.element;\n    this.unstick();\n    this.reset();\n    this.read();\n    this.write();\n    this.process();\n    this.element.scrollTop = scrollTop;\n  }\n\n  /**\n   * Remove event listeners and references.\n   */\n  dispose() {\n    this.layerDemote();\n    this.element.classList.remove(Affix.Classes.BASE);\n    this.element.style.position = '';\n    this.element.style.top = '';\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n    this.element.style.overflowY = '';\n    this.element = null;\n    this._anchor = null;\n    OdoScrollAnimation.remove(this._scrollId);\n    Affix.arrayRemove(Affix.instances, this);\n  }\n\n  /**\n   * Since 'load' events on images do not bubble, the event listener cannot be\n   * delegated and must be added to every image.\n   * The load event is not removed once the image loads because the image could\n   * be a responsive image which could have multiple load events.\n   */\n  static _addImageLoadHandlers() {\n    const images = document.getElementsByTagName('img');\n\n    for (let i = 0, len = images.length; i < len; i++) {\n      images[i].addEventListener('load', Affix._scheduleUpdate, false);\n    }\n  }\n\n  /**\n   * Schedule a throttled update to check if offsets need to be recalculated.\n   */\n  static _scheduleUpdate() {\n    window.removeEventListener('load', Affix._scheduleUpdate);\n\n    // Cancel a previous update if it exists.\n    if (Affix._updateId) {\n      window.cancelAnimationFrame(Affix._updateId);\n    }\n\n    // Throttle updates to once per frame.\n    Affix._updateId = window.requestAnimationFrame(Affix._handleImageLoad);\n  }\n\n  /**\n   * When an image loads, it could possibly change the layout/geometry of the\n   * entire page. Because Affix relies on offsets, everything must be\n   * updated here.\n   */\n  static _handleImageLoad() {\n    Affix._updateId = null;\n    Affix.documentHeight = document.body.offsetHeight;\n    Affix.viewportHeight = window.innerHeight;\n    Affix.update();\n  }\n\n  /**\n   * Batch update all instances. This method is more efficient because it syncs\n   * reads and writes to the DOM for each instance.\n   */\n  static update() {\n    const scrollY = window.pageYOffset;\n    const scrollPositions = Affix.instances.map(instance => instance.element.scrollTop);\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.unstick();\n      instance.reset();\n    });\n\n    // Read\n    Affix.instances.forEach((instance) => {\n      instance.read();\n    });\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.write();\n      instance.process(scrollY);\n    });\n\n    Affix.instances.forEach((instance, i) => {\n      instance.element.scrollTop = scrollPositions[i];\n    });\n  }\n\n  /**\n   * Remove an item from an array.\n   * @param {Array} arr Array to use.\n   * @param {*} item Item to remove.\n   * @return {*} Item removed.\n   */\n  static arrayRemove(arr, item) {\n    const index = arr.indexOf(item);\n    arr.splice(index, 1);\n    return item;\n  }\n}\n\nAffix.PROMOTION_RANGE = 200;\nAffix.instances = [];\nAffix._updateId = null;\nAffix.documentHeight = document.body.offsetHeight;\nAffix.viewportHeight = window.innerHeight;\nAffix._addImageLoadHandlers();\nAffix._resizeId = OdoWindowEvents.onResize(Affix._scheduleUpdate);\nwindow.addEventListener('load', Affix._scheduleUpdate);\n\nAffix.Classes = {\n  BASE: 'odo-affix',\n  AT_TOP: 'odo-affix--at-top',\n  AT_BOTTOM: 'odo-affix--at-bottom',\n};\n\nexport default Affix;\n"],"names":["Affix","element","_anchor","document","getElementById","getAttribute","this","Error","isStuck","isAtBottom","isPromoted","_getUiOverlap","_overlap","_maxHeight","_marginTop","_marginBottom","_top","_bottom","containerHeight","_scrollId","OdoScrollAnimation","add","process","bind","classList","Classes","BASE","style","overflowY","instances","push","update","read","rect","getBoundingClientRect","scrollY","window","pageYOffset","viewportHeight","innerHeight","asideHeight","offsetHeight","_asideWidth","offsetWidth","styles","getComputedStyle","parseFloat","marginTop","marginBottom","Math","round","height","top","bottom","min","write","maxHeight","width","scrollTop","stick","stickToBottom","unstick","isInRange","isInPromotionRange","layerPromote","layerDemote","PROMOTION_RANGE","position","remove","AT_BOTTOM","AT_TOP","willChange","transform","reset","dispose","arrayRemove","_addImageLoadHandlers","images","getElementsByTagName","i","len","length","addEventListener","_scheduleUpdate","removeEventListener","_updateId","cancelAnimationFrame","requestAnimationFrame","_handleImageLoad","documentHeight","body","scrollPositions","map","instance","forEach","arr","item","index","indexOf","splice","fn","_resizeId","OdoWindowEvents","onResize"],"mappings":"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"}