{"version":3,"file":"odo-affix.js","sources":["../src/affix.js"],"sourcesContent":["/**\n * @fileoverview Emulates `position:sticky` to make an element fixed position\n * while its within a container. This is best for sidebars so that they follow\n * the content, without overlapping sections below it.\n */\n\nimport OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\n\nclass Affix {\n  constructor(element) {\n    /**\n     * Main element.\n     * @type {HTMLElement}\n     */\n    this.element = element;\n\n    /**\n     * Parent containing element.\n     * @type {Element}\n     */\n    this._anchor = document.getElementById(element.getAttribute('data-anchor'));\n\n    if (!this._anchor) {\n      throw new Error(`Unable to find element with id=\"${element.getAttribute('data-anchor')}\"`);\n    }\n\n    /**\n     * Whether the main element is position fixed.\n     * @type {boolean}\n     */\n    this.isStuck = false;\n\n    /**\n     * Whether the main element is stuck to the bottom of its container.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the main element has been promoted to its own layer for the GPU.\n     * @type {boolean}\n     * @protected\n     */\n    this.isPromoted = false;\n\n    /**\n     * The amount that the ui overlaps the top of the page. A sticky navigation,\n     * for example, would cause an overlap equal to its height.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOverlap = () => 0;\n\n    /**\n     * Current UI overlap.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Current maximum height for the main sticky element.\n     * @type {number}\n     * @private\n     */\n    this._maxHeight = 0;\n\n    /**\n     * Main element's top margin.\n     * @type {number}\n     * @private\n     */\n    this._marginTop = 0;\n\n    /**\n     * Main element's bottom margin.\n     * @type {number}\n     * @private\n     */\n    this._marginBottom = 0;\n\n    /**\n     * Top offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._top = 0;\n\n    /**\n     * Bottom offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._bottom = 0;\n\n    /**\n     * Height of the anchor (container).\n     * @type {number}\n     */\n    this.containerHeight = 0;\n\n    /**\n     * Unique id for the throttled scroll event listener.\n     * @type {string}\n     * @private\n     */\n    this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n\n    this.element.classList.add(Affix.Classes.BASE);\n    this.element.style.overflowY = 'auto';\n\n    // Keep track of instances so they can be batch-processed.\n    Affix.instances.push(this);\n\n    this.update();\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   * @protected\n   */\n  read() {\n    const rect = this._anchor.getBoundingClientRect();\n    const scrollY = window.pageYOffset;\n    const viewportHeight = window.innerHeight;\n    const asideHeight = this.element.offsetHeight;\n    this._asideWidth = this.element.offsetWidth;\n    const styles = getComputedStyle(this.element, null);\n    this._marginTop = parseFloat(styles.marginTop);\n    this._marginBottom = parseFloat(styles.marginBottom);\n\n    this._overlap = this._getUiOverlap();\n    this._maxHeight = viewportHeight - this._overlap - this._marginTop - this._marginBottom;\n\n    this.containerHeight = Math.round(rect.height);\n    this._top = rect.top + scrollY;\n    this._bottom = rect.bottom + scrollY - Math.min(asideHeight, this._maxHeight);\n  }\n\n  /** @protected */\n  write() {\n    this.element.style.maxHeight = this._maxHeight + 'px';\n    this.element.style.width = this._asideWidth + 'px';\n  }\n\n  /**\n   * This method runs on every frame to update the placement of the sticky element.\n   * @param {number} scrollTop Scroll top of the page.\n   */\n  process(scrollTop = window.pageYOffset) {\n    // Stick (position fixed).\n    if ((!this.isStuck && scrollTop >= this.top && scrollTop < this.bottom) ||\n        (this.isAtBottom && scrollTop < this.bottom)) {\n      this.stick();\n\n    // Affix. Item has reached the end of its view-length, stick it to the bottom.\n    } else if (!this.isAtBottom && scrollTop >= this.bottom) {\n      this.stickToBottom();\n\n    // Above the position where the sticky element should be position fixed, so unstick it.\n    } else if (this.isStuck && scrollTop < this.top) {\n      this.unstick();\n    }\n\n    // When the affix-element's position is soon going to change, promote it\n    // to a new layer so that the browser does not have to paint it on every scroll.\n    // Having the affix-element layer promoted all the time is inefficient and greedy.\n    const isInRange = this.isInPromotionRange(scrollTop);\n    if (!this.isPromoted && isInRange) {\n      this.layerPromote();\n    } else if (this.isPromoted && !isInRange) {\n      this.layerDemote();\n    }\n  }\n\n  /**\n   * Whether the browser's scroll position is within promotion range.\n   */\n  isInPromotionRange(scrollTop) {\n    return scrollTop >= this.top - Affix.PROMOTION_RANGE &&\n        scrollTop <= this.bottom + Affix.PROMOTION_RANGE;\n  }\n\n  /** @protected */\n  stick() {\n    this.element.style.position = 'fixed';\n    this.element.style.top = Math.round(this._overlap) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.isStuck = true;\n    this.isAtBottom = false;\n  }\n\n  /** @protected */\n  stickToBottom() {\n    this.element.style.position = 'absolute';\n    this.element.style.top = Math.round(this._bottom - this._top - this._marginBottom) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.element.classList.add(Affix.Classes.AT_BOTTOM);\n    this.isAtBottom = true;\n  }\n\n  /** @protected */\n  unstick() {\n    this.element.style.position = '';\n    this.element.classList.add(Affix.Classes.AT_TOP);\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.isStuck = false;\n    this.isAtBottom = false;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   * @protected\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   * @protected\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Reset values that are set with `write` so that they can be read again.\n   * @protected\n   */\n  reset() {\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n   * @return {function():number}\n   */\n  get uiOverlap() {\n    return this._getUiOverlap;\n  }\n\n  /**\n   * Define a custom getter to determine overlap.\n   * @param {function():number} fn\n   */\n  set uiOverlap(fn) {\n    this._getUiOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * The offset when this component becomes sticky.\n   * @return {number}\n   */\n  get top() {\n    return this._top - this._overlap;\n  }\n\n  /**\n   * The offset when this component sticks to the bottom of its container.\n   * @return {number}\n   */\n  get bottom() {\n    return this._bottom - this._marginBottom;\n  }\n\n  /**\n   * Reset everything, cache offsets, and recalculate.\n   */\n  update() {\n    const { scrollTop } = this.element;\n    this.unstick();\n    this.reset();\n    this.read();\n    this.write();\n    this.process();\n    this.element.scrollTop = scrollTop;\n  }\n\n  /**\n   * Remove event listeners and references.\n   */\n  dispose() {\n    this.layerDemote();\n    this.element.classList.remove(Affix.Classes.BASE);\n    this.element.style.position = '';\n    this.element.style.top = '';\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n    this.element.style.overflowY = '';\n    this.element = null;\n    this._anchor = null;\n    OdoScrollAnimation.remove(this._scrollId);\n    Affix.arrayRemove(Affix.instances, this);\n  }\n\n  /**\n   * Since 'load' events on images do not bubble, the event listener cannot be\n   * delegated and must be added to every image.\n   * The load event is not removed once the image loads because the image could\n   * be a responsive image which could have multiple load events.\n   */\n  static _addImageLoadHandlers() {\n    const images = document.getElementsByTagName('img');\n\n    for (let i = 0, len = images.length; i < len; i++) {\n      images[i].addEventListener('load', Affix._scheduleUpdate, false);\n    }\n  }\n\n  /**\n   * Schedule a throttled update to check if offsets need to be recalculated.\n   */\n  static _scheduleUpdate() {\n    window.removeEventListener('load', Affix._scheduleUpdate);\n\n    // Cancel a previous update if it exists.\n    if (Affix._updateId) {\n      window.cancelAnimationFrame(Affix._updateId);\n    }\n\n    // Throttle updates to once per frame.\n    Affix._updateId = window.requestAnimationFrame(Affix._handleImageLoad);\n  }\n\n  /**\n   * When an image loads, it could possibly change the layout/geometry of the\n   * entire page. Because Affix relies on offsets, everything must be\n   * updated here.\n   */\n  static _handleImageLoad() {\n    Affix._updateId = null;\n    Affix.documentHeight = document.body.offsetHeight;\n    Affix.viewportHeight = window.innerHeight;\n    Affix.update();\n  }\n\n  /**\n   * Batch update all instances. This method is more efficient because it syncs\n   * reads and writes to the DOM for each instance.\n   */\n  static update() {\n    const scrollY = window.pageYOffset;\n    const scrollPositions = Affix.instances.map(instance => instance.element.scrollTop);\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.unstick();\n      instance.reset();\n    });\n\n    // Read\n    Affix.instances.forEach((instance) => {\n      instance.read();\n    });\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.write();\n      instance.process(scrollY);\n    });\n\n    Affix.instances.forEach((instance, i) => {\n      instance.element.scrollTop = scrollPositions[i];\n    });\n  }\n\n  /**\n   * Remove an item from an array.\n   * @param {Array} arr Array to use.\n   * @param {*} item Item to remove.\n   * @return {*} Item removed.\n   */\n  static arrayRemove(arr, item) {\n    const index = arr.indexOf(item);\n    arr.splice(index, 1);\n    return item;\n  }\n}\n\nAffix.PROMOTION_RANGE = 200;\nAffix.instances = [];\nAffix._updateId = null;\nAffix.documentHeight = document.body.offsetHeight;\nAffix.viewportHeight = window.innerHeight;\nAffix._addImageLoadHandlers();\nAffix._resizeId = OdoWindowEvents.onResize(Affix._scheduleUpdate);\nwindow.addEventListener('load', Affix._scheduleUpdate);\n\nAffix.Classes = {\n  BASE: 'odo-affix',\n  AT_TOP: 'odo-affix--at-top',\n  AT_BOTTOM: 'odo-affix--at-bottom',\n};\n\nexport default Affix;\n"],"names":["Affix","element","_anchor","document","getElementById","getAttribute","Error","isStuck","isAtBottom","isPromoted","_getUiOverlap","_overlap","_maxHeight","_marginTop","_marginBottom","_top","_bottom","containerHeight","_scrollId","OdoScrollAnimation","add","process","bind","classList","Classes","BASE","style","overflowY","instances","push","update","read","rect","getBoundingClientRect","scrollY","window","pageYOffset","viewportHeight","innerHeight","asideHeight","offsetHeight","_asideWidth","offsetWidth","styles","getComputedStyle","parseFloat","marginTop","marginBottom","Math","round","height","top","bottom","min","write","maxHeight","width","scrollTop","stick","stickToBottom","unstick","isInRange","isInPromotionRange","layerPromote","layerDemote","PROMOTION_RANGE","position","remove","AT_BOTTOM","AT_TOP","willChange","transform","reset","dispose","arrayRemove","_addImageLoadHandlers","images","getElementsByTagName","i","len","length","addEventListener","_scheduleUpdate","removeEventListener","_updateId","cancelAnimationFrame","requestAnimationFrame","_handleImageLoad","documentHeight","body","scrollPositions","map","instance","forEach","arr","item","index","indexOf","splice","fn","_resizeId","OdoWindowEvents","onResize"],"mappings":"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"}