{"version":3,"file":"odo-affix.js","sources":["../src/affix.js"],"sourcesContent":["/**\n * @fileoverview Emulates `position:sticky` to make an element fixed position\n * while its within a container. This is best for sidebars so that they follow\n * the content, without overlapping sections below it.\n */\n\nimport OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\n\nclass Affix {\n  constructor(element) {\n    /**\n     * Main element.\n     * @type {HTMLElement}\n     */\n    this.element = element;\n\n    /**\n     * Parent containing element.\n     * @type {Element}\n     */\n    this._anchor = document.getElementById(element.getAttribute('data-anchor'));\n\n    if (!this._anchor) {\n      throw new Error(`Unable to find element with id=\"${element.getAttribute('data-anchor')}\"`);\n    }\n\n    /**\n     * Whether the main element is position fixed.\n     * @type {boolean}\n     */\n    this.isStuck = false;\n\n    /**\n     * Whether the main element is stuck to the bottom of its container.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the main element has been promoted to its own layer for the GPU.\n     * @type {boolean}\n     * @protected\n     */\n    this.isPromoted = false;\n\n    /**\n     * The amount that the ui overlaps the top of the page. A sticky navigation,\n     * for example, would cause an overlap equal to its height.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOverlap = () => 0;\n\n    /**\n     * Current UI overlap.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Current maximum height for the main sticky element.\n     * @type {number}\n     * @private\n     */\n    this._maxHeight = 0;\n\n    /**\n     * Main element's top margin.\n     * @type {number}\n     * @private\n     */\n    this._marginTop = 0;\n\n    /**\n     * Main element's bottom margin.\n     * @type {number}\n     * @private\n     */\n    this._marginBottom = 0;\n\n    /**\n     * Top offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._top = 0;\n\n    /**\n     * Bottom offset of the main element.\n     * @type {number}\n     * @private\n     */\n    this._bottom = 0;\n\n    /**\n     * Height of the anchor (container).\n     * @type {number}\n     */\n    this.containerHeight = 0;\n\n    /**\n     * Unique id for the throttled scroll event listener.\n     * @type {string}\n     * @private\n     */\n    this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n\n    this.element.classList.add(Affix.Classes.BASE);\n    this.element.style.overflowY = 'auto';\n\n    // Keep track of instances so they can be batch-processed.\n    Affix.instances.push(this);\n\n    this.update();\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   * @protected\n   */\n  read() {\n    const rect = this._anchor.getBoundingClientRect();\n    const scrollY = window.pageYOffset;\n    const viewportHeight = window.innerHeight;\n    const asideHeight = this.element.offsetHeight;\n    this._asideWidth = this.element.offsetWidth;\n    const styles = getComputedStyle(this.element, null);\n    this._marginTop = parseFloat(styles.marginTop);\n    this._marginBottom = parseFloat(styles.marginBottom);\n\n    this._overlap = this._getUiOverlap();\n    this._maxHeight = viewportHeight - this._overlap - this._marginTop - this._marginBottom;\n\n    this.containerHeight = Math.round(rect.height);\n    this._top = rect.top + scrollY;\n    this._bottom = rect.bottom + scrollY - Math.min(asideHeight, this._maxHeight);\n  }\n\n  /** @protected */\n  write() {\n    this.element.style.maxHeight = this._maxHeight + 'px';\n    this.element.style.width = this._asideWidth + 'px';\n  }\n\n  /**\n   * This method runs on every frame to update the placement of the sticky element.\n   * @param {number} scrollTop Scroll top of the page.\n   */\n  process(scrollTop = window.pageYOffset) {\n    // Stick (position fixed).\n    if ((!this.isStuck && scrollTop >= this.top && scrollTop < this.bottom) ||\n        (this.isAtBottom && scrollTop < this.bottom)) {\n      this.stick();\n\n    // Affix. Item has reached the end of its view-length, stick it to the bottom.\n    } else if (!this.isAtBottom && scrollTop >= this.bottom) {\n      this.stickToBottom();\n\n    // Above the position where the sticky element should be position fixed, so unstick it.\n    } else if (this.isStuck && scrollTop < this.top) {\n      this.unstick();\n    }\n\n    // When the affix-element's position is soon going to change, promote it\n    // to a new layer so that the browser does not have to paint it on every scroll.\n    // Having the affix-element layer promoted all the time is inefficient and greedy.\n    const isInRange = this.isInPromotionRange(scrollTop);\n    if (!this.isPromoted && isInRange) {\n      this.layerPromote();\n    } else if (this.isPromoted && !isInRange) {\n      this.layerDemote();\n    }\n  }\n\n  /**\n   * Whether the browser's scroll position is within promotion range.\n   */\n  isInPromotionRange(scrollTop) {\n    return scrollTop >= this.top - Affix.PROMOTION_RANGE &&\n        scrollTop <= this.bottom + Affix.PROMOTION_RANGE;\n  }\n\n  /** @protected */\n  stick() {\n    this.element.style.position = 'fixed';\n    this.element.style.top = Math.round(this._overlap) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.isStuck = true;\n    this.isAtBottom = false;\n  }\n\n  /** @protected */\n  stickToBottom() {\n    this.element.style.position = 'absolute';\n    this.element.style.top = Math.round(this._bottom - this._top - this._marginBottom) + 'px';\n    this.element.classList.remove(Affix.Classes.AT_TOP);\n    this.element.classList.add(Affix.Classes.AT_BOTTOM);\n    this.isAtBottom = true;\n  }\n\n  /** @protected */\n  unstick() {\n    this.element.style.position = '';\n    this.element.classList.add(Affix.Classes.AT_TOP);\n    this.element.classList.remove(Affix.Classes.AT_BOTTOM);\n    this.isStuck = false;\n    this.isAtBottom = false;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   * @protected\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   * @protected\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Reset values that are set with `write` so that they can be read again.\n   * @protected\n   */\n  reset() {\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n   * @return {function():number}\n   */\n  get uiOverlap() {\n    return this._getUiOverlap;\n  }\n\n  /**\n   * Define a custom getter to determine overlap.\n   * @param {function():number} fn\n   */\n  set uiOverlap(fn) {\n    this._getUiOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * The offset when this component becomes sticky.\n   * @return {number}\n   */\n  get top() {\n    return this._top - this._overlap;\n  }\n\n  /**\n   * The offset when this component sticks to the bottom of its container.\n   * @return {number}\n   */\n  get bottom() {\n    return this._bottom - this._marginBottom;\n  }\n\n  /**\n   * Reset everything, cache offsets, and recalculate.\n   */\n  update() {\n    const { scrollTop } = this.element;\n    this.unstick();\n    this.reset();\n    this.read();\n    this.write();\n    this.process();\n    this.element.scrollTop = scrollTop;\n  }\n\n  /**\n   * Remove event listeners and references.\n   */\n  dispose() {\n    this.layerDemote();\n    this.element.classList.remove(Affix.Classes.BASE);\n    this.element.style.position = '';\n    this.element.style.top = '';\n    this.element.style.maxHeight = '';\n    this.element.style.width = '';\n    this.element.style.overflowY = '';\n    this.element = null;\n    this._anchor = null;\n    OdoScrollAnimation.remove(this._scrollId);\n    Affix.arrayRemove(Affix.instances, this);\n  }\n\n  /**\n   * Since 'load' events on images do not bubble, the event listener cannot be\n   * delegated and must be added to every image.\n   * The load event is not removed once the image loads because the image could\n   * be a responsive image which could have multiple load events.\n   */\n  static _addImageLoadHandlers() {\n    const images = document.getElementsByTagName('img');\n\n    for (let i = 0, len = images.length; i < len; i++) {\n      images[i].addEventListener('load', Affix._scheduleUpdate, false);\n    }\n  }\n\n  /**\n   * Schedule a throttled update to check if offsets need to be recalculated.\n   */\n  static _scheduleUpdate() {\n    window.removeEventListener('load', Affix._scheduleUpdate);\n\n    // Cancel a previous update if it exists.\n    if (Affix._updateId) {\n      window.cancelAnimationFrame(Affix._updateId);\n    }\n\n    // Throttle updates to once per frame.\n    Affix._updateId = window.requestAnimationFrame(Affix._handleImageLoad);\n  }\n\n  /**\n   * When an image loads, it could possibly change the layout/geometry of the\n   * entire page. Because Affix relies on offsets, everything must be\n   * updated here.\n   */\n  static _handleImageLoad() {\n    Affix._updateId = null;\n    Affix.documentHeight = document.body.offsetHeight;\n    Affix.viewportHeight = window.innerHeight;\n    Affix.update();\n  }\n\n  /**\n   * Batch update all instances. This method is more efficient because it syncs\n   * reads and writes to the DOM for each instance.\n   */\n  static update() {\n    const scrollY = window.pageYOffset;\n    const scrollPositions = Affix.instances.map(instance => instance.element.scrollTop);\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.unstick();\n      instance.reset();\n    });\n\n    // Read\n    Affix.instances.forEach((instance) => {\n      instance.read();\n    });\n\n    // Write\n    Affix.instances.forEach((instance) => {\n      instance.write();\n      instance.process(scrollY);\n    });\n\n    Affix.instances.forEach((instance, i) => {\n      instance.element.scrollTop = scrollPositions[i];\n    });\n  }\n\n  /**\n   * Remove an item from an array.\n   * @param {Array} arr Array to use.\n   * @param {*} item Item to remove.\n   * @return {*} Item removed.\n   */\n  static arrayRemove(arr, item) {\n    const index = arr.indexOf(item);\n    arr.splice(index, 1);\n    return item;\n  }\n}\n\nAffix.PROMOTION_RANGE = 200;\nAffix.instances = [];\nAffix._updateId = null;\nAffix.documentHeight = document.body.offsetHeight;\nAffix.viewportHeight = window.innerHeight;\nAffix._addImageLoadHandlers();\nAffix._resizeId = OdoWindowEvents.onResize(Affix._scheduleUpdate);\nwindow.addEventListener('load', Affix._scheduleUpdate);\n\nAffix.Classes = {\n  BASE: 'odo-affix',\n  AT_TOP: 'odo-affix--at-top',\n  AT_BOTTOM: 'odo-affix--at-bottom',\n};\n\nexport default Affix;\n"],"names":["Affix","element","_anchor","document","getElementById","getAttribute","Error","isStuck","isAtBottom","isPromoted","_getUiOverlap","_overlap","_maxHeight","_marginTop","_marginBottom","_top","_bottom","containerHeight","_scrollId","OdoScrollAnimation","add","process","bind","classList","Classes","BASE","style","overflowY","instances","push","update","read","rect","getBoundingClientRect","scrollY","window","pageYOffset","viewportHeight","innerHeight","asideHeight","offsetHeight","_asideWidth","offsetWidth","styles","getComputedStyle","parseFloat","marginTop","marginBottom","Math","round","height","top","bottom","min","write","maxHeight","width","scrollTop","stick","stickToBottom","unstick","isInRange","isInPromotionRange","layerPromote","layerDemote","PROMOTION_RANGE","position","remove","AT_BOTTOM","AT_TOP","willChange","transform","reset","dispose","arrayRemove","_addImageLoadHandlers","images","getElementsByTagName","i","len","length","addEventListener","_scheduleUpdate","removeEventListener","_updateId","cancelAnimationFrame","requestAnimationFrame","_handleImageLoad","documentHeight","body","scrollPositions","map","instance","forEach","arr","item","index","indexOf","splice","fn","_resizeId","OdoWindowEvents","onResize"],"mappings":"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"}