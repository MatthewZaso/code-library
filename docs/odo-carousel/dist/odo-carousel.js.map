{"version":3,"file":"odo-carousel.js","sources":["../src/carousel-event.js","../src/settings.js","../src/template-engine.js","../src/utils.js","../src/carousel.js"],"sourcesContent":["\nclass CarouselEvent {\n  /**\n   * Object representing a carousel event.\n   * @param {string} type Event type.\n   * @param {Carousel} carousel The carousel instance.\n   * @param {number=} optFrom The logical index the carousel is coming from.\n   * @param {number=} optTo The logical index the carouesl is going to.\n   * @constructor\n   */\n  constructor(type, carousel, optFrom, optTo) {\n    this.type = type;\n\n    /** @type {Element} */\n    this.target = carousel.element;\n\n    /** @type {number} carousel slid from this index. */\n    this.from = optFrom;\n\n    /** @type {number} carousel slid to this index. */\n    this.to = optTo;\n\n    /** @type {boolean} Whether the carousel actually changed slides. */\n    this.hasSlideChanged = optFrom !== optTo;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default CarouselEvent;\n","export default {\n\n  /**\n   * Event types emitted by the carousel.\n   * @enum {string}\n   */\n  EventType: {\n    WILL_NAVIGATE: 'odocarousel:willnavigate',\n    SLIDE_START: 'odocarousel:slidestart',\n    SLIDE_END: 'odocarousel:slideend',\n  },\n\n  /** @enum {string} */\n  Classes: {\n    BASE: 'odo-carousel',\n    FADE: 'odo-carousel--fade',\n    VERTICAL: 'odo-carousel--vertical',\n    WRAPPER: 'odo-carousel__wrapper',\n    CAROUSEL_ELEMENT: 'odo-carousel__element',\n\n    SLIDE: 'odo-carousel__slide',\n    ACTIVE_SLIDE: 'odo-carousel__slide--active',\n    PREVIOUS_SLIDE: 'odo-carousel__slide--previous',\n    PAST_SLIDE: 'odo-carousel__slide--past',\n    NEXT_SLIDE: 'odo-carousel__slide--next',\n    FUTURE_SLIDE: 'odo-carousel__slide--future',\n\n    VISIBLE: 'odo-carousel__slide--visible',\n    BEHIND: 'odo-carousel__slide--behind',\n\n    PAGINATION: 'odo-carousel__pagination',\n    PAGINATION_DOT: 'odo-carousel__pagination-dot',\n    PAGINATION_DOT_SELECTED: 'is-selected',\n\n    PADDLES: 'odo-carousel__nav-paddles',\n    PADDLE: 'odo-carousel__nav-paddle',\n    PADDLE_NEXT: 'odo-carousel__nav-next',\n    PADDLE_PREV: 'odo-carousel__nav-prev',\n    PADDLE_DISABLED: 'is-disabled',\n\n    SLIDE_CHILD: 'odo-carousel__slide-child',\n  },\n\n  Defaults: {\n    startIndex: 0,\n    isVertical: false,\n    isLooped: false,\n    isJumped: false,\n    isFade: false,\n    isCentered: false,\n    neighborCount: 1,\n    slideshowSpeed: 1000,\n    animationSpeed: 400,\n    crossfadeAmount: 0.875,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    pagination: false,\n    getNavPaddleHtml: null,\n    getPaginationHtml: null,\n    template: {\n      paddles: '<nav class=\"odo-carousel__nav-paddles\">{{ prev }}{{ next }}</nav>',\n      paddleNext: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"next slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-next\">{{ paddleInner }}</a>',\n      paddlePrev: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"previous slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-prev\">{{ paddleInner }}</a>',\n      paddleNextInner: '<svg viewBox=\"75.4 27 461.2 738\"><path d=\"M167.7 27l368.9 369-368.9 369-92.3-92.3 276.7-276.7-276.7-276.7z\"/></svg>',\n      paddlePrevInner: '<svg viewBox=\"75.396 26.994 461.208 738.012\"><path d=\"M444.336 765.006l-368.94-369.006 368.94-369.006 92.268 92.268-276.738 276.738 276.738 276.738z\"/></svg>',\n      pagination: '<nav class=\"odo-carousel__pagination\" role=\"tablist\">{{ dots }}</nav>',\n      paginationDot: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\"></a>',\n      paginationDotSecondary: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\" data-secondary-index=\"{{ secondaryIndex }}\" aria-hidden=\"{{ hidden }}\"></a>',\n    },\n  },\n\n  TRANSITION_END_WAIT: 32,\n};\n","/**\n * A simple string replacement template with double curly braces. You can use\n * nested objects and functions too.\n *\n * Usage:\n *     template(\"Today is {{ day }}\", {\n *       day: 'Friday'\n *     }); // \"Today is Friday\"\n *\n *     template(\"Today is {{ month.day }}\", {\n *       month: {\n *         day: \"Friday\"\n *       }\n *     }); // \"Today is Friday\n *\n *     template(\"Today is {{ day }}\", {\n *       dayOfTheWeek: 'Friday',\n *       day: function() {\n *         return this.dayOfTheWeek;\n *       }\n *     }); // \"Today is Friday\"\n *\n *\n * @param {string} str Template.\n * @param {Object} data Data object with keys which match your template.\n * @return {string}\n */\nexport default function template(str, data) {\n  // A modified version of Malsup's template method for Cycle.\n  // https://github.com/malsup/cycle2/blob/master/src/jquery.cycle2.tmpl.js\n\n  // Regex which matches {{cool}} or {{ cool }} where `cool` is what should\n  // be replaced.\n  return str.replace(/{{\\s?((.)?.*?)\\s?}}/g, (match, str) => {\n    const names = str.split('.');\n    let obj = data;\n    let property;\n\n    // If the name has dots in it, \"person.name\", loop through each one.\n    if (names.length > 1) {\n      property = obj;\n      for (let i = 0; i < names.length; i++) {\n        obj = property;\n        property = property[names[i]] || str;\n      }\n\n    // Otherwise, it's a simple assignment from the data object.\n    } else {\n      property = obj[str];\n    }\n\n    // If they passed a function, use that.\n    if (typeof property === 'function') {\n      return property.call(obj);\n    }\n\n    // Return the string if it exists.\n    if (property !== undefined && property !== null && property !== str) {\n      return property;\n    }\n\n    // Otherwise, return the original string.\n    return str;\n  });\n}\n","\nexport function getTranslate(str) {\n  const array = str.match(/(-?[\\d.]+)/g);\n  return {\n    x: parseFloat(array[4]),\n    y: parseFloat(array[5]),\n  };\n}\n\nlet count = 0;\nexport function uniqueId() {\n  count += 1;\n  return `odo-carousel${count}`;\n}\n\n/**\n * Find every element within the parent which is focusable via tabbing and\n * enable/disable it. Ideally, some property could be set on the parent\n * element itself to prevent tabbing into it. visibility:hidden accomplishes\n * this, but there can be slides in view which are not the current slide.\n * @param {Element} parent Ancestor element to disable tabbing into.\n * @param {boolean} canFocus Whether to enable or disable focusability.\n */\nexport function toggleFocusability(parent, canFocus) {\n  const focusableElements = 'a[href],button,details,iframe,input,textarea,select,*[tabindex]';\n  const elements = Array.from(parent.querySelectorAll(focusableElements));\n\n  // Test the parent element itself. Odo Helpers polyfills `matches`.\n  if (parent.matches(focusableElements)) {\n    elements.push(parent);\n  }\n\n  for (let i = elements.length - 1; i >= 0; i--) {\n    if (canFocus) {\n      // Prefer resetting the tabIndex property by using removeAttribute to lets\n      // the browser decide if it should go back to 0 (like if it was a button)\n      // or to -1 if it wasn't originally focusable.\n      elements[i].removeAttribute('tabindex');\n    } else {\n      elements[i].tabIndex = -1;\n    }\n  }\n}\n","/**\n * @fileoverview A UI Component for creating versatile carousels. They are\n * peformant, draggable, and can ininitely loop.\n *\n * @author glen@odopod.com (Glen Cheney)\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport OdoPointer from '@odopod/odo-pointer';\nimport OdoDraggable from '@odopod/odo-draggable';\nimport {\n  animation,\n  array,\n  dom,\n  math,\n  string,\n  style,\n  Timer,\n} from '@odopod/odo-helpers';\n\nimport CarouselEvent from './carousel-event';\nimport settings from './settings';\nimport templateEngine from './template-engine';\nimport { getTranslate, toggleFocusability, uniqueId } from './utils';\n\nclass Carousel extends TinyEmitter {\n  /**\n   * @param {Element} element The outermost carousel element.\n   * @param {Object} [options] An options object.\n   * @constructor\n   * @throws {TypeError} if element isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!(element instanceof Element)) {\n      throw new TypeError(`OdoCarousel requires an element. Got: \"${element}\"`);\n    }\n\n    this.element = element;\n\n    /**\n     * Deep copy from the defaults and override defaults with options passed in.\n     * @public\n     */\n    this.options = Carousel.getOptions(options);\n\n    /**\n     * Whether the carousel is vertical or horizontal.\n     * @type {boolean}\n     * @protected\n     */\n    this.isVertical = this.options.isVertical;\n\n    /**\n     * Whether this is a looped carousel which is not a fading carousel.\n     * @type {boolean}\n     */\n    this._isSlidingLooped = this.options.isLooped && !this.options.isFade;\n\n    /**\n     * The DOM index of the current slide element within the slides' parent.\n     * @type {number}\n     * @protected\n     */\n    this.domIndex = 0;\n\n    /**\n     * The previous domIndex value.\n     * @type {number}\n     * @protected\n     */\n    this.lastDomIndex = 0;\n\n    /**\n     * Current logical index.\n     * @type {number}\n     */\n    this._selectedIndex = 0;\n\n    /**\n     * The slide container's parent.\n     * @type {Element}\n     * @private\n     */\n    this._slideContainerParentEl = null;\n\n    /**\n     * The container for the slides and the element which is moved around with\n     * transforms or absolute positioning.\n     * @type {Element}\n     * @private\n     */\n    this._carouselEl = null;\n\n    /**\n     * An array of slides (elements) in the carousel.\n     * @type {Array.<!Element>}\n     * @private\n     */\n    this._slides = [];\n\n    /**\n     * Whether the carousel is currently skipping slides. For example, going from\n     * slide 1 to 3, a jumping carousel repositions the slides so that 3 is next\n     * to 1 and only has to animate one slide length to get to it. This flag\n     * indicates a slide has been repositioned.\n     * @type {boolean}\n     * @private\n     */\n    this._isJumped = false;\n\n    /**\n     * Whether the carousel is able to be used. This can be changed with the\n     * `setEnabled` method.\n     * @type {boolean}\n     * @private\n     */\n    this._isEnabled = true;\n\n    /**\n     * Top or left.\n     * @type {string}\n     * @private\n     */\n    this._posAttr = this.isVertical ? 'top' : 'left';\n\n    /**\n     * offsetTop or offsetLeft.\n     * @type {string}\n     * @private\n     */\n    this._offsetPosition = 'offset' + string.capitalize(this._posAttr);\n\n    /**\n     * Height or width.\n     * @type {string}\n     * @private\n     */\n    this._dimensionAttr = this.isVertical ? 'height' : 'width';\n\n    /**\n     * Value used in `translate{X|Y}()`.\n     * @type {string}\n     */\n    this._translateAxis = this.isVertical ? 'Y' : 'X';\n\n    /**\n     * A flag indicating that the carousel is animating. It also will have\n     * a transition end event lister bound to it if the browser can\n     * transition transforms.\n     * @type {boolean}\n     * @protected\n     */\n    this.isTransitioning = false;\n\n    /**\n     * The id returned from animation.onTransitionEnd which is used to cancel\n     * the transitionend listener.\n     * @type {string}\n     */\n    this._transitionId = null;\n\n    /**\n     * If a selector is specified, gotoSlide will look for this on the last\n     * slide and not reveal unneccesary whitespace to the right of the last\n     * matched element.\n     * @type {boolean}\n     * @private\n     */\n    this._hasSlideChildren = false;\n\n    /**\n     * Default to true for being able to drag the carousel between slides.\n     * @type {boolean}\n     * @private\n     */\n    this._isDraggable = true;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the carousel is at a resting position or between slides.\n     * @type {boolean}\n     */\n    this._isOffset = false;\n\n    /**\n     * A Timer used to make the carousel an autoplaying slideshow.\n     * @type {Timer}\n     * @private\n     */\n    this._timer = null;\n\n    /**\n     * Time, in milliseconds, to wait before adding zero opacity to the slide,\n     * which triggers the css transition. timeout = speed - (speed * %).\n     * @type {number}\n     * @private\n     */\n    this._crossfadeTimeout = this.options.animationSpeed -\n        (this.options.animationSpeed * this.options.crossfadeAmount);\n\n    /**\n     * When carousel slides are centered, they won't be aligned with the starting\n     * edge of the carousel wrapper. The starting edge (relative zero) is used\n     * to determine which slide is closest to the current position.\n     * @type {number}\n     */\n    this._startEdge = 0;\n\n    /**\n     * Draggable attached to the carousel element. Used for non-fade carousels.\n     * @type {OdoDraggable}\n     */\n    this.draggable = null;\n\n    /**\n     * Pointer attached to the main element. Used for fading carousels.\n     * @type {OdoDraggable}\n     */\n    this.pointer = null;\n\n    /**\n     * Carousels containing only two slides with looping functionality are special\n     * cases. Slides need to be duplicated and pagination needs to be rendered\n     * differently. This is because in order for the user to navigate in either\n     * direction from the active slide, the second slide would need to be present in\n     * both the 'previous' and 'next' positions. 'Bidirectional' will refer to\n     * carousels with content that unnaturally exists for the sake of navigational\n     * purposes.\n     * @type {boolean}\n     */\n    this._isBidirectional = false;\n\n    // Deprecated method.\n    this.resetSync = this.reset;\n\n    // Go.\n    this.decorate();\n  }\n\n  /**\n   * Finds an element within this class' main element based on a class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optionally provide the context (scope)\n   *     for the query. Default is the main element of the class.\n   * @return {Array.<Element>} An array which may or may not contain the element\n   *     which was searched for.\n   */\n  getElementsByClass(className, context = this.element) {\n    return Array.from(context.getElementsByClassName(className));\n  }\n\n  /**\n   * Retrieve an element by its class name.\n   * @param {string} className Class name to search for.\n   * @param {Element} [context] Optinal scope for search.\n   * @return {?Element} The element or null if it isn't found.\n   */\n  getElementByClass(className, context) {\n    return this.getElementsByClass(className, context)[0] || null;\n  }\n\n  /**\n   * Modify the DOM to be a carousel.\n   */\n  decorate() {\n    this._saveDomElements();\n\n    // After we determine the number of slides, we have enough information to decide if\n    // this carousel will be a special bidirectional one.\n    if (this.options.isLooped && this._slides.length === 2) {\n      this._decorateBidirectionalCarousel();\n    }\n\n    this._setA11yAttributes();\n    this._renderPaddles();\n\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    this._setSlideIndices();\n\n    if (this.options.isFade) {\n      this._decorateFadeCarousel();\n    } else {\n      this._decorateRegularCarousel();\n    }\n\n    this._onClick = this._handleClick.bind(this);\n    this.element.addEventListener('click', this._onClick);\n\n    // Set the selected index without animation.\n    this.setSelectedIndex(this._getSafeIndex(this.options.startIndex), true);\n\n    // Changes viewport, so it needs to come after the goto zero.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateRegularCarousel() {\n    // Add easing to container\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_PROPERTY] = OdoDevice.Css.TRANSFORM;\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_TIMING_FUNCTION] = this.options.easing;\n\n    this._hasSlideChildren = this._getSlideChildren().length > 0;\n\n    this.bindDragEvents();\n  }\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n  _decorateFadeCarousel() {\n    this._isDraggable = false;\n\n    // Add transitions to each slide.\n    this.getSlides().forEach((slide, i) => {\n      slide.style[OdoDevice.Dom.TRANSITION] = 'opacity ' +\n        this.options.animationSpeed + 'ms linear';\n\n      // The first slide needs to have the visible class.\n      if (i === 0) {\n        slide.classList.add(Carousel.Classes.VISIBLE);\n      }\n    });\n\n    this.bindSwipeEvents();\n  }\n\n  /**\n   * Sets up the additional DOM modifications that will be needed for bidirectional\n   * carousels. We will essentially be duplicating both carousel slides so that no\n   * matter the current index, the active slide will alway have neighbors on either side.\n   * Then later on, we hide the additional pagination.\n   * @private\n   */\n  _decorateBidirectionalCarousel() {\n    // Bidirectional carousels automatically will need to become a jumped carousels,\n    // since we will be adding artificial slides that ruin natural navigation.\n    this._isBidirectional = true;\n    this._isJumped = true;\n\n    // Turn 2 slides into 4.\n    this._slides.forEach((slide) => {\n      this.getCarouselElement().appendChild(slide.cloneNode(true));\n    });\n\n    // Update the global slides variable to include the new elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Set static accessibility attributes.\n   */\n  _setA11yAttributes() {\n    this.getWrapper().setAttribute('aria-live', 'polite');\n    this.getCarouselElement().setAttribute('role', 'list');\n    this.getSlides().forEach((slide) => {\n      dom.giveId(slide, uniqueId);\n      slide.setAttribute('role', 'listitem');\n    });\n  }\n\n  /**\n   * Remove static accessibility attributes.\n   */\n  _removeA11yAttributes() {\n    this.getWrapper().removeAttribute('aria-live');\n    this.getCarouselElement().removeAttribute('role');\n    this.getSlides().forEach((slide) => {\n      slide.removeAttribute('role');\n    });\n  }\n\n  /**\n   * Store references to commonly used DOM elements.\n   * @private\n   */\n  _saveDomElements() {\n    // Element which wraps the element which contains all the slides.\n    this._slideContainerParentEl = this.getElementByClass(Carousel.Classes.WRAPPER);\n\n    // Element which contains all the slides.\n    this._carouselEl = this.getElementByClass(Carousel.Classes.CAROUSEL_ELEMENT);\n\n    // Because carousels can have carousels inside them, finding elements by\n    // class retrieves too many elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  }\n\n  /**\n   * Store references to generated elements. The pagination dots cannot be save in\n   * `_saveDomElements` because the number of slides is not yet known.\n   * @private\n   */\n  _saveRenderedElements() {\n    this._paddlePrevious = this.getElementByClass(Carousel.Classes.PADDLE_PREV);\n    this._paddleNext = this.getElementByClass(Carousel.Classes.PADDLE_NEXT);\n    this._paginationDots = this.getElementsByClass(Carousel.Classes.PAGINATION_DOT)\n      .map(dot => ({\n        dot,\n        i: parseInt(dot.getAttribute('data-index'), 10),\n        i2: parseInt(dot.getAttribute('data-secondary-index'), 10),\n      }));\n  }\n\n  /**\n   * Add navigation paddles (previous and next buttons) to the carousel.\n   * @private\n   */\n  _renderPaddles() {\n    this.element.insertAdjacentHTML('beforeend', this._getNavPaddleHtml());\n  }\n\n  /**\n   * Remove navigation paddles from the carousel (if they exist).\n   * @private\n   */\n  _removePaddles() {\n    this._removeByClass(Carousel.Classes.PADDLES);\n  }\n\n  /**\n   * Remove a child element by class, if it exists.\n   * @param {string} className Class name of the element to find and remove.\n   */\n  _removeByClass(className) {\n    const element = this.getElementByClass(className);\n    if (element) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  /**\n   * Retrieves the html string for the nav paddles from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getNavPaddleHtml() {\n    if (typeof this.options.getNavPaddleHtml === 'function') {\n      return this.options.getNavPaddleHtml.call(this, this);\n    }\n\n    return Carousel.template(this.options.template.paddles, {\n      prev: Carousel.template(this.options.template.paddlePrev, {\n        paddleInner: this.options.template.paddlePrevInner,\n      }),\n      next: Carousel.template(this.options.template.paddleNext, {\n        paddleInner: this.options.template.paddleNextInner,\n      }),\n    });\n  }\n\n  /**\n   * Add pagination (the dots) to the carousel.\n   * @private\n   */\n  _renderPagination() {\n    this.element.insertAdjacentHTML('beforeend', this._getPaginationHtml());\n  }\n\n  /**\n   * Remove pagination from the carousel (if they exist).\n   * @private\n   */\n  _removePagination() {\n    this._removeByClass(Carousel.Classes.PAGINATION);\n  }\n\n  /**\n   * Retrieves the html string for the pagination from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n  _getPaginationHtml() {\n    if (typeof this.options.getPaginationHtml === 'function') {\n      return this.options.getPaginationHtml.call(this, this);\n    }\n\n    const dots = this._buildPaginationHtml();\n\n    return Carousel.template(this.options.template.pagination, {\n      dots,\n    });\n  }\n\n  /**\n   * Builds and returns the HTML string of the pagination dots.\n   * Bidirectional carousels utilize a separate template that includes\n   * secondary indices.\n   * @return {string}\n   * @private\n   */\n  _buildPaginationHtml() {\n    const template = this._isBidirectional ?\n      this.options.template.paginationDotSecondary :\n      this.options.template.paginationDot;\n\n    return this.getSlides().reduce((dotsHtml, slide, i, arr) => {\n      const data = {\n        index: i,\n        index1: i + 1,\n        slideId: slide.id,\n      };\n\n      if (this._isBidirectional) {\n        // If you are rendering pagination for a bidirectional carousel, you will need\n        // secondary indices computed. This returns the secondary index based on the primary.\n        // i.e. For 4 slides, 1 returns 3, 2 returns 4 and the inverse.\n        data.secondaryIndex = i > 1 ? i % 2 : i + 2;\n        data.hidden = i >= arr.length / 2;\n      }\n\n      return dotsHtml + Carousel.template(template, data);\n    }, '');\n  }\n\n  /**\n   * Listen for dragging events.\n   * @protected\n   */\n  bindDragEvents() {\n    this.draggable = new OdoDraggable(this._carouselEl, {\n      axis: this.isVertical ? OdoPointer.Axis.Y : OdoPointer.Axis.X,\n    });\n\n    this._onDragStart = this._handleDragStart.bind(this);\n    this._onDragMove = this._handleDragMove.bind(this);\n    this._onDragEnd = this._handleDragEnd.bind(this);\n\n    this.draggable.on(OdoDraggable.EventType.START, this._onDragStart);\n    this.draggable.on(OdoDraggable.EventType.MOVE, this._onDragMove);\n    this.draggable.on(OdoDraggable.EventType.END, this._onDragEnd);\n  }\n\n  /**\n   * Listen for the pointer to come up from the screen, then execute a callback.\n   * @protected\n   */\n  bindSwipeEvents() {\n    this.pointer = new OdoPointer(this._carouselEl, {\n      axis: OdoPointer.Axis.X,\n      preventEventDefault: true,\n    });\n\n    this._onPointerEnd = this._handlePointerEnd.bind(this);\n    this.pointer.on(OdoPointer.EventType.END, this._onPointerEnd);\n  }\n\n  /**\n   * Add a slide to the end of the carousel.\n   * @param {string} slideHtml Html string for the slide.\n   */\n  addSlide(slideHtml) {\n    // Make sure looped carousels are in the right order without any neighbors.\n    this._setSlidesToLogicalOrder();\n\n    // Insert new slide at the end.\n    this._carouselEl.insertAdjacentHTML('beforeend', slideHtml);\n\n    this.reset();\n  }\n\n  /**\n   * Synchronously reset the slides. Use this when you're sure the elements\n   * within the carousel are done changing.\n   */\n  reset() {\n    // Update the slides.\n    this._saveDomElements();\n\n    // Remove old paddles + pagination.\n    this._removePaddles();\n    this._removePagination();\n\n    this._setA11yAttributes();\n\n    // Re-render paddles and pagination.\n    this._renderPaddles();\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    // Update slide indices now that there's a new slide.\n    this._setSlideIndices();\n\n    // Go to the slide it was at before.\n    const selected = this.getSelectedIndex();\n    this.setSelectedIndex(0, true);\n\n    // Try going back to the previous one.\n    this.setSelectedIndex(selected, true);\n\n    // Set neighbors slides for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  }\n\n  /**\n   * Retreives the cached carousel wrapper element.\n   * @return {Element}\n   */\n  getWrapper() {\n    return this._slideContainerParentEl;\n  }\n\n  /**\n   * Retreives the cached carousel element.\n   * @return {Element}\n   */\n  getCarouselElement() {\n    return this._carouselEl;\n  }\n\n  /**\n   * Returns the array of slides in the carousel.\n   * @return {!Array.<!Element>} The slides array.\n   */\n  getSlides() {\n    return this._slides;\n  }\n\n  /**\n   * Get the slide element at the given index.\n   * @param {number} index The logical index of the slide you want.\n   * @return {Element} The slide element.\n   */\n  getSlide(index) {\n    return this.getSlides()[index];\n  }\n\n  /**\n   * Get the index of the currently active slide.\n   * @return {number} Index of the current slide.\n   */\n  getSelectedIndex() {\n    return this._selectedIndex;\n  }\n\n  /**\n   * Translates the original index to the current DOM index.\n   * @param {number} logicalIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getDomIndex(logicalIndex) {\n    return this.getSlideIndices().indexOf(logicalIndex);\n  }\n\n  /**\n   * Translates the DOM index to the original logical index.\n   * @param {number} domIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n  _getLogicalIndex(domIndex) {\n    return this.getSlideIndices()[domIndex];\n  }\n\n  /**\n   * Takes a logical index which could potentially be out of range and returns\n   * the logical index within range.\n   * @param {number} logicalIndex Logical index to make safe.\n   * @return {number} Safe logical index.\n   * @private\n   */\n  _getSafeIndex(logicalIndex) {\n    if (this.isIndexOutOfRange(logicalIndex)) {\n      if (this.options.isLooped) {\n        return this._getRelativeIndex(logicalIndex, 0);\n      }\n      return this.clampIndexToSlides(logicalIndex);\n    }\n    return logicalIndex;\n  }\n\n  /**\n   * Calculates the offset index for a circular list.\n   * @param {number} index Starting index.\n   * @param {number} displacement Offset from the starting index. Can be negative\n   *     or positive. For example, -2 or 2.\n   * @param {number} length Length of the list.\n   * @return {number} The index of the relative displacement, wrapping around\n   *     the end of the list to the start when the displacement is larger than\n   *     what's left in the list.\n   */\n  _getRelativeIndex(index, displacment) {\n    return math.wrapAroundList(index, displacment, this._slides.length);\n  }\n\n  /**\n   * @return {boolean} Whether a given index is out of range of the carousel.\n   */\n  isIndexOutOfRange(index) {\n    return index <= -1 || index >= this._slides.length;\n  }\n\n  clampIndexToSlides(index) {\n    return math.clamp(index, 0, this._slides.length - 1);\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the first slide.\n   */\n  isFirstSlide() {\n    return this.getSelectedIndex() === 0;\n  }\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the last slide.\n   */\n  isLastSlide() {\n    return this.getSelectedIndex() === this._slides.length - 1;\n  }\n\n  /**\n   * Generates the array which will follow the DOM order of the slides in their\n   * container and saves it.\n   * @private\n   */\n  _setSlideIndices() {\n    this._slideIndices = new Array(this._slides.length);\n\n    for (let i = 0, len = this._slides.length; i < len; i++) {\n      this._slideIndices[i] = i;\n    }\n  }\n\n  /** @return {!Array.<!number>} The slide indices array. */\n  getSlideIndices() {\n    return this._slideIndices;\n  }\n\n  /**\n   * Retrieves the slide children.\n   * @param {Element=} optSlide Slide to look within.\n   * @return {Array.<Element>} NodeList of slide children.\n   * @private\n   */\n  _getSlideChildren(optSlide) {\n    return this.getElementsByClass(Carousel.Classes.SLIDE_CHILD, optSlide);\n  }\n\n  /**\n   * Modifieds the _slideIndices array to represent the DOM order of the slides\n   * within their container.\n   * @param {number} currentValue The value to be moved. This is the same as the\n   *     logical index.\n   * @param {number} toIndex The location to move it to in the array. It will be\n   *     clamped between zero and one less than the length of the array. This is\n   *     also referred to as the DOM index.\n   * @private\n   */\n  _moveIndex(currentValue, toIndex) {\n    const clampedIndex = this.clampIndexToSlides(toIndex);\n    const fromIndex = this._getDomIndex(currentValue);\n    const arr = this._slideIndices;\n\n    // Array moveIndex.\n    arr.splice(clampedIndex, 0, arr.splice(fromIndex, 1)[0]);\n  }\n\n  /**\n   * Swaps positions of two logical indices in the slide indices array.\n   * @param {number} logIndex1 First logical index which will be swappeed.\n   * @param {number} logIndex2 Second logical index to be swapped.\n   * @private\n   */\n  _swapIndexes(logIndex1, logIndex2) {\n    const domIndexOfLogicalIndex1 = this._getDomIndex(logIndex1);\n    this._slideIndices[domIndexOfLogicalIndex1] = -1;\n    this._slideIndices[this._getDomIndex(logIndex2)] = logIndex1;\n    this._slideIndices[domIndexOfLogicalIndex1] = logIndex2;\n  }\n\n  /**\n   * Gets the slide positions (offsets from the left|top) array.\n   * @param {Array.<Element>} slideSet the slides array.\n   * @return {Array.<number>} array of slide positions.\n   * @private\n   */\n  _getPositions(slideSet) {\n    const bounds = this.getWrapper().getBoundingClientRect()[this._posAttr];\n    return slideSet.map(el => el.getBoundingClientRect()[this._posAttr] - bounds);\n  }\n\n  /**\n   * Enable or disable dragging.\n   * @param {boolean} enabled Whether it should be draggable.\n   * @private\n   */\n  _setDraggableEnabled(enabled) {\n    if (this.draggable) {\n      this.draggable.isEnabled = enabled;\n    } else {\n      this.pointer.isEnabled = enabled;\n    }\n  }\n\n  /**\n   * Enable or disable dragging of the carousel.\n   * @param {boolean} isDraggable Whether it should be draggable.\n   */\n  setDraggable(isDraggable) {\n    this._isDraggable = isDraggable;\n    this._setDraggableEnabled(isDraggable);\n  }\n\n  /**\n   * Public method which returns the enabled state.\n   * @return {boolean}\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  /**\n   * Toggle the enabled/disabled state of the carousel. When it's disabled, it\n   * will not be able to navigate slides.\n   * @param {boolean} enabled Whether to enable or disable.\n   */\n  set isEnabled(enabled) {\n    this._isEnabled = enabled;\n    this._setDraggableEnabled(enabled);\n  }\n\n  /**\n   * Gets the adjusted position.\n   * @param {Element} destinationSlide The slide the carousel is headed to.\n   * @return {number} The position it is.\n   * @private\n   */\n  _getNewPosition(destinationSlide) {\n    // Destination position.\n    let destinationPosition = destinationSlide[this._offsetPosition];\n\n    // Width or height of the carousel element.\n    const carouselSize = style.getSize(this.getCarouselElement())[this._dimensionAttr];\n\n    if (this.options.isCentered) {\n      const destinationSize = style.getSize(destinationSlide)[this._dimensionAttr];\n      const wrapperSize = style.getSize(this.getWrapper())[this._dimensionAttr];\n      this._startEdge = (wrapperSize - destinationSize) / 2;\n      destinationPosition -= this._startEdge;\n    }\n\n    let position = destinationPosition / carouselSize;\n\n    if (this._hasSlideChildren && this.isLastSlide()) {\n      // Adjust the position again if there are slide children in the last slide.\n      position = this._getPositionForSlideChildren(destinationSlide,\n        destinationPosition, carouselSize);\n    }\n\n    return position;\n  }\n\n  /**\n   * Adjust the destination position again if there are slide children.\n   * @param {Element} destinationSlide Slide element.\n   * @param {number} destinationPosition Where the slide would initially go.\n   * @param {number} carouselSize Width or height of the carousel element.\n   * @return {number} New destination position.\n   * @private\n   */\n  _getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize) {\n    // Size of the combined width/height + margins of the slide children\n    // within the destination slide.\n    const childrenSum = style.getElementsSize(\n      this._getSlideChildren(destinationSlide), this._dimensionAttr);\n\n    // width|height of the carousel slide.\n    const slideSize = style.getSize(destinationSlide)[this._dimensionAttr];\n\n    // The destination position minus the empty space in the next slide in px.\n    const newPosition = destinationPosition - (slideSize - childrenSum);\n\n    // Calculate the percentage from the pixel value.\n    return newPosition / carouselSize;\n  }\n\n  /**\n   * Returns the translated position based on carousel direction.\n   * @param {string} pos The position (eg \"25%\").\n   * @return {string} the css value for transform.\n   * @private\n   */\n  _getCssPosition(pos) {\n    return 'translate' + this._translateAxis + '(' + pos + ')';\n  }\n\n  /** @private */\n  _setSlidesToLogicalOrder() {\n    const frag = document.createDocumentFragment();\n\n    this._slides.forEach(frag.appendChild, frag);\n\n    this._carouselEl.appendChild(frag);\n\n    // Reset the slide indices array.\n    this._setSlideIndices();\n  }\n\n  /**\n   * If this is a jumped carousel, prepare the slides for the jump by swapping\n   * elements out and setting the `isJumped` option.\n   * @param {number} toDomIndex Index of the slide the carousel is jumping to.\n   * @return {number} If this function changed the order the slides, it returns\n   *     the new DOM index the carousel is going to. Otherwise it returns the\n   *     DOM index parameter it was given.\n   * @private\n   */\n  _setNeighborSlidesForJump(toDomIndex) {\n    const toLogicalIndex = this._getLogicalIndex(toDomIndex);\n    const currentLogicalIndex = this._getLogicalIndex(this.domIndex);\n\n    this._isJumped = true;\n\n    // Where to move the slide to. Next to the current index.\n    const destinationDomIndex = toLogicalIndex > currentLogicalIndex ?\n      this.domIndex + 1 :\n      this.domIndex - 1;\n\n    // Swap indices.\n    // Swap destination slide with current slide at the destination.\n    this._swapSlides(toLogicalIndex, this._getLogicalIndex(destinationDomIndex));\n\n    // Return the dom index the carousel is actually going to.\n    return destinationDomIndex;\n  }\n\n  /**\n   * Swap indices and DOM elements.\n   * @param {number} index1 Logical index 1.\n   * @param {number} index2 Logical index 2.\n   * @private\n   */\n  _swapSlides(index1, index2) {\n    this._swapIndexes(index1, index2);\n    dom.swapElements(this.getSlide(index1), this.getSlide(index2));\n  }\n\n  /**\n   * This function initializes the slideshow functionality for the\n   * carousel. It sets an interval for the slideshow to continue animate\n   * based on the option slideshowSpeed.\n   */\n  startSlideshow() {\n    // Create the timer if it doesn't already exist.\n    if (!this._timer) {\n      this._timer = new Timer(this._slideshowTimerExpired.bind(this),\n        this.options.slideshowSpeed, true);\n    }\n\n    this._timer.start();\n  }\n\n  /**\n   * A simple method which pauses the _timer\n   * once thats paused the slideshow will stop ticking.\n   * Can be re-initialzed by running `startSlideshow()`\n   */\n  pauseSlideshow() {\n    if (this._isSlideshowPlaying()) {\n      this._timer.stop();\n    }\n  }\n\n  /**\n   * Whether the slideshow timer exists and is currently ticking.\n   * @return {boolean}\n   * @private\n   */\n  _isSlideshowPlaying() {\n    return !!this._timer && this._timer.isTicking;\n  }\n\n  // getNthSibling returns null if it cannot find the nth sibling,\n  // but if `null` is used in `insertBefore`, it will append the element\n  // to the end.\n  getInnocentNeighbor(iterator, isNext) {\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    return isNext ?\n      dom.getNthSibling(currentSlideEl, iterator + 1) :\n      dom.getNthSibling(currentSlideEl, iterator, false) ||\n      dom.getFirstElementChild(this._carouselEl);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNeighborInsertionIndex(iterator, isNext, currentDomIndex) {\n    return isNext ?\n      currentDomIndex + iterator + 1 :\n      currentDomIndex - iterator;\n  }\n\n  /**\n   *\n   * @param {number} iterator Neighbor index.\n   * @param {number} relativePos Neighbor index relative to the current index.\n   * @param {boolean} isNext Whether to move the slide next or previous.\n   * @private\n   */\n  _setNeighborSlide(iterator, relativePos, isNext) {\n    const index = this.getSelectedIndex();\n    const indices = this.getSlideIndices();\n\n    // Previous calls to set neighbor slide may have changed the DOM, so\n    // don't rely on stored variables.\n    const currentDomIndex = this._getDomIndex(index);\n\n    // Index of the future neighbor relative to the original DOM order.\n    const logicalNeighborIndex = this._getRelativeIndex(index, relativePos);\n\n    // Do the slides need to be rearranged? Check the current indices to see\n    // if the new neighbors are already there.\n    if (indices[currentDomIndex + relativePos] !== logicalNeighborIndex) {\n      // The slide to insert the new neighbor before.\n      const innocentNeighbor = this.getInnocentNeighbor(iterator, isNext);\n      const insertionIndex = this.getNeighborInsertionIndex(iterator, isNext, currentDomIndex);\n      const neighborEl = this.getSlide(logicalNeighborIndex);\n\n      // Move the neighbor's index to be a neighbor to the current dom index.\n      this._moveIndex(logicalNeighborIndex, insertionIndex);\n      this._carouselEl.insertBefore(neighborEl, innocentNeighbor);\n    }\n  }\n\n  /**\n   * This function makes sure that looped carousels always have a neighbor to\n   * go to. It repositions the viewport if it has to move slides around.\n   * @private\n   */\n  _setNeighborSlides() {\n    let i;\n\n    // Set the left neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, -(i + 1), false);\n    }\n\n    // Set the right neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, i + 1, true);\n    }\n  }\n\n  /**\n   * Reset the carousel back to the currently selected slide without animation.\n   */\n  _snapToCurrentSlide() {\n    this.goToSlide(this._getDomIndex(this.getSelectedIndex()), true);\n  }\n\n  /**\n   * Determine if the distance between current and destination slides is more\n   * than one slide. If it's not, there is no need to \"jump\".\n   * @param {number} domIndex DOM index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating.\n   * @return {number} DOM index of the slide to go to because moving slides\n   *     around to \"jump\" them will causes indices to change.\n   */\n  _maybeSetJumpedSlides(domIndex, noAnimation) {\n    // Determine if the distance between current and destination slides\n    // is more than one slide. If it's not, there's no need to \"jump\".\n    if (this.options.isJumped && !noAnimation && Math.abs(this.domIndex - domIndex) > 1) {\n      return this._setNeighborSlidesForJump(domIndex);\n    }\n    return domIndex;\n  }\n\n  /**\n   * Determine whether or not the carousel can navigate in its current condition.\n   * @param {number} domIndex Dom index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating there.\n   * @return {boolean}\n   */\n  _canNavigate(domIndex, noAnimation) {\n    const isSameSlideWithAnimation = domIndex === this.domIndex && !noAnimation;\n\n    // Whether the carousel would be able to move.\n    const isOffset = this.hasDragged || this._isOffset;\n\n    // 1) Whether the carousel is enabled.\n    // 2) The index is out of range and the carousel isn't set to loop. Silently\n    // exit here instead of throwing errors everywhere.\n    // 3) Trying to go to the slide it's already on with a transition and no\n    // dragging has occured or the carousel is not offset.\n    return !(\n      (!this._isEnabled) ||\n      (!this.options.isLooped && this.isIndexOutOfRange(domIndex)) ||\n      (isSameSlideWithAnimation && !isOffset));\n  }\n\n  _toNewSlide() {\n    // Set flag meaning the carousel is waiting for a transition end.\n    this.isTransitioning = true;\n\n    // Fire event saying the slide started to transition.\n    this._emitEvent(new CarouselEvent(\n      Carousel.EventType.SLIDE_START,\n      this,\n      this._getLogicalIndex(this.lastDomIndex),\n      this._getLogicalIndex(this.domIndex)));\n  }\n\n  /**\n   * Uses Css transforms to move the carousel to a new position.\n   * @param {string} position The percentage value.\n   * @param {boolean} noAnimation Whether to move with animation or not.\n   * @private\n   */\n  _moveToPosition(position, noAnimation) {\n    // Set transform.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = this._getCssPosition(position);\n\n    // Set transition speed to zero so that it happens instantly.\n    if (noAnimation) {\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n\n      // Listen for transitionend if it will animate.\n    } else {\n      // Set transition speed.\n      this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] =\n        this.options.animationSpeed + 'ms';\n\n      // This is used as a backup to the transitionend event, which sometimes\n      // doesn't fire on iOS 7 Safari when the carousel has only been dragged a\n      // few pixels. It's set to go off ~2 frames after the transition end event\n      // should have occurred.\n      this._transitionId = animation.onTransitionEnd(this._carouselEl,\n        this._transitionDone,\n        this,\n        OdoDevice.Dom.TRANSFORM,\n        this.options.animationSpeed + Carousel.TRANSITION_END_WAIT);\n\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Calculates the offset of the carousel relative to the current slide.\n   * @return {number}\n   */\n  _getCarouselOffset() {\n    const matrix = getComputedStyle(this._carouselEl)[OdoDevice.Dom.TRANSFORM];\n\n    // Round to 1 decimal place because the `_startEdge` can be a decimal.\n    const translate = Math.round(\n      getTranslate(matrix)[this._translateAxis.toLowerCase()] * 10,\n    ) / 10;\n\n    const slideOffset = this.getSlide(this.getSelectedIndex())[this._offsetPosition];\n    return slideOffset + translate;\n  }\n\n  /**\n   * If the carousel is waiting for a transition to finish (going to a slide),\n   * but the user tells it to navigate again, the previous listener for the\n   * transition end event needs to be canceled. This allows the user to quickly\n   * click through the carousel without waiting for each navigation to finish.\n   *\n   * For jumped and looped carousels, the carousel element needs to be\n   * repositioned because setting neighbor slides will cause the elements to\n   * shift within the main carousel element. The current offset relative to\n   * the current slide is saved before moving any slide elements, then the slide\n   * elements are moved, and finally the carousel is set to appear as if the\n   * elements never moved.\n   */\n  _cancelMovement() {\n    if (!this.isTransitioning) {\n      return;\n    }\n\n    this.isTransitioning = false;\n    animation.cancelTransitionEnd(this._transitionId);\n\n    // Fading carousels do not need to reposition themselves.\n    if (this.options.isFade) {\n      return;\n    }\n\n    // Save the offset relative to the current slide before slides are moved.\n    const carouselSize = style.getSize(this.getCarouselElement())[this._dimensionAttr];\n    const offset = this._getCarouselOffset();\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    // Now that the current slide has potentially moved in the DOM, update the\n    // carousel's offset.\n    const currentSlideEl = this.getSlide(this.getSelectedIndex());\n    const newSlideOffset = currentSlideEl[this._offsetPosition];\n    const position = (newSlideOffset - offset) / carouselSize;\n\n    // Setting the position here stops the browser from transitioning to the\n    // previous position, allowing the user to \"catch\" the carousel mid-nav.\n    this._moveToPosition((position * -100) + '%', true);\n    this.draggable.update();\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  fadeToSlide(domIndex, optNoAnimation) {\n    // Get next and previous slides.\n    const nextSlide = this.getSlide(domIndex, true);\n    const previousSlide = this.getSlide(this.domIndex, true);\n\n    // Listen for transitionend if it will animate.\n    if (!optNoAnimation) {\n      // Going to a new slide, wait for callback.\n      this._transitionId = animation.onTransitionEnd(nextSlide, this._transitionDone, this);\n    }\n\n    // Show next slide. Put the previous behind the next.\n    nextSlide.classList.add(Carousel.Classes.VISIBLE);\n\n    if (previousSlide !== nextSlide) {\n      previousSlide.classList.add(Carousel.Classes.BEHIND);\n\n      // Delay the previous slide fading out by the specified percentage.\n      // The crossfade amount is between 0 and 1. A value of 1 means that both slides\n      // will fade at the same time. A crossfade of zero means the previous slide\n      // will wait until the next slide has completely faded in before it fades out.\n      setTimeout(() => {\n        previousSlide.classList.remove(Carousel.Classes.VISIBLE);\n      }, this._crossfadeTimeout);\n    }\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = domIndex;\n\n    // Emit event for slide start.\n    if (!optNoAnimation) {\n      this._toNewSlide();\n    }\n  }\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean=} optNoAnimation Whether going to the slide should animate.\n   * @protected\n   */\n  goToSlide(domIndex, optNoAnimation) {\n    // Get the destion slide element from the current DOM order.\n    const destinationSlide = this.getSlide(this._getLogicalIndex(domIndex));\n\n    // If the carousel skips inbetween slides, reposition them.\n    // DOM index is reassinged here because if the slides are repositioned,\n    // the DOM index of the carousel changes.\n    const updatedDomIndex = this._maybeSetJumpedSlides(domIndex, optNoAnimation);\n\n    // The position the container will go to.\n    const adjustedPosition = (this._getNewPosition(destinationSlide) * -100) + '%';\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = updatedDomIndex;\n\n    // Set the css styles to move the carousel element. This also dispatches\n    // the slide start event if the carousel element will move with animation.\n    this._moveToPosition(adjustedPosition, optNoAnimation);\n  }\n\n  /**\n   * Helper function for going to a given index. This method should be used\n   * instead of the private one to abstract the DOM order stuff.\n   * @param {number} index The logical, zero based index of the slide you wish\n   *     the carousel to go to.\n   * @param {boolean=} optNoAnimation Optional skip the animation in goToSlide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  setSelectedIndex(index, optNoAnimation) {\n    let domIndex = this._getDomIndex(index);\n    const canNavigate = this._canNavigate(domIndex, optNoAnimation);\n\n    // Will go the the give slide.\n    if (canNavigate) {\n      // If the event's default action was prevented, return false.\n      if (this._emitEvent(new CarouselEvent(Carousel.EventType.WILL_NAVIGATE, this))) {\n        return false;\n      }\n\n      this._cancelMovement();\n\n      this._selectedIndex = this._getSafeIndex(index);\n\n      // Convert new safe logical index to a DOM index.\n      domIndex = this._getDomIndex(this._selectedIndex);\n\n      // Set new classes on the slide elements. This is also where toggling\n      // paddles and pagination should go.\n      this._setSlidesState();\n      this._setPaddleState();\n      this._setPaginationState();\n      if (this.options.isFade) {\n        this.fadeToSlide(domIndex, optNoAnimation);\n      } else {\n        this.goToSlide(domIndex, optNoAnimation);\n      }\n    }\n\n    // Otherwise, it will not go to the give slide due to unmet conditions.\n    return canNavigate;\n  }\n\n  /**\n   * Find the nearest slide, and move the carousel to that.\n   * @param {boolean} isNext Whether it should go to the nearest slide, but\n   *     only in the next direction. False means it should go previous and\n   *     anything not true or false will go to the nearest slide regardless\n   *     of direction.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNearestSlide(isNext) {\n    // Gets positions relative to the wrapper element of each slide.\n    const positions = this._getPositions(this.getSlides());\n\n    // Current position (the left side of the carousel wrapper)\n    // Gets the closest value in the array to the given value.\n    // Index of the closest value.\n    let logicalIndex = positions.indexOf(array.closest(positions, this._startEdge));\n\n    // When going to a next or previous slide, the closest index could\n    // still be the one that's currently selected, but the carousel should\n    // still move next/previous because it has enough velocity.\n    if (logicalIndex === this.getSelectedIndex()) {\n      if (isNext === true) {\n        logicalIndex = this._getSafeIndex(logicalIndex + 1);\n      } else if (isNext === false) {\n        logicalIndex = this._getSafeIndex(logicalIndex - 1);\n      }\n    }\n\n    return this.setSelectedIndex(logicalIndex);\n  }\n\n  /**\n   * Go to the next slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToNextSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() + 1);\n  }\n\n  /**\n   * Go to the previous slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n  goToPreviousSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() - 1);\n  }\n\n  /**\n   * Sets the past, previous, active, next, and future classes to the appropriate\n   * slides.\n   * @private\n   */\n  _setSlidesState() {\n    const selectedIndex = this.getSelectedIndex();\n    const past = this._getSafeIndex(selectedIndex - 2);\n    const previous = this._getSafeIndex(selectedIndex - 1);\n    const next = this._getSafeIndex(selectedIndex + 1);\n    const future = this._getSafeIndex(selectedIndex + 2);\n\n    // This works because the _slides array does not mimic the DOM order.\n    this.getSlides().forEach((slide, i) => {\n      const isActive = i === selectedIndex;\n\n      toggleFocusability(slide, isActive);\n\n      slide.setAttribute('aria-hidden', !isActive);\n\n      // Active slide.\n      slide.classList.toggle(Carousel.Classes.ACTIVE_SLIDE, isActive);\n\n      // Previous previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PAST_SLIDE,\n        i === past && selectedIndex !== past && previous !== past);\n\n      // Previous slide.\n      slide.classList.toggle(\n        Carousel.Classes.PREVIOUS_SLIDE,\n        i === previous && selectedIndex !== previous);\n\n      // Next slide.\n      slide.classList.toggle(\n        Carousel.Classes.NEXT_SLIDE,\n        i === next && selectedIndex !== next);\n\n      // Next next slide.\n      slide.classList.toggle(\n        Carousel.Classes.FUTURE_SLIDE,\n        i === future && selectedIndex !== future && next !== future);\n    });\n  }\n\n  _setPaginationState() {\n    if (this.options.pagination) {\n      const selectedIndex = this.getSelectedIndex();\n      this._paginationDots.forEach(({ dot, i, i2 }) => {\n        const selected = selectedIndex === i || selectedIndex === i2;\n        dot.classList.toggle(Carousel.Classes.PAGINATION_DOT_SELECTED, selected);\n        dot.setAttribute('aria-selected', selected);\n      });\n    }\n  }\n\n  _setPaddleState() {\n    const notLooped = !this.options.isLooped;\n    if (notLooped && this._paddlePrevious) {\n      const first = this.isFirstSlide();\n      this._paddlePrevious.classList.toggle(Carousel.Classes.PADDLE_DISABLED, first);\n      this._paddlePrevious.setAttribute('aria-disabled', first);\n    }\n\n    if (notLooped && this._paddleNext) {\n      const last = this.isLastSlide();\n      this._paddleNext.classList.toggle(Carousel.Classes.PADDLE_DISABLED, last);\n      this._paddleNext.setAttribute('aria-disabled', last);\n    }\n  }\n\n  /**\n   * Callback for when the slideshow timer expires.\n   * @private\n   */\n  _slideshowTimerExpired() {\n    // Pause the timer if it's at the end.\n    if (!this.options.isLooped && this.isLastSlide()) {\n      this.pauseSlideshow();\n    } else {\n      this.goToNextSlide();\n    }\n  }\n\n  _transitionDone() {\n    const from = this._getLogicalIndex(this.lastDomIndex);\n    const to = this._getLogicalIndex(this.domIndex);\n\n    // Needs to come before setting neighbor slides.\n    this.isTransitioning = false;\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    // Neighboring slides must be set after each transition for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    if (this._isJumped || this._isSlidingLooped) {\n      this._snapToCurrentSlide();\n    }\n\n    if (this.options.isFade) {\n      this.getSlide(from).classList.remove(Carousel.Classes.BEHIND);\n    }\n\n    // No longer jumped.\n    this._isJumped = false;\n\n    // Dispatch slide end event.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_END, this, from, to));\n  }\n\n  /**\n   * Received the pointer end event.\n   * @param {PointerEvent} pointerEvent Pointer event object.\n   */\n  _handlePointerEnd(pointerEvent) {\n    if (this.pointer.hasVelocity(pointerEvent.velocity)) {\n      if (pointerEvent.direction === OdoPointer.Direction.RIGHT) {\n        this.goToPreviousSlide();\n      } else if (pointerEvent.direction === OdoPointer.Direction.LEFT) {\n        this.goToNextSlide();\n      }\n    }\n  }\n\n  /**\n   * The click listener is bound to the main element. Inside the handler, the target\n   * of the click is tested and if it is a pagination dot or paddle, navigation\n   * will be started.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleClick(evt) {\n    const target = evt.target;\n    let willNavigate = false;\n\n    // Determine what was clicked.\n    const dot = target.closest('.' + Carousel.Classes.PAGINATION_DOT);\n    const prev = target.closest('.' + Carousel.Classes.PADDLE_PREV);\n    const next = target.closest('.' + Carousel.Classes.PADDLE_NEXT);\n\n    // Navigation dot.\n    if (dot) {\n      willNavigate = true;\n      this.setSelectedIndex(parseInt(dot.getAttribute('data-index'), 10));\n\n    // Left paddle or child of left paddle.\n    } else if (prev) {\n      willNavigate = true;\n      this.goToPreviousSlide();\n\n    // Right paddle or child of right paddle.\n    } else if (next) {\n      willNavigate = true;\n      this.goToNextSlide();\n\n    // If the carousel slides have links in them, some browsers (Firefox), will\n    // emit the click event even after a drag if the mouse is still on the\n    // clickable element.\n    } else if (this.isTransitioning) {\n      evt.preventDefault();\n    }\n\n    if (willNavigate) {\n      evt.preventDefault();\n\n      // Pause slideshow if it's playing.\n      this.pauseSlideshow();\n    }\n  }\n\n  /**\n   * Stop animations that were ongoing when you started to drag.\n   * @private\n   */\n  _handleDragStart() {\n    this.pauseSlideshow();\n    this._cancelMovement();\n\n    // Remove transition while dragging.\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION_DURATION] = '0ms';\n  }\n\n  /**\n   * Pointer move event. Set a friction value if on the first/last slide and\n   * going towards the edge.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragMove({ delta }) {\n    this.hasDragged = this.isVertical ?\n      Math.abs(delta.y) > 0 :\n      Math.abs(delta.x) > 0;\n    if (!this.options.isLooped) {\n      const friction = this._isMovingTowardsEdge(delta.x, delta.y) ? 0.4 : 1;\n      this.draggable.friction = friction;\n    }\n  }\n\n  /**\n   * Depending on how fast you were dragging, either proceed to an adjacent\n   * slide or reset position to the nearest one.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    this.draggable.friction = 1;\n    this.navigateAfterDrag(evt.velocity, evt.axisDirection, evt.didMoveOnAxis);\n    this.hasDragged = false;\n    this._isOffset = false;\n  }\n\n  _shouldGoToPrevious(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isFirstSlide()) && (\n      direction === OdoPointer.Direction.RIGHT ||\n      direction === OdoPointer.Direction.DOWN);\n  }\n\n  _shouldGoToNext(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isLastSlide()) && (\n      direction === OdoPointer.Direction.LEFT ||\n      direction === OdoPointer.Direction.UP);\n  }\n\n  navigateAfterDrag(velocity, direction, didMoveOnAxis) {\n    const hasVelocity = this.hasDragged && this.draggable.pointer.hasVelocity(velocity);\n\n    // If dragging has not occurred, the user simply clicked on the carousel.\n    // If the user is quickly navigating through the carousel, then clicks on\n    // it, the movement will be canceled, but it wouldn't go anywhere because it\n    // appears to be going to the same slide. Determine if the carousel is still\n    // between slides (offset). If it is, it needs to go to the nearest slide.\n    if (!this.hasDragged) {\n      this._isOffset =\n        Math.abs(Math.round(this._getCarouselOffset())) > Math.round(this._startEdge);\n    }\n\n    // Previous.\n    if (this._shouldGoToPrevious(hasVelocity, direction)) {\n      this.goToNearestSlide(false);\n\n    // Next.\n    } else if (this._shouldGoToNext(hasVelocity, direction)) {\n      this.goToNearestSlide(true);\n\n    // Not enough velocity, go to the nearest slide.\n    // The distance must at least be 1, otherwise gotoSlide creates an event\n    // listener for moving the element by zero pixels and the transition end\n    // event doesn't fire.\n    } else if (didMoveOnAxis || this._isOffset) {\n      this.goToNearestSlide();\n    }\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {CarouselEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Whether the carousel is being dragged towards an edge.\n   * @param {number} deltaX Change in x during drag.\n   * @param {number} deltaY Change in y during drag.\n   * @return {boolean}\n   * @private\n   */\n  _isMovingTowardsEdge(deltaX, deltaY) {\n    const toStartEdge = this.isVertical ?\n      deltaY > 0 :\n      deltaX > 0;\n    const toEndEdge = this.isVertical ?\n      deltaY < 0 :\n      deltaX < 0;\n\n    return (this.isFirstSlide() && toStartEdge) || (this.isLastSlide() && toEndEdge);\n  }\n\n  /**\n   * Remove event listeners, DOM references, inline styles, class names, paddles,\n   * and pagination added by Carousel.\n   */\n  dispose() {\n    if (this._timer) {\n      this._timer.dispose();\n    }\n\n    this._removeA11yAttributes();\n    this._removePaddles();\n    this._removePagination();\n\n    // Reset container styles.\n    this._carouselEl.style[OdoDevice.Dom.TRANSFORM] = '';\n    this._carouselEl.style[OdoDevice.Dom.TRANSITION] = '';\n\n    if (this.options.isFade) {\n      this.pointer.off(OdoPointer.EventType.END, this._onPointerEnd);\n      this.pointer.dispose();\n\n      this.getSlides().forEach((slide) => {\n        slide.style[OdoDevice.Dom.TRANSITION] = '';\n      });\n    } else {\n      this.draggable.off(OdoDraggable.EventType.START, this._onDragStart);\n      this.draggable.off(OdoDraggable.EventType.MOVE, this._onDragMove);\n      this.draggable.off(OdoDraggable.EventType.END, this._onDragEnd);\n\n      this.draggable.dispose();\n    }\n\n    this.element.removeEventListener('click', this._onClick);\n\n    this._slides.forEach((slide) => {\n      slide.classList.remove(\n        Carousel.Classes.PAST_SLIDE,\n        Carousel.Classes.PREVIOUS_SLIDE,\n        Carousel.Classes.ACTIVE_SLIDE,\n        Carousel.Classes.NEXT_SLIDE,\n        Carousel.Classes.FUTURE_SLIDE,\n        Carousel.Classes.VISIBLE,\n        Carousel.Classes.BEHIND,\n      );\n    });\n\n    // When the carousel is bidirectional, it has cloned the first two slides\n    // and added them to the carousel element. Remove the clones.\n    if (this._isBidirectional) {\n      this._carouselEl.removeChild(this._slides[2]);\n      this._carouselEl.removeChild(this._slides[3]);\n    }\n\n    // Null out DOM refs.\n    this.element = null;\n    this._slideContainerParentEl = null;\n    this._carouselEl = null;\n    this._paddlePrevious = null;\n    this._paddleNext = null;\n    this._paginationDots = null;\n    this.draggable = null;\n    this.pointer = null;\n    this._slides.length = 0;\n  }\n\n  /**\n   * Because Object.assign only does a shallow merge, merge the template option\n   * first and then overwrite the main Object.assign result.\n   * @param {Object} options Options object.\n   * @return {Object} Merged options object with defaults.\n   */\n  static getOptions(options) {\n    const templates = Object.assign({}, Carousel.Defaults.template, options.template);\n    const opts = Object.assign({}, Carousel.Defaults, options);\n    opts.template = templates;\n    return opts;\n  }\n}\n\nObject.assign(Carousel, settings);\n\nCarousel.template = templateEngine;\n\nexport default Carousel;\n"],"names":["CarouselEvent","type","carousel","optFrom","optTo","target","element","from","to","hasSlideChanged","defaultPrevented","preventDefault","template","str","data","replace","match","names","split","obj","property","length","i","call","undefined","getTranslate","array","parseFloat","count","uniqueId","toggleFocusability","parent","canFocus","focusableElements","elements","Array","querySelectorAll","matches","push","removeAttribute","tabIndex","Carousel","options","Element","TypeError","getOptions","isVertical","_isSlidingLooped","isLooped","isFade","domIndex","lastDomIndex","_selectedIndex","_slideContainerParentEl","_carouselEl","_slides","_isJumped","_isEnabled","_posAttr","_offsetPosition","string","capitalize","_dimensionAttr","_translateAxis","isTransitioning","_transitionId","_hasSlideChildren","_isDraggable","hasDragged","_isOffset","_timer","_crossfadeTimeout","animationSpeed","crossfadeAmount","_startEdge","draggable","pointer","_isBidirectional","resetSync","reset","decorate","getElementsByClass","className","context","getElementsByClassName","getElementByClass","_saveDomElements","_decorateBidirectionalCarousel","_setA11yAttributes","_renderPaddles","pagination","_renderPagination","_saveRenderedElements","_setSlideIndices","_decorateFadeCarousel","_decorateRegularCarousel","_onClick","_handleClick","bind","addEventListener","setSelectedIndex","_getSafeIndex","startIndex","_setNeighborSlides","_snapToCurrentSlide","style","OdoDevice","Dom","TRANSITION_PROPERTY","Css","TRANSFORM","TRANSITION_TIMING_FUNCTION","easing","_getSlideChildren","bindDragEvents","getSlides","forEach","slide","TRANSITION","classList","add","Classes","VISIBLE","bindSwipeEvents","getCarouselElement","appendChild","cloneNode","SLIDE","getWrapper","setAttribute","giveId","_removeA11yAttributes","WRAPPER","CAROUSEL_ELEMENT","_paddlePrevious","PADDLE_PREV","_paddleNext","PADDLE_NEXT","_paginationDots","PAGINATION_DOT","map","parseInt","dot","getAttribute","insertAdjacentHTML","_getNavPaddleHtml","_removePaddles","_removeByClass","PADDLES","parentNode","removeChild","getNavPaddleHtml","paddles","paddlePrev","paddlePrevInner","paddleNext","paddleNextInner","_getPaginationHtml","_removePagination","PAGINATION","getPaginationHtml","dots","_buildPaginationHtml","paginationDotSecondary","paginationDot","reduce","dotsHtml","arr","id","secondaryIndex","hidden","OdoDraggable","OdoPointer","Axis","Y","X","_onDragStart","_handleDragStart","_onDragMove","_handleDragMove","_onDragEnd","_handleDragEnd","on","EventType","START","MOVE","END","_onPointerEnd","_handlePointerEnd","addSlide","slideHtml","_setSlidesToLogicalOrder","selected","getSelectedIndex","getSlide","index","_getDomIndex","logicalIndex","getSlideIndices","indexOf","_getLogicalIndex","isIndexOutOfRange","_getRelativeIndex","clampIndexToSlides","displacment","math","wrapAroundList","clamp","isFirstSlide","isLastSlide","_slideIndices","len","optSlide","SLIDE_CHILD","_moveIndex","currentValue","toIndex","clampedIndex","fromIndex","splice","_swapIndexes","logIndex1","logIndex2","domIndexOfLogicalIndex1","_getPositions","slideSet","bounds","getBoundingClientRect","el","_setDraggableEnabled","enabled","isEnabled","setDraggable","isDraggable","_getNewPosition","destinationSlide","destinationPosition","carouselSize","getSize","isCentered","destinationSize","wrapperSize","position","_getPositionForSlideChildren","childrenSum","getElementsSize","slideSize","newPosition","_getCssPosition","pos","frag","document","createDocumentFragment","_setNeighborSlidesForJump","toDomIndex","toLogicalIndex","currentLogicalIndex","destinationDomIndex","_swapSlides","index1","index2","swapElements","startSlideshow","Timer","_slideshowTimerExpired","slideshowSpeed","start","pauseSlideshow","_isSlideshowPlaying","stop","isTicking","getInnocentNeighbor","iterator","isNext","currentSlideEl","dom","getNthSibling","getFirstElementChild","getNeighborInsertionIndex","currentDomIndex","_setNeighborSlide","relativePos","indices","logicalNeighborIndex","innocentNeighbor","insertionIndex","neighborEl","insertBefore","neighborCount","goToSlide","_maybeSetJumpedSlides","noAnimation","isJumped","Math","abs","_canNavigate","isSameSlideWithAnimation","isOffset","_toNewSlide","_emitEvent","SLIDE_START","_moveToPosition","TRANSITION_DURATION","animation","onTransitionEnd","_transitionDone","TRANSITION_END_WAIT","_getCarouselOffset","matrix","getComputedStyle","translate","round","toLowerCase","slideOffset","_cancelMovement","cancelTransitionEnd","offset","newSlideOffset","update","fadeToSlide","optNoAnimation","nextSlide","previousSlide","BEHIND","remove","updatedDomIndex","adjustedPosition","canNavigate","WILL_NAVIGATE","_setSlidesState","_setPaddleState","_setPaginationState","goToNearestSlide","positions","closest","goToNextSlide","goToPreviousSlide","selectedIndex","past","previous","next","future","isActive","toggle","ACTIVE_SLIDE","PAST_SLIDE","PREVIOUS_SLIDE","NEXT_SLIDE","FUTURE_SLIDE","i2","PAGINATION_DOT_SELECTED","notLooped","first","PADDLE_DISABLED","last","SLIDE_END","pointerEvent","hasVelocity","velocity","direction","Direction","RIGHT","LEFT","evt","willNavigate","prev","delta","y","x","friction","_isMovingTowardsEdge","navigateAfterDrag","axisDirection","didMoveOnAxis","_shouldGoToPrevious","DOWN","_shouldGoToNext","UP","event","emit","deltaX","deltaY","toStartEdge","toEndEdge","dispose","off","removeEventListener","templates","Object","assign","Defaults","opts","TinyEmitter","settings","templateEngine"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACMA;;;;;;;;;yBASQC,IAAZ,EAAkBC,QAAlB,EAA4BC,OAA5B,EAAqCC,KAArC,EAA4C;;;SACrCH,IAAL,GAAYA,IAAZ;;;SAGKI,MAAL,GAAcH,SAASI,OAAvB;;;SAGKC,IAAL,GAAYJ,OAAZ;;;SAGKK,EAAL,GAAUJ,KAAV;;;SAGKK,eAAL,GAAuBN,YAAYC,KAAnC;;;SAGKM,gBAAL,GAAwB,KAAxB;;;0BAGFC,2CAAiB;SACVD,gBAAL,GAAwB,IAAxB;;;;;;AC9BJ,eAAe;;;;;;aAMF;mBACM,0BADN;iBAEI,wBAFJ;eAGE;GATA;;;WAaJ;UACD,cADC;UAED,oBAFC;cAGG,wBAHH;aAIE,uBAJF;sBAKW,uBALX;;WAOA,qBAPA;kBAQO,6BARP;oBASS,+BATT;gBAUK,2BAVL;gBAWK,2BAXL;kBAYO,6BAZP;;aAcE,8BAdF;YAeC,6BAfD;;gBAiBK,0BAjBL;oBAkBS,8BAlBT;6BAmBkB,aAnBlB;;aAqBE,2BArBF;YAsBC,0BAtBD;iBAuBM,wBAvBN;iBAwBM,wBAxBN;qBAyBU,aAzBV;;iBA2BM;GAxCF;;YA2CH;gBACI,CADJ;gBAEI,KAFJ;cAGE,KAHF;cAIE,KAJF;YAKA,KALA;gBAMI,KANJ;mBAOO,CAPP;oBAQQ,IARR;oBASQ,GATR;qBAUS,KAVT;YAWA,0CAXA;gBAYI,KAZJ;sBAaU,IAbV;uBAcW,IAdX;cAeE;eACC,mEADD;kBAEI,kJAFJ;kBAGI,sJAHJ;uBAIS,qHAJT;uBAKS,+JALT;kBAMI,uEANJ;qBAOO,sMAPP;8BAQgB;;GAlEf;;uBAsEQ;CAtEvB;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,AAAe,SAASE,QAAT,CAAkBC,GAAlB,EAAuBC,IAAvB,EAA6B;;;;;;SAMnCD,IAAIE,OAAJ,CAAY,sBAAZ,EAAoC,UAACC,KAAD,EAAQH,GAAR,EAAgB;QACnDI,QAAQJ,IAAIK,KAAJ,CAAU,GAAV,CAAd;QACIC,MAAML,IAAV;QACIM,iBAAJ;;;QAGIH,MAAMI,MAAN,GAAe,CAAnB,EAAsB;iBACTF,GAAX;WACK,IAAIG,IAAI,CAAb,EAAgBA,IAAIL,MAAMI,MAA1B,EAAkCC,GAAlC,EAAuC;cAC/BF,QAAN;mBACWA,SAASH,MAAMK,CAAN,CAAT,KAAsBT,GAAjC;;;;KAJJ,MAQO;iBACMM,IAAIN,GAAJ,CAAX;;;;QAIE,OAAOO,QAAP,KAAoB,UAAxB,EAAoC;aAC3BA,SAASG,IAAT,CAAcJ,GAAd,CAAP;;;;QAIEC,aAAaI,SAAb,IAA0BJ,aAAa,IAAvC,IAA+CA,aAAaP,GAAhE,EAAqE;aAC5DO,QAAP;;;;WAIKP,GAAP;GA7BK,CAAP;;;AChCK,SAASY,YAAT,CAAsBZ,GAAtB,EAA2B;MAC1Ba,WAAQb,IAAIG,KAAJ,CAAU,aAAV,CAAd;SACO;OACFW,WAAWD,SAAM,CAAN,CAAX,CADE;OAEFC,WAAWD,SAAM,CAAN,CAAX;GAFL;;;AAMF,IAAIE,QAAQ,CAAZ;AACA,AAAO,SAASC,QAAT,GAAoB;WAChB,CAAT;0BACsBD,KAAtB;;;;;;;;;;;AAWF,AAAO,SAASE,kBAAT,CAA4BC,MAA5B,EAAoCC,QAApC,EAA8C;MAC7CC,oBAAoB,iEAA1B;MACMC,WAAWC,MAAM5B,IAAN,CAAWwB,OAAOK,gBAAP,CAAwBH,iBAAxB,CAAX,CAAjB;;;MAGIF,OAAOM,OAAP,CAAeJ,iBAAf,CAAJ,EAAuC;aAC5BK,IAAT,CAAcP,MAAd;;;OAGG,IAAIT,IAAIY,SAASb,MAAT,GAAkB,CAA/B,EAAkCC,KAAK,CAAvC,EAA0CA,GAA1C,EAA+C;QACzCU,QAAJ,EAAc;;;;eAIHV,CAAT,EAAYiB,eAAZ,CAA4B,UAA5B;KAJF,MAKO;eACIjB,CAAT,EAAYkB,QAAZ,GAAuB,CAAC,CAAxB;;;;;ACvCN;;;;;;;AAOA,IAmBMC;;;;;;;;;oBAOQnC,OAAZ,EAAmC;QAAdoC,OAAc,uEAAJ,EAAI;;;gDACjC,uBADiC;;QAG7B,EAAEpC,mBAAmBqC,OAArB,CAAJ,EAAmC;YAC3B,IAAIC,SAAJ,6CAAwDtC,OAAxD,OAAN;;;UAGGA,OAAL,GAAeA,OAAf;;;;;;UAMKoC,OAAL,GAAeD,SAASI,UAAT,CAAoBH,OAApB,CAAf;;;;;;;UAOKI,UAAL,GAAkB,MAAKJ,OAAL,CAAaI,UAA/B;;;;;;UAMKC,gBAAL,GAAwB,MAAKL,OAAL,CAAaM,QAAb,IAAyB,CAAC,MAAKN,OAAL,CAAaO,MAA/D;;;;;;;UAOKC,QAAL,GAAgB,CAAhB;;;;;;;UAOKC,YAAL,GAAoB,CAApB;;;;;;UAMKC,cAAL,GAAsB,CAAtB;;;;;;;UAOKC,uBAAL,GAA+B,IAA/B;;;;;;;;UAQKC,WAAL,GAAmB,IAAnB;;;;;;;UAOKC,OAAL,GAAe,EAAf;;;;;;;;;;UAUKC,SAAL,GAAiB,KAAjB;;;;;;;;UAQKC,UAAL,GAAkB,IAAlB;;;;;;;UAOKC,QAAL,GAAgB,MAAKZ,UAAL,GAAkB,KAAlB,GAA0B,MAA1C;;;;;;;UAOKa,eAAL,GAAuB,WAAWC,kBAAOC,UAAP,CAAkB,MAAKH,QAAvB,CAAlC;;;;;;;UAOKI,cAAL,GAAsB,MAAKhB,UAAL,GAAkB,QAAlB,GAA6B,OAAnD;;;;;;UAMKiB,cAAL,GAAsB,MAAKjB,UAAL,GAAkB,GAAlB,GAAwB,GAA9C;;;;;;;;;UASKkB,eAAL,GAAuB,KAAvB;;;;;;;UAOKC,aAAL,GAAqB,IAArB;;;;;;;;;UASKC,iBAAL,GAAyB,KAAzB;;;;;;;UAOKC,YAAL,GAAoB,IAApB;;;;;;;UAOKC,UAAL,GAAkB,KAAlB;;;;;;UAMKC,SAAL,GAAiB,KAAjB;;;;;;;UAOKC,MAAL,GAAc,IAAd;;;;;;;;UAQKC,iBAAL,GAAyB,MAAK7B,OAAL,CAAa8B,cAAb,GACpB,MAAK9B,OAAL,CAAa8B,cAAb,GAA8B,MAAK9B,OAAL,CAAa+B,eADhD;;;;;;;;UASKC,UAAL,GAAkB,CAAlB;;;;;;UAMKC,SAAL,GAAiB,IAAjB;;;;;;UAMKC,OAAL,GAAe,IAAf;;;;;;;;;;;;UAYKC,gBAAL,GAAwB,KAAxB;;;UAGKC,SAAL,GAAiB,MAAKC,KAAtB;;;UAGKC,QAAL;;;;;;;;;;;;;;qBAWFC,iDAAmBC,WAAmC;QAAxBC,OAAwB,uEAAd,KAAK7E,OAAS;;WAC7C6B,MAAM5B,IAAN,CAAW4E,QAAQC,sBAAR,CAA+BF,SAA/B,CAAX,CAAP;;;;;;;;;;;qBASFG,+CAAkBH,WAAWC,SAAS;WAC7B,KAAKF,kBAAL,CAAwBC,SAAxB,EAAmCC,OAAnC,EAA4C,CAA5C,KAAkD,IAAzD;;;;;;;;qBAMFH,+BAAW;SACJM,gBAAL;;;;QAII,KAAK5C,OAAL,CAAaM,QAAb,IAAyB,KAAKO,OAAL,CAAalC,MAAb,KAAwB,CAArD,EAAwD;WACjDkE,8BAAL;;;SAGGC,kBAAL;SACKC,cAAL;;QAEI,KAAK/C,OAAL,CAAagD,UAAjB,EAA6B;WACtBC,iBAAL;;;SAGGC,qBAAL;;SAEKC,gBAAL;;QAEI,KAAKnD,OAAL,CAAaO,MAAjB,EAAyB;WAClB6C,qBAAL;KADF,MAEO;WACAC,wBAAL;;;SAGGC,QAAL,GAAgB,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAAhB;SACK5F,OAAL,CAAa6F,gBAAb,CAA8B,OAA9B,EAAuC,KAAKH,QAA5C;;;SAGKI,gBAAL,CAAsB,KAAKC,aAAL,CAAmB,KAAK3D,OAAL,CAAa4D,UAAhC,CAAtB,EAAmE,IAAnE;;;QAGI,KAAKvD,gBAAT,EAA2B;WACpBwD,kBAAL;WACKC,mBAAL;;;;;;;;;;qBAQJT,+DAA2B;;SAEpBzC,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcC,mBAArC,IAA4DF,UAAUG,GAAV,CAAcC,SAA1E;SACKxD,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcI,0BAArC,IAAmE,KAAKrE,OAAL,CAAasE,MAAhF;;SAEK9C,iBAAL,GAAyB,KAAK+C,iBAAL,GAAyB5F,MAAzB,GAAkC,CAA3D;;SAEK6F,cAAL;;;;;;;;;qBAOFpB,yDAAwB;;;SACjB3B,YAAL,GAAoB,KAApB;;;SAGKgD,SAAL,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAQ/F,CAAR,EAAc;YAC/BmF,KAAN,CAAYC,UAAUC,GAAV,CAAcW,UAA1B,IAAwC,aACtC,OAAK5E,OAAL,CAAa8B,cADyB,GACR,WADhC;;;UAIIlD,MAAM,CAAV,EAAa;cACLiG,SAAN,CAAgBC,GAAhB,CAAoB/E,SAASgF,OAAT,CAAiBC,OAArC;;KANJ;;SAUKC,eAAL;;;;;;;;;;;;qBAUFpC,2EAAiC;;;;;SAG1BV,gBAAL,GAAwB,IAAxB;SACKrB,SAAL,GAAiB,IAAjB;;;SAGKD,OAAL,CAAa6D,OAAb,CAAqB,UAACC,KAAD,EAAW;aACzBO,kBAAL,GAA0BC,WAA1B,CAAsCR,MAAMS,SAAN,CAAgB,IAAhB,CAAtC;KADF;;;SAKKvE,OAAL,GAAe,KAAK0B,kBAAL,CAAwBxC,SAASgF,OAAT,CAAiBM,KAAzC,CAAf;;;;;;;;qBAMFvC,mDAAqB;SACdwC,UAAL,GAAkBC,YAAlB,CAA+B,WAA/B,EAA4C,QAA5C;SACKL,kBAAL,GAA0BK,YAA1B,CAAuC,MAAvC,EAA+C,MAA/C;SACKd,SAAL,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAW;qBAC9Ba,MAAJ,CAAWb,KAAX,EAAkBxF,QAAlB;YACMoG,YAAN,CAAmB,MAAnB,EAA2B,UAA3B;KAFF;;;;;;;;qBASFE,yDAAwB;SACjBH,UAAL,GAAkBzF,eAAlB,CAAkC,WAAlC;SACKqF,kBAAL,GAA0BrF,eAA1B,CAA0C,MAA1C;SACK4E,SAAL,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAW;YAC5B9E,eAAN,CAAsB,MAAtB;KADF;;;;;;;;;qBASF+C,+CAAmB;;SAEZjC,uBAAL,GAA+B,KAAKgC,iBAAL,CAAuB5C,SAASgF,OAAT,CAAiBW,OAAxC,CAA/B;;;SAGK9E,WAAL,GAAmB,KAAK+B,iBAAL,CAAuB5C,SAASgF,OAAT,CAAiBY,gBAAxC,CAAnB;;;;SAIK9E,OAAL,GAAe,KAAK0B,kBAAL,CAAwBxC,SAASgF,OAAT,CAAiBM,KAAzC,CAAf;;;;;;;;;;qBAQFnC,yDAAwB;SACjB0C,eAAL,GAAuB,KAAKjD,iBAAL,CAAuB5C,SAASgF,OAAT,CAAiBc,WAAxC,CAAvB;SACKC,WAAL,GAAmB,KAAKnD,iBAAL,CAAuB5C,SAASgF,OAAT,CAAiBgB,WAAxC,CAAnB;SACKC,eAAL,GAAuB,KAAKzD,kBAAL,CAAwBxC,SAASgF,OAAT,CAAiBkB,cAAzC,EACpBC,GADoB,CAChB;aAAQ;gBAAA;WAERC,SAASC,IAAIC,YAAJ,CAAiB,YAAjB,CAAT,EAAyC,EAAzC,CAFQ;YAGPF,SAASC,IAAIC,YAAJ,CAAiB,sBAAjB,CAAT,EAAmD,EAAnD;OAHD;KADgB,CAAvB;;;;;;;;;qBAYFtD,2CAAiB;SACVnF,OAAL,CAAa0I,kBAAb,CAAgC,WAAhC,EAA6C,KAAKC,iBAAL,EAA7C;;;;;;;;;qBAOFC,2CAAiB;SACVC,cAAL,CAAoB1G,SAASgF,OAAT,CAAiB2B,OAArC;;;;;;;;;qBAOFD,yCAAejE,WAAW;QAClB5E,UAAU,KAAK+E,iBAAL,CAAuBH,SAAvB,CAAhB;QACI5E,OAAJ,EAAa;cACH+I,UAAR,CAAmBC,WAAnB,CAA+BhJ,OAA/B;;;;;;;;;;;qBASJ2I,iDAAoB;QACd,OAAO,KAAKvG,OAAL,CAAa6G,gBAApB,KAAyC,UAA7C,EAAyD;aAChD,KAAK7G,OAAL,CAAa6G,gBAAb,CAA8BhI,IAA9B,CAAmC,IAAnC,EAAyC,IAAzC,CAAP;;;WAGKkB,SAAS7B,QAAT,CAAkB,KAAK8B,OAAL,CAAa9B,QAAb,CAAsB4I,OAAxC,EAAiD;YAChD/G,SAAS7B,QAAT,CAAkB,KAAK8B,OAAL,CAAa9B,QAAb,CAAsB6I,UAAxC,EAAoD;qBAC3C,KAAK/G,OAAL,CAAa9B,QAAb,CAAsB8I;OAD/B,CADgD;YAIhDjH,SAAS7B,QAAT,CAAkB,KAAK8B,OAAL,CAAa9B,QAAb,CAAsB+I,UAAxC,EAAoD;qBAC3C,KAAKjH,OAAL,CAAa9B,QAAb,CAAsBgJ;OAD/B;KAJD,CAAP;;;;;;;;;qBAcFjE,iDAAoB;SACbrF,OAAL,CAAa0I,kBAAb,CAAgC,WAAhC,EAA6C,KAAKa,kBAAL,EAA7C;;;;;;;;;qBAOFC,iDAAoB;SACbX,cAAL,CAAoB1G,SAASgF,OAAT,CAAiBsC,UAArC;;;;;;;;;;qBAQFF,mDAAqB;QACf,OAAO,KAAKnH,OAAL,CAAasH,iBAApB,KAA0C,UAA9C,EAA0D;aACjD,KAAKtH,OAAL,CAAasH,iBAAb,CAA+BzI,IAA/B,CAAoC,IAApC,EAA0C,IAA1C,CAAP;;;QAGI0I,OAAO,KAAKC,oBAAL,EAAb;;WAEOzH,SAAS7B,QAAT,CAAkB,KAAK8B,OAAL,CAAa9B,QAAb,CAAsB8E,UAAxC,EAAoD;;KAApD,CAAP;;;;;;;;;;;;qBAYFwE,uDAAuB;;;QACftJ,cAAW,KAAKiE,gBAAL,GACf,KAAKnC,OAAL,CAAa9B,QAAb,CAAsBuJ,sBADP,GAEf,KAAKzH,OAAL,CAAa9B,QAAb,CAAsBwJ,aAFxB;;WAIO,KAAKjD,SAAL,GAAiBkD,MAAjB,CAAwB,UAACC,QAAD,EAAWjD,KAAX,EAAkB/F,CAAlB,EAAqBiJ,GAArB,EAA6B;UACpDzJ,OAAO;eACJQ,CADI;gBAEHA,IAAI,CAFD;iBAGF+F,MAAMmD;OAHjB;;UAMI,OAAK3F,gBAAT,EAA2B;;;;aAIpB4F,cAAL,GAAsBnJ,IAAI,CAAJ,GAAQA,IAAI,CAAZ,GAAgBA,IAAI,CAA1C;aACKoJ,MAAL,GAAcpJ,KAAKiJ,IAAIlJ,MAAJ,GAAa,CAAhC;;;aAGKiJ,WAAW7H,SAAS7B,QAAT,CAAkBA,WAAlB,EAA4BE,IAA5B,CAAlB;KAfK,EAgBJ,EAhBI,CAAP;;;;;;;;;qBAuBFoG,2CAAiB;SACVvC,SAAL,GAAiB,IAAIgG,YAAJ,CAAiB,KAAKrH,WAAtB,EAAmC;YAC5C,KAAKR,UAAL,GAAkB8H,WAAWC,IAAX,CAAgBC,CAAlC,GAAsCF,WAAWC,IAAX,CAAgBE;KAD7C,CAAjB;;SAIKC,YAAL,GAAoB,KAAKC,gBAAL,CAAsB/E,IAAtB,CAA2B,IAA3B,CAApB;SACKgF,WAAL,GAAmB,KAAKC,eAAL,CAAqBjF,IAArB,CAA0B,IAA1B,CAAnB;SACKkF,UAAL,GAAkB,KAAKC,cAAL,CAAoBnF,IAApB,CAAyB,IAAzB,CAAlB;;SAEKvB,SAAL,CAAe2G,EAAf,CAAkBX,aAAaY,SAAb,CAAuBC,KAAzC,EAAgD,KAAKR,YAArD;SACKrG,SAAL,CAAe2G,EAAf,CAAkBX,aAAaY,SAAb,CAAuBE,IAAzC,EAA+C,KAAKP,WAApD;SACKvG,SAAL,CAAe2G,EAAf,CAAkBX,aAAaY,SAAb,CAAuBG,GAAzC,EAA8C,KAAKN,UAAnD;;;;;;;;;qBAOFzD,6CAAkB;SACX/C,OAAL,GAAe,IAAIgG,UAAJ,CAAe,KAAKtH,WAApB,EAAiC;YACxCsH,WAAWC,IAAX,CAAgBE,CADwB;2BAEzB;KAFR,CAAf;;SAKKY,aAAL,GAAqB,KAAKC,iBAAL,CAAuB1F,IAAvB,CAA4B,IAA5B,CAArB;SACKtB,OAAL,CAAa0G,EAAb,CAAgBV,WAAWW,SAAX,CAAqBG,GAArC,EAA0C,KAAKC,aAA/C;;;;;;;;;qBAOFE,6BAASC,WAAW;;SAEbC,wBAAL;;;SAGKzI,WAAL,CAAiB0F,kBAAjB,CAAoC,WAApC,EAAiD8C,SAAjD;;SAEK/G,KAAL;;;;;;;;;qBAOFA,yBAAQ;;SAEDO,gBAAL;;;SAGK4D,cAAL;SACKY,iBAAL;;SAEKtE,kBAAL;;;SAGKC,cAAL;QACI,KAAK/C,OAAL,CAAagD,UAAjB,EAA6B;WACtBC,iBAAL;;;SAGGC,qBAAL;;;SAGKC,gBAAL;;;QAGMmG,WAAW,KAAKC,gBAAL,EAAjB;SACK7F,gBAAL,CAAsB,CAAtB,EAAyB,IAAzB;;;SAGKA,gBAAL,CAAsB4F,QAAtB,EAAgC,IAAhC;;;QAGI,KAAKjJ,gBAAT,EAA2B;WACpBwD,kBAAL;WACKC,mBAAL;;;;;;;;;;qBAQJwB,mCAAa;WACJ,KAAK3E,uBAAZ;;;;;;;;;qBAOFuE,mDAAqB;WACZ,KAAKtE,WAAZ;;;;;;;;;qBAOF6D,iCAAY;WACH,KAAK5D,OAAZ;;;;;;;;;;qBAQF2I,6BAASC,OAAO;WACP,KAAKhF,SAAL,GAAiBgF,KAAjB,CAAP;;;;;;;;;qBAOFF,+CAAmB;WACV,KAAK7I,cAAZ;;;;;;;;;;;qBASFgJ,qCAAaC,cAAc;WAClB,KAAKC,eAAL,GAAuBC,OAAvB,CAA+BF,YAA/B,CAAP;;;;;;;;;;;qBASFG,6CAAiBtJ,UAAU;WAClB,KAAKoJ,eAAL,GAAuBpJ,QAAvB,CAAP;;;;;;;;;;;;qBAUFmD,uCAAcgG,cAAc;QACtB,KAAKI,iBAAL,CAAuBJ,YAAvB,CAAJ,EAA0C;UACpC,KAAK3J,OAAL,CAAaM,QAAjB,EAA2B;eAClB,KAAK0J,iBAAL,CAAuBL,YAAvB,EAAqC,CAArC,CAAP;;aAEK,KAAKM,kBAAL,CAAwBN,YAAxB,CAAP;;WAEKA,YAAP;;;;;;;;;;;;;;;qBAaFK,+CAAkBP,OAAOS,aAAa;WAC7BC,gBAAKC,cAAL,CAAoBX,KAApB,EAA2BS,WAA3B,EAAwC,KAAKrJ,OAAL,CAAalC,MAArD,CAAP;;;;;;;;qBAMFoL,+CAAkBN,OAAO;WAChBA,SAAS,CAAC,CAAV,IAAeA,SAAS,KAAK5I,OAAL,CAAalC,MAA5C;;;qBAGFsL,iDAAmBR,OAAO;WACjBU,gBAAKE,KAAL,CAAWZ,KAAX,EAAkB,CAAlB,EAAqB,KAAK5I,OAAL,CAAalC,MAAb,GAAsB,CAA3C,CAAP;;;;;;;;qBAMF2L,uCAAe;WACN,KAAKf,gBAAL,OAA4B,CAAnC;;;;;;;;qBAMFgB,qCAAc;WACL,KAAKhB,gBAAL,OAA4B,KAAK1I,OAAL,CAAalC,MAAb,GAAsB,CAAzD;;;;;;;;;;qBAQFwE,+CAAmB;SACZqH,aAAL,GAAqB,IAAI/K,KAAJ,CAAU,KAAKoB,OAAL,CAAalC,MAAvB,CAArB;;SAEK,IAAIC,IAAI,CAAR,EAAW6L,MAAM,KAAK5J,OAAL,CAAalC,MAAnC,EAA2CC,IAAI6L,GAA/C,EAAoD7L,GAApD,EAAyD;WAClD4L,aAAL,CAAmB5L,CAAnB,IAAwBA,CAAxB;;;;;;;qBAKJgL,6CAAkB;WACT,KAAKY,aAAZ;;;;;;;;;;;qBASFjG,+CAAkBmG,UAAU;WACnB,KAAKnI,kBAAL,CAAwBxC,SAASgF,OAAT,CAAiB4F,WAAzC,EAAsDD,QAAtD,CAAP;;;;;;;;;;;;;;;qBAaFE,iCAAWC,cAAcC,SAAS;QAC1BC,eAAe,KAAKd,kBAAL,CAAwBa,OAAxB,CAArB;QACME,YAAY,KAAKtB,YAAL,CAAkBmB,YAAlB,CAAlB;QACMhD,MAAM,KAAK2C,aAAjB;;;QAGIS,MAAJ,CAAWF,YAAX,EAAyB,CAAzB,EAA4BlD,IAAIoD,MAAJ,CAAWD,SAAX,EAAsB,CAAtB,EAAyB,CAAzB,CAA5B;;;;;;;;;;;qBASFE,qCAAaC,WAAWC,WAAW;QAC3BC,0BAA0B,KAAK3B,YAAL,CAAkByB,SAAlB,CAAhC;SACKX,aAAL,CAAmBa,uBAAnB,IAA8C,CAAC,CAA/C;SACKb,aAAL,CAAmB,KAAKd,YAAL,CAAkB0B,SAAlB,CAAnB,IAAmDD,SAAnD;SACKX,aAAL,CAAmBa,uBAAnB,IAA8CD,SAA9C;;;;;;;;;;;qBASFE,uCAAcC,UAAU;;;QAChBC,SAAS,KAAKlG,UAAL,GAAkBmG,qBAAlB,GAA0C,KAAKzK,QAA/C,CAAf;WACOuK,SAASrF,GAAT,CAAa;aAAMwF,GAAGD,qBAAH,GAA2B,OAAKzK,QAAhC,IAA4CwK,MAAlD;KAAb,CAAP;;;;;;;;;;qBAQFG,qDAAqBC,SAAS;QACxB,KAAK3J,SAAT,EAAoB;WACbA,SAAL,CAAe4J,SAAf,GAA2BD,OAA3B;KADF,MAEO;WACA1J,OAAL,CAAa2J,SAAb,GAAyBD,OAAzB;;;;;;;;;;qBAQJE,qCAAaC,aAAa;SACnBtK,YAAL,GAAoBsK,WAApB;SACKJ,oBAAL,CAA0BI,WAA1B;;;;;;;;;;;;;;;qBA2BFC,2CAAgBC,kBAAkB;;QAE5BC,sBAAsBD,iBAAiB,KAAKhL,eAAtB,CAA1B;;;QAGMkL,eAAepI,iBAAMqI,OAAN,CAAc,KAAKlH,kBAAL,EAAd,EAAyC,KAAK9D,cAA9C,CAArB;;QAEI,KAAKpB,OAAL,CAAaqM,UAAjB,EAA6B;UACrBC,kBAAkBvI,iBAAMqI,OAAN,CAAcH,gBAAd,EAAgC,KAAK7K,cAArC,CAAxB;UACMmL,cAAcxI,iBAAMqI,OAAN,CAAc,KAAK9G,UAAL,EAAd,EAAiC,KAAKlE,cAAtC,CAApB;WACKY,UAAL,GAAkB,CAACuK,cAAcD,eAAf,IAAkC,CAApD;6BACuB,KAAKtK,UAA5B;;;QAGEwK,WAAWN,sBAAsBC,YAArC;;QAEI,KAAK3K,iBAAL,IAA0B,KAAK+I,WAAL,EAA9B,EAAkD;;iBAErC,KAAKkC,4BAAL,CAAkCR,gBAAlC,EACTC,mBADS,EACYC,YADZ,CAAX;;;WAIKK,QAAP;;;;;;;;;;;;;qBAWFC,qEAA6BR,kBAAkBC,qBAAqBC,cAAc;;;QAG1EO,cAAc3I,iBAAM4I,eAAN,CAClB,KAAKpI,iBAAL,CAAuB0H,gBAAvB,CADkB,EACwB,KAAK7K,cAD7B,CAApB;;;QAIMwL,YAAY7I,iBAAMqI,OAAN,CAAcH,gBAAd,EAAgC,KAAK7K,cAArC,CAAlB;;;QAGMyL,cAAcX,uBAAuBU,YAAYF,WAAnC,CAApB;;;WAGOG,cAAcV,YAArB;;;;;;;;;;;qBASFW,2CAAgBC,KAAK;WACZ,cAAc,KAAK1L,cAAnB,GAAoC,GAApC,GAA0C0L,GAA1C,GAAgD,GAAvD;;;;;;qBAIF1D,+DAA2B;QACnB2D,OAAOC,SAASC,sBAAT,EAAb;;SAEKrM,OAAL,CAAa6D,OAAb,CAAqBsI,KAAK7H,WAA1B,EAAuC6H,IAAvC;;SAEKpM,WAAL,CAAiBuE,WAAjB,CAA6B6H,IAA7B;;;SAGK7J,gBAAL;;;;;;;;;;;;;;qBAYFgK,+DAA0BC,YAAY;QAC9BC,iBAAiB,KAAKvD,gBAAL,CAAsBsD,UAAtB,CAAvB;QACME,sBAAsB,KAAKxD,gBAAL,CAAsB,KAAKtJ,QAA3B,CAA5B;;SAEKM,SAAL,GAAiB,IAAjB;;;QAGMyM,sBAAsBF,iBAAiBC,mBAAjB,GAC1B,KAAK9M,QAAL,GAAgB,CADU,GAE1B,KAAKA,QAAL,GAAgB,CAFlB;;;;SAMKgN,WAAL,CAAiBH,cAAjB,EAAiC,KAAKvD,gBAAL,CAAsByD,mBAAtB,CAAjC;;;WAGOA,mBAAP;;;;;;;;;;;qBASFC,mCAAYC,QAAQC,QAAQ;SACrBxC,YAAL,CAAkBuC,MAAlB,EAA0BC,MAA1B;mBACIC,YAAJ,CAAiB,KAAKnE,QAAL,CAAciE,MAAd,CAAjB,EAAwC,KAAKjE,QAAL,CAAckE,MAAd,CAAxC;;;;;;;;;;qBAQFE,2CAAiB;;QAEX,CAAC,KAAKhM,MAAV,EAAkB;WACXA,MAAL,GAAc,IAAIiM,gBAAJ,CAAU,KAAKC,sBAAL,CAA4BtK,IAA5B,CAAiC,IAAjC,CAAV,EACZ,KAAKxD,OAAL,CAAa+N,cADD,EACiB,IADjB,CAAd;;;SAIGnM,MAAL,CAAYoM,KAAZ;;;;;;;;;;qBAQFC,2CAAiB;QACX,KAAKC,mBAAL,EAAJ,EAAgC;WACzBtM,MAAL,CAAYuM,IAAZ;;;;;;;;;;;qBASJD,qDAAsB;WACb,CAAC,CAAC,KAAKtM,MAAP,IAAiB,KAAKA,MAAL,CAAYwM,SAApC;;;;;;;;qBAMFC,mDAAoBC,UAAUC,QAAQ;QAC9BC,iBAAiB,KAAKhF,QAAL,CAAc,KAAKD,gBAAL,EAAd,CAAvB;WACOgF,SACLE,eAAIC,aAAJ,CAAkBF,cAAlB,EAAkCF,WAAW,CAA7C,CADK,GAELG,eAAIC,aAAJ,CAAkBF,cAAlB,EAAkCF,QAAlC,EAA4C,KAA5C,KACAG,eAAIE,oBAAJ,CAAyB,KAAK/N,WAA9B,CAHF;;;;;;qBAOFgO,+DAA0BN,UAAUC,QAAQM,iBAAiB;WACpDN,SACLM,kBAAkBP,QAAlB,GAA6B,CADxB,GAELO,kBAAkBP,QAFpB;;;;;;;;;;;;qBAYFQ,+CAAkBR,UAAUS,aAAaR,QAAQ;QACzC9E,QAAQ,KAAKF,gBAAL,EAAd;QACMyF,UAAU,KAAKpF,eAAL,EAAhB;;;;QAIMiF,kBAAkB,KAAKnF,YAAL,CAAkBD,KAAlB,CAAxB;;;QAGMwF,uBAAuB,KAAKjF,iBAAL,CAAuBP,KAAvB,EAA8BsF,WAA9B,CAA7B;;;;QAIIC,QAAQH,kBAAkBE,WAA1B,MAA2CE,oBAA/C,EAAqE;;UAE7DC,mBAAmB,KAAKb,mBAAL,CAAyBC,QAAzB,EAAmCC,MAAnC,CAAzB;UACMY,iBAAiB,KAAKP,yBAAL,CAA+BN,QAA/B,EAAyCC,MAAzC,EAAiDM,eAAjD,CAAvB;UACMO,aAAa,KAAK5F,QAAL,CAAcyF,oBAAd,CAAnB;;;WAGKrE,UAAL,CAAgBqE,oBAAhB,EAAsCE,cAAtC;WACKvO,WAAL,CAAiByO,YAAjB,CAA8BD,UAA9B,EAA0CF,gBAA1C;;;;;;;;;;;qBASJrL,mDAAqB;QACfjF,UAAJ;;;SAGKA,IAAI,CAAT,EAAYA,IAAI,KAAKoB,OAAL,CAAasP,aAA7B,EAA4C1Q,GAA5C,EAAiD;WAC1CkQ,iBAAL,CAAuBlQ,CAAvB,EAA0B,EAAEA,IAAI,CAAN,CAA1B,EAAoC,KAApC;;;;SAIGA,IAAI,CAAT,EAAYA,IAAI,KAAKoB,OAAL,CAAasP,aAA7B,EAA4C1Q,GAA5C,EAAiD;WAC1CkQ,iBAAL,CAAuBlQ,CAAvB,EAA0BA,IAAI,CAA9B,EAAiC,IAAjC;;;;;;;;;qBAOJkF,qDAAsB;SACfyL,SAAL,CAAe,KAAK7F,YAAL,CAAkB,KAAKH,gBAAL,EAAlB,CAAf,EAA2D,IAA3D;;;;;;;;;;;;;qBAWFiG,uDAAsBhP,UAAUiP,aAAa;;;QAGvC,KAAKzP,OAAL,CAAa0P,QAAb,IAAyB,CAACD,WAA1B,IAAyCE,KAAKC,GAAL,CAAS,KAAKpP,QAAL,GAAgBA,QAAzB,IAAqC,CAAlF,EAAqF;aAC5E,KAAK2M,yBAAL,CAA+B3M,QAA/B,CAAP;;WAEKA,QAAP;;;;;;;;;;;qBASFqP,qCAAarP,UAAUiP,aAAa;QAC5BK,2BAA2BtP,aAAa,KAAKA,QAAlB,IAA8B,CAACiP,WAAhE;;;QAGMM,WAAW,KAAKrO,UAAL,IAAmB,KAAKC,SAAzC;;;;;;;WAOO,EACJ,CAAC,KAAKZ,UAAP,IACC,CAAC,KAAKf,OAAL,CAAaM,QAAd,IAA0B,KAAKyJ,iBAAL,CAAuBvJ,QAAvB,CAD3B,IAECsP,4BAA4B,CAACC,QAHzB,CAAP;;;qBAMFC,qCAAc;;SAEP1O,eAAL,GAAuB,IAAvB;;;SAGK2O,UAAL,CAAgB,IAAI3S,aAAJ,CACdyC,SAAS8I,SAAT,CAAmBqH,WADL,EAEd,IAFc,EAGd,KAAKpG,gBAAL,CAAsB,KAAKrJ,YAA3B,CAHc,EAId,KAAKqJ,gBAAL,CAAsB,KAAKtJ,QAA3B,CAJc,CAAhB;;;;;;;;;;;qBAaF2P,2CAAgB3D,UAAUiD,aAAa;;SAEhC7O,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcG,SAArC,IAAkD,KAAK0I,eAAL,CAAqBN,QAArB,CAAlD;;;QAGIiD,WAAJ,EAAiB;WACV7O,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcmM,mBAArC,IAA4D,KAA5D;;;KADF,MAIO;;WAEAxP,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcmM,mBAArC,IACE,KAAKpQ,OAAL,CAAa8B,cAAb,GAA8B,IADhC;;;;;;WAOKP,aAAL,GAAqB8O,qBAAUC,eAAV,CAA0B,KAAK1P,WAA/B,EACnB,KAAK2P,eADc,EAEnB,IAFmB,EAGnBvM,UAAUC,GAAV,CAAcG,SAHK,EAInB,KAAKpE,OAAL,CAAa8B,cAAb,GAA8B/B,SAASyQ,mBAJpB,CAArB;;WAMKR,WAAL;;;;;;;;;;qBAQJS,mDAAqB;QACbC,SAASC,iBAAiB,KAAK/P,WAAtB,EAAmCoD,UAAUC,GAAV,CAAcG,SAAjD,CAAf;;;QAGMwM,YAAYjB,KAAKkB,KAAL,CAChB9R,aAAa2R,MAAb,EAAqB,KAAKrP,cAAL,CAAoByP,WAApB,EAArB,IAA0D,EAD1C,IAEd,EAFJ;;QAIMC,cAAc,KAAKvH,QAAL,CAAc,KAAKD,gBAAL,EAAd,EAAuC,KAAKtI,eAA5C,CAApB;WACO8P,cAAcH,SAArB;;;;;;;;;;;;;;;;;;qBAgBFI,6CAAkB;QACZ,CAAC,KAAK1P,eAAV,EAA2B;;;;SAItBA,eAAL,GAAuB,KAAvB;yBACU2P,mBAAV,CAA8B,KAAK1P,aAAnC;;;QAGI,KAAKvB,OAAL,CAAaO,MAAjB,EAAyB;;;;;QAKnB4L,eAAepI,iBAAMqI,OAAN,CAAc,KAAKlH,kBAAL,EAAd,EAAyC,KAAK9D,cAA9C,CAArB;QACM8P,SAAS,KAAKT,kBAAL,EAAf;;QAEI,KAAK3P,SAAT,EAAoB;WACbuI,wBAAL;;;QAGE,KAAKhJ,gBAAT,EAA2B;WACpBwD,kBAAL;;;;;QAKI2K,iBAAiB,KAAKhF,QAAL,CAAc,KAAKD,gBAAL,EAAd,CAAvB;QACM4H,iBAAiB3C,eAAe,KAAKvN,eAApB,CAAvB;QACMuL,WAAW,CAAC2E,iBAAiBD,MAAlB,IAA4B/E,YAA7C;;;;SAIKgE,eAAL,CAAsB3D,WAAW,CAAC,GAAb,GAAoB,GAAzC,EAA8C,IAA9C;SACKvK,SAAL,CAAemP,MAAf;;;;;;;;;;;qBASFC,mCAAY7Q,UAAU8Q,gBAAgB;;QAE9BC,YAAY,KAAK/H,QAAL,CAAchJ,QAAd,EAAwB,IAAxB,CAAlB;QACMgR,gBAAgB,KAAKhI,QAAL,CAAc,KAAKhJ,QAAnB,EAA6B,IAA7B,CAAtB;;;QAGI,CAAC8Q,cAAL,EAAqB;;WAEd/P,aAAL,GAAqB8O,qBAAUC,eAAV,CAA0BiB,SAA1B,EAAqC,KAAKhB,eAA1C,EAA2D,IAA3D,CAArB;;;;cAIQ1L,SAAV,CAAoBC,GAApB,CAAwB/E,SAASgF,OAAT,CAAiBC,OAAzC;;QAEIwM,kBAAkBD,SAAtB,EAAiC;oBACjB1M,SAAd,CAAwBC,GAAxB,CAA4B/E,SAASgF,OAAT,CAAiB0M,MAA7C;;;;;;iBAMW,YAAM;sBACD5M,SAAd,CAAwB6M,MAAxB,CAA+B3R,SAASgF,OAAT,CAAiBC,OAAhD;OADF,EAEG,KAAKnD,iBAFR;;;;SAMGpB,YAAL,GAAoB,KAAKD,QAAzB;SACKA,QAAL,GAAgBA,QAAhB;;;QAGI,CAAC8Q,cAAL,EAAqB;WACdtB,WAAL;;;;;;;;;;;;qBAUJT,+BAAU/O,UAAU8Q,gBAAgB;;QAE5BrF,mBAAmB,KAAKzC,QAAL,CAAc,KAAKM,gBAAL,CAAsBtJ,QAAtB,CAAd,CAAzB;;;;;QAKMmR,kBAAkB,KAAKnC,qBAAL,CAA2BhP,QAA3B,EAAqC8Q,cAArC,CAAxB;;;QAGMM,mBAAoB,KAAK5F,eAAL,CAAqBC,gBAArB,IAAyC,CAAC,GAA3C,GAAkD,GAA3E;;;SAGKxL,YAAL,GAAoB,KAAKD,QAAzB;SACKA,QAAL,GAAgBmR,eAAhB;;;;SAIKxB,eAAL,CAAqByB,gBAArB,EAAuCN,cAAvC;;;;;;;;;;;;;qBAWF5N,6CAAiB+F,OAAO6H,gBAAgB;QAClC9Q,WAAW,KAAKkJ,YAAL,CAAkBD,KAAlB,CAAf;QACMoI,cAAc,KAAKhC,YAAL,CAAkBrP,QAAlB,EAA4B8Q,cAA5B,CAApB;;;QAGIO,WAAJ,EAAiB;;UAEX,KAAK5B,UAAL,CAAgB,IAAI3S,aAAJ,CAAkByC,SAAS8I,SAAT,CAAmBiJ,aAArC,EAAoD,IAApD,CAAhB,CAAJ,EAAgF;eACvE,KAAP;;;WAGGd,eAAL;;WAEKtQ,cAAL,GAAsB,KAAKiD,aAAL,CAAmB8F,KAAnB,CAAtB;;;iBAGW,KAAKC,YAAL,CAAkB,KAAKhJ,cAAvB,CAAX;;;;WAIKqR,eAAL;WACKC,eAAL;WACKC,mBAAL;UACI,KAAKjS,OAAL,CAAaO,MAAjB,EAAyB;aAClB8Q,WAAL,CAAiB7Q,QAAjB,EAA2B8Q,cAA3B;OADF,MAEO;aACA/B,SAAL,CAAe/O,QAAf,EAAyB8Q,cAAzB;;;;;WAKGO,WAAP;;;;;;;;;;;;;qBAWFK,6CAAiB3D,QAAQ;;QAEjB4D,YAAY,KAAK7G,aAAL,CAAmB,KAAK7G,SAAL,EAAnB,CAAlB;;;;;QAKIkF,eAAewI,UAAUtI,OAAV,CAAkB7K,iBAAMoT,OAAN,CAAcD,SAAd,EAAyB,KAAKnQ,UAA9B,CAAlB,CAAnB;;;;;QAKI2H,iBAAiB,KAAKJ,gBAAL,EAArB,EAA8C;UACxCgF,WAAW,IAAf,EAAqB;uBACJ,KAAK5K,aAAL,CAAmBgG,eAAe,CAAlC,CAAf;OADF,MAEO,IAAI4E,WAAW,KAAf,EAAsB;uBACZ,KAAK5K,aAAL,CAAmBgG,eAAe,CAAlC,CAAf;;;;WAIG,KAAKjG,gBAAL,CAAsBiG,YAAtB,CAAP;;;;;;;;;qBAOF0I,yCAAgB;WACP,KAAK3O,gBAAL,CAAsB,KAAK6F,gBAAL,KAA0B,CAAhD,CAAP;;;;;;;;;qBAOF+I,iDAAoB;WACX,KAAK5O,gBAAL,CAAsB,KAAK6F,gBAAL,KAA0B,CAAhD,CAAP;;;;;;;;;;qBAQFwI,6CAAkB;QACVQ,gBAAgB,KAAKhJ,gBAAL,EAAtB;QACMiJ,OAAO,KAAK7O,aAAL,CAAmB4O,gBAAgB,CAAnC,CAAb;QACME,WAAW,KAAK9O,aAAL,CAAmB4O,gBAAgB,CAAnC,CAAjB;QACMG,OAAO,KAAK/O,aAAL,CAAmB4O,gBAAgB,CAAnC,CAAb;QACMI,SAAS,KAAKhP,aAAL,CAAmB4O,gBAAgB,CAAnC,CAAf;;;SAGK9N,SAAL,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAQ/F,CAAR,EAAc;UAC/BgU,WAAWhU,MAAM2T,aAAvB;;yBAEmB5N,KAAnB,EAA0BiO,QAA1B;;YAEMrN,YAAN,CAAmB,aAAnB,EAAkC,CAACqN,QAAnC;;;YAGM/N,SAAN,CAAgBgO,MAAhB,CAAuB9S,SAASgF,OAAT,CAAiB+N,YAAxC,EAAsDF,QAAtD;;;YAGM/N,SAAN,CAAgBgO,MAAhB,CACE9S,SAASgF,OAAT,CAAiBgO,UADnB,EAEEnU,MAAM4T,IAAN,IAAcD,kBAAkBC,IAAhC,IAAwCC,aAAaD,IAFvD;;;YAKM3N,SAAN,CAAgBgO,MAAhB,CACE9S,SAASgF,OAAT,CAAiBiO,cADnB,EAEEpU,MAAM6T,QAAN,IAAkBF,kBAAkBE,QAFtC;;;YAKM5N,SAAN,CAAgBgO,MAAhB,CACE9S,SAASgF,OAAT,CAAiBkO,UADnB,EAEErU,MAAM8T,IAAN,IAAcH,kBAAkBG,IAFlC;;;YAKM7N,SAAN,CAAgBgO,MAAhB,CACE9S,SAASgF,OAAT,CAAiBmO,YADnB,EAEEtU,MAAM+T,MAAN,IAAgBJ,kBAAkBI,MAAlC,IAA4CD,SAASC,MAFvD;KA1BF;;;qBAgCFV,qDAAsB;QAChB,KAAKjS,OAAL,CAAagD,UAAjB,EAA6B;UACrBuP,gBAAgB,KAAKhJ,gBAAL,EAAtB;WACKvD,eAAL,CAAqBtB,OAArB,CAA6B,gBAAoB;YAAjB0B,GAAiB,QAAjBA,GAAiB;YAAZxH,CAAY,QAAZA,CAAY;YAATuU,EAAS,QAATA,EAAS;;YACzC7J,WAAWiJ,kBAAkB3T,CAAlB,IAAuB2T,kBAAkBY,EAA1D;YACItO,SAAJ,CAAcgO,MAAd,CAAqB9S,SAASgF,OAAT,CAAiBqO,uBAAtC,EAA+D9J,QAA/D;YACI/D,YAAJ,CAAiB,eAAjB,EAAkC+D,QAAlC;OAHF;;;;qBAQJ0I,6CAAkB;QACVqB,YAAY,CAAC,KAAKrT,OAAL,CAAaM,QAAhC;QACI+S,aAAa,KAAKzN,eAAtB,EAAuC;UAC/B0N,QAAQ,KAAKhJ,YAAL,EAAd;WACK1E,eAAL,CAAqBf,SAArB,CAA+BgO,MAA/B,CAAsC9S,SAASgF,OAAT,CAAiBwO,eAAvD,EAAwED,KAAxE;WACK1N,eAAL,CAAqBL,YAArB,CAAkC,eAAlC,EAAmD+N,KAAnD;;;QAGED,aAAa,KAAKvN,WAAtB,EAAmC;UAC3B0N,OAAO,KAAKjJ,WAAL,EAAb;WACKzE,WAAL,CAAiBjB,SAAjB,CAA2BgO,MAA3B,CAAkC9S,SAASgF,OAAT,CAAiBwO,eAAnD,EAAoEC,IAApE;WACK1N,WAAL,CAAiBP,YAAjB,CAA8B,eAA9B,EAA+CiO,IAA/C;;;;;;;;;;qBAQJ1F,2DAAyB;;QAEnB,CAAC,KAAK9N,OAAL,CAAaM,QAAd,IAA0B,KAAKiK,WAAL,EAA9B,EAAkD;WAC3C0D,cAAL;KADF,MAEO;WACAoE,aAAL;;;;qBAIJ9B,6CAAkB;QACV1S,OAAO,KAAKiM,gBAAL,CAAsB,KAAKrJ,YAA3B,CAAb;QACM3C,KAAK,KAAKgM,gBAAL,CAAsB,KAAKtJ,QAA3B,CAAX;;;SAGKc,eAAL,GAAuB,KAAvB;;QAEI,KAAKR,SAAT,EAAoB;WACbuI,wBAAL;;;;QAIE,KAAKhJ,gBAAT,EAA2B;WACpBwD,kBAAL;;;QAGE,KAAK/C,SAAL,IAAkB,KAAKT,gBAA3B,EAA6C;WACtCyD,mBAAL;;;QAGE,KAAK9D,OAAL,CAAaO,MAAjB,EAAyB;WAClBiJ,QAAL,CAAc3L,IAAd,EAAoBgH,SAApB,CAA8B6M,MAA9B,CAAqC3R,SAASgF,OAAT,CAAiB0M,MAAtD;;;;SAIG3Q,SAAL,GAAiB,KAAjB;;;SAGKmP,UAAL,CAAgB,IAAI3S,aAAJ,CAAkByC,SAAS8I,SAAT,CAAmB4K,SAArC,EAAgD,IAAhD,EAAsD5V,IAAtD,EAA4DC,EAA5D,CAAhB;;;;;;;;;qBAOFoL,+CAAkBwK,cAAc;QAC1B,KAAKxR,OAAL,CAAayR,WAAb,CAAyBD,aAAaE,QAAtC,CAAJ,EAAqD;UAC/CF,aAAaG,SAAb,KAA2B3L,WAAW4L,SAAX,CAAqBC,KAApD,EAA2D;aACpDzB,iBAAL;OADF,MAEO,IAAIoB,aAAaG,SAAb,KAA2B3L,WAAW4L,SAAX,CAAqBE,IAApD,EAA0D;aAC1D3B,aAAL;;;;;;;;;;;;;;qBAYN9O,qCAAa0Q,KAAK;QACVtW,SAASsW,IAAItW,MAAnB;QACIuW,eAAe,KAAnB;;;QAGM9N,MAAMzI,OAAOyU,OAAP,CAAe,MAAMrS,SAASgF,OAAT,CAAiBkB,cAAtC,CAAZ;QACMkO,OAAOxW,OAAOyU,OAAP,CAAe,MAAMrS,SAASgF,OAAT,CAAiBc,WAAtC,CAAb;QACM6M,OAAO/U,OAAOyU,OAAP,CAAe,MAAMrS,SAASgF,OAAT,CAAiBgB,WAAtC,CAAb;;;QAGIK,GAAJ,EAAS;qBACQ,IAAf;WACK1C,gBAAL,CAAsByC,SAASC,IAAIC,YAAJ,CAAiB,YAAjB,CAAT,EAAyC,EAAzC,CAAtB;;;KAFF,MAKO,IAAI8N,IAAJ,EAAU;qBACA,IAAf;WACK7B,iBAAL;;;KAFK,MAKA,IAAII,IAAJ,EAAU;qBACA,IAAf;WACKL,aAAL;;;;;KAFK,MAOA,IAAI,KAAK/Q,eAAT,EAA0B;UAC3BrD,cAAJ;;;QAGEiW,YAAJ,EAAkB;UACZjW,cAAJ;;;WAGKgQ,cAAL;;;;;;;;;;qBAQJ1F,+CAAmB;SACZ0F,cAAL;SACK+C,eAAL;;;SAGKpQ,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcmM,mBAArC,IAA4D,KAA5D;;;;;;;;;;;qBASF3H,kDAA2B;QAAT2L,KAAS,SAATA,KAAS;;SACpB1S,UAAL,GAAkB,KAAKtB,UAAL,GAChBuP,KAAKC,GAAL,CAASwE,MAAMC,CAAf,IAAoB,CADJ,GAEhB1E,KAAKC,GAAL,CAASwE,MAAME,CAAf,IAAoB,CAFtB;QAGI,CAAC,KAAKtU,OAAL,CAAaM,QAAlB,EAA4B;UACpBiU,WAAW,KAAKC,oBAAL,CAA0BJ,MAAME,CAAhC,EAAmCF,MAAMC,CAAzC,IAA8C,GAA9C,GAAoD,CAArE;WACKpS,SAAL,CAAesS,QAAf,GAA0BA,QAA1B;;;;;;;;;;;;qBAUJ5L,yCAAesL,KAAK;SACbhS,SAAL,CAAesS,QAAf,GAA0B,CAA1B;SACKE,iBAAL,CAAuBR,IAAIL,QAA3B,EAAqCK,IAAIS,aAAzC,EAAwDT,IAAIU,aAA5D;SACKjT,UAAL,GAAkB,KAAlB;SACKC,SAAL,GAAiB,KAAjB;;;qBAGFiT,mDAAoBjB,aAAaE,WAAW;WACnCF,gBAAgB,KAAK3T,OAAL,CAAaM,QAAb,IAAyB,CAAC,KAAKgK,YAAL,EAA1C,MACLuJ,cAAc3L,WAAW4L,SAAX,CAAqBC,KAAnC,IACAF,cAAc3L,WAAW4L,SAAX,CAAqBe,IAF9B,CAAP;;;qBAKFC,2CAAgBnB,aAAaE,WAAW;WAC/BF,gBAAgB,KAAK3T,OAAL,CAAaM,QAAb,IAAyB,CAAC,KAAKiK,WAAL,EAA1C,MACLsJ,cAAc3L,WAAW4L,SAAX,CAAqBE,IAAnC,IACAH,cAAc3L,WAAW4L,SAAX,CAAqBiB,EAF9B,CAAP;;;qBAKFN,+CAAkBb,UAAUC,WAAWc,eAAe;QAC9ChB,cAAc,KAAKjS,UAAL,IAAmB,KAAKO,SAAL,CAAeC,OAAf,CAAuByR,WAAvB,CAAmCC,QAAnC,CAAvC;;;;;;;QAOI,CAAC,KAAKlS,UAAV,EAAsB;WACfC,SAAL,GACEgO,KAAKC,GAAL,CAASD,KAAKkB,KAAL,CAAW,KAAKJ,kBAAL,EAAX,CAAT,IAAkDd,KAAKkB,KAAL,CAAW,KAAK7O,UAAhB,CADpD;;;;QAKE,KAAK4S,mBAAL,CAAyBjB,WAAzB,EAAsCE,SAAtC,CAAJ,EAAsD;WAC/C3B,gBAAL,CAAsB,KAAtB;;;KADF,MAIO,IAAI,KAAK4C,eAAL,CAAqBnB,WAArB,EAAkCE,SAAlC,CAAJ,EAAkD;WAClD3B,gBAAL,CAAsB,IAAtB;;;;;;KADK,MAOA,IAAIyC,iBAAiB,KAAKhT,SAA1B,EAAqC;WACrCuQ,gBAAL;;;;;;;;;;;qBASJjC,iCAAW+E,OAAO;SACXC,IAAL,CAAUD,MAAMzX,IAAhB,EAAsByX,KAAtB;WACOA,MAAMhX,gBAAb;;;;;;;;;;;;qBAUFwW,qDAAqBU,QAAQC,QAAQ;QAC7BC,cAAc,KAAKhV,UAAL,GAClB+U,SAAS,CADS,GAElBD,SAAS,CAFX;QAGMG,YAAY,KAAKjV,UAAL,GAChB+U,SAAS,CADO,GAEhBD,SAAS,CAFX;;WAIQ,KAAK5K,YAAL,MAAuB8K,WAAxB,IAAyC,KAAK7K,WAAL,MAAsB8K,SAAtE;;;;;;;;;qBAOFC,6BAAU;QACJ,KAAK1T,MAAT,EAAiB;WACVA,MAAL,CAAY0T,OAAZ;;;SAGG7P,qBAAL;SACKe,cAAL;SACKY,iBAAL;;;SAGKxG,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcG,SAArC,IAAkD,EAAlD;SACKxD,WAAL,CAAiBmD,KAAjB,CAAuBC,UAAUC,GAAV,CAAcW,UAArC,IAAmD,EAAnD;;QAEI,KAAK5E,OAAL,CAAaO,MAAjB,EAAyB;WAClB2B,OAAL,CAAaqT,GAAb,CAAiBrN,WAAWW,SAAX,CAAqBG,GAAtC,EAA2C,KAAKC,aAAhD;WACK/G,OAAL,CAAaoT,OAAb;;WAEK7Q,SAAL,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAW;cAC5BZ,KAAN,CAAYC,UAAUC,GAAV,CAAcW,UAA1B,IAAwC,EAAxC;OADF;KAJF,MAOO;WACA3C,SAAL,CAAesT,GAAf,CAAmBtN,aAAaY,SAAb,CAAuBC,KAA1C,EAAiD,KAAKR,YAAtD;WACKrG,SAAL,CAAesT,GAAf,CAAmBtN,aAAaY,SAAb,CAAuBE,IAA1C,EAAgD,KAAKP,WAArD;WACKvG,SAAL,CAAesT,GAAf,CAAmBtN,aAAaY,SAAb,CAAuBG,GAA1C,EAA+C,KAAKN,UAApD;;WAEKzG,SAAL,CAAeqT,OAAf;;;SAGG1X,OAAL,CAAa4X,mBAAb,CAAiC,OAAjC,EAA0C,KAAKlS,QAA/C;;SAEKzC,OAAL,CAAa6D,OAAb,CAAqB,UAACC,KAAD,EAAW;YACxBE,SAAN,CAAgB6M,MAAhB,CACE3R,SAASgF,OAAT,CAAiBgO,UADnB,EAEEhT,SAASgF,OAAT,CAAiBiO,cAFnB,EAGEjT,SAASgF,OAAT,CAAiB+N,YAHnB,EAIE/S,SAASgF,OAAT,CAAiBkO,UAJnB,EAKElT,SAASgF,OAAT,CAAiBmO,YALnB,EAMEnT,SAASgF,OAAT,CAAiBC,OANnB,EAOEjF,SAASgF,OAAT,CAAiB0M,MAPnB;KADF;;;;QAcI,KAAKtP,gBAAT,EAA2B;WACpBvB,WAAL,CAAiBgG,WAAjB,CAA6B,KAAK/F,OAAL,CAAa,CAAb,CAA7B;WACKD,WAAL,CAAiBgG,WAAjB,CAA6B,KAAK/F,OAAL,CAAa,CAAb,CAA7B;;;;SAIGjD,OAAL,GAAe,IAAf;SACK+C,uBAAL,GAA+B,IAA/B;SACKC,WAAL,GAAmB,IAAnB;SACKgF,eAAL,GAAuB,IAAvB;SACKE,WAAL,GAAmB,IAAnB;SACKE,eAAL,GAAuB,IAAvB;SACK/D,SAAL,GAAiB,IAAjB;SACKC,OAAL,GAAe,IAAf;SACKrB,OAAL,CAAalC,MAAb,GAAsB,CAAtB;;;;;;;;;;;WASKwB,iCAAWH,SAAS;QACnByV,YAAYC,OAAOC,MAAP,CAAc,EAAd,EAAkB5V,SAAS6V,QAAT,CAAkB1X,QAApC,EAA8C8B,QAAQ9B,QAAtD,CAAlB;QACM2X,OAAOH,OAAOC,MAAP,CAAc,EAAd,EAAkB5V,SAAS6V,QAA3B,EAAqC5V,OAArC,CAAb;SACK9B,QAAL,GAAgBuX,SAAhB;WACOI,IAAP;;;;;wBAh5Bc;aACP,KAAK9U,UAAZ;;;;;;;;;sBAQY6K,SAAS;WAChB7K,UAAL,GAAkB6K,OAAlB;WACKD,oBAAL,CAA0BC,OAA1B;;;;EAnzBmBkK;;AA4rDvBJ,OAAOC,MAAP,CAAc5V,QAAd,EAAwBgW,QAAxB;;AAEAhW,SAAS7B,QAAT,GAAoB8X,QAApB;;;;;;;;"}