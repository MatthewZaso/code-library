{"version":3,"file":"odo-pointer.js","sources":["../src/settings.js","../src/pointer-event.js","../src/pointer.js"],"sourcesContent":["/** @enum {string} */\nexport const Direction = {\n  RIGHT: 'right',\n  LEFT: 'left',\n  UP: 'up',\n  DOWN: 'down',\n  NONE: 'no_movement',\n};\n\n/** @enum {string} */\nexport const Axis = {\n  X: 'x',\n  Y: 'y',\n  BOTH: 'xy',\n};\n","import { Coordinate } from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\n\nfunction isXAxis(axis) {\n  return axis === Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new Coordinate(\n    finiteOrZero(deltaX / deltaTime),\n    finiteOrZero(deltaY / deltaTime),\n  );\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(\n      coord1.x, coord2.x, Direction.LEFT,\n      Direction.RIGHT, Direction.NONE,\n    );\n  }\n\n  return getTheDirection(\n    coord1.y, coord2.y, Direction.UP,\n    Direction.DOWN, Direction.NONE,\n  );\n}\n\nfunction isOnAxis(axis, direction) {\n  const isXAndLeftOrRight = isXAxis(axis) && (\n    direction === Direction.LEFT ||\n    direction === Direction.RIGHT);\n\n  const isYAndUpOrDown = isYAxis(axis) && (\n    direction === Direction.UP ||\n    direction === Direction.DOWN);\n\n  const isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return (isXAxis(axis) && Math.abs(deltaX) > 0) ||\n\n  // Y axis and deltaY > 0\n  (isYAxis(axis) && Math.abs(deltaY) > 0) ||\n\n  // Both axis, as long as it actually moved.\n  (isBothAxis(axis) && hasDirection(direction));\n}\n\nfunction getAxisDirection(axis, start, end) {\n  const _start = Object.assign({}, start);\n  const _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nclass PointerEvent {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  constructor(options) {\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = Coordinate.distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(\n      options.axis, this.direction,\n      this.delta.x, this.delta.y,\n    );\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default PointerEvent;\n","/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport {\n  clamp,\n  Coordinate,\n  events,\n  noop,\n} from '@odopod/odo-helpers';\nimport { Direction, Axis } from './settings';\nimport _PointerEvent from './pointer-event';\n\nclass Pointer extends TinyEmitter {\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {HTMLElement} element Element to watch.\n   * @param {PointerOptions} options Options object.\n   * @throws {TypeError} Throws when the element parameter isn't an element.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    /**\n     * @type {PointerOptions}\n     */\n    this.options = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * The draggable element.\n     * @type {HTMLElement}\n     * @private\n     */\n    this.element = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    this.pageStart = new Coordinate();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    this.page = new Coordinate();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    this.delta = new Coordinate();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    this._lastPosition = new Coordinate();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    this._friction = 1;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    this.velocity = new Coordinate();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    this.dragEventTarget = document;\n\n    const touchAction = Pointer.TouchActionSupport[this.options.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (this.options.preventEventDefault && this._isTouchActionSupported) {\n      this.element.style[touchAction] = Pointer.TouchAction[this.options.axis];\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.addEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.listen();\n  }\n\n  listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (OdoDevice.HAS_POINTER_EVENTS) {\n      this.element.addEventListener(events.POINTERDOWN, this._onStart);\n    } else {\n      this.element.addEventListener(events.MOUSEDOWN, this._onStart);\n\n      if (OdoDevice.HAS_TOUCH_EVENTS) {\n        this.element.addEventListener(events.TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this.element.addEventListener(events.DRAGSTART, Pointer._preventDefault);\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  isXAxis() {\n    return this.options.axis === Pointer.Axis.X;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n  isYAxis() {\n    return this.options.axis === Pointer.Axis.Y;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n  isBothAxis() {\n    return this.options.axis === Pointer.Axis.BOTH;\n  }\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n  get friction() {\n    return this._friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this._friction = friction;\n  }\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  }\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  }\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n  _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  }\n\n  /**\n   * Drag start handler.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The drag event object.\n   * @private\n   */\n  _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(\n        this._trackVelocity.bind(this),\n        Pointer.VELOCITY_INTERVAL,\n      );\n    }\n  }\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this.options.preventEventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  }\n\n  /**\n   * Finish the drag move function.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @private\n   */\n  _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    const endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    const isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  }\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new Coordinate();\n    this.velocity = new Coordinate();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  }\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    const lastDelta = Coordinate.difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  }\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n  _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  }\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n  _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n  _shouldLock(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n  _shouldDeactivate(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!Pointer.Event}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new Pointer.Event({\n      type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.options.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity,\n    });\n  }\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n  _addDragHandlers(startType) {\n    const target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case events.POINTERDOWN:\n        target.addEventListener(events.POINTERMOVE, this._onMove);\n        target.addEventListener(events.POINTERUP, this._onEnd);\n        target.addEventListener(events.POINTERCANCEL, this._onEnd);\n        break;\n      case events.MOUSEDOWN:\n        target.addEventListener(events.MOUSEMOVE, this._onMove);\n        target.addEventListener(events.MOUSEUP, this._onEnd);\n        break;\n      case events.TOUCHSTART:\n        target.addEventListener(events.TOUCHMOVE, this._onMove);\n        target.addEventListener(events.TOUCHEND, this._onEnd);\n        target.addEventListener(events.TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  }\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n  _removeDragHandlers() {\n    const target = this.dragEventTarget;\n    target.removeEventListener(events.POINTERMOVE, this._onMove);\n    target.removeEventListener(events.POINTERUP, this._onEnd);\n    target.removeEventListener(events.POINTERCANCEL, this._onEnd);\n    target.removeEventListener(events.MOUSEMOVE, this._onMove);\n    target.removeEventListener(events.MOUSEUP, this._onEnd);\n    target.removeEventListener(events.TOUCHMOVE, this._onMove);\n    target.removeEventListener(events.TOUCHEND, this._onEnd);\n    target.removeEventListener(events.TOUCHCANCEL, this._onEnd);\n  }\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n  _trackVelocity() {\n    const now = Date.now();\n    const elapsed = now - this._lastTime;\n    const delta = Coordinate.difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    const maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = clamp(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = clamp(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  }\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n  hasVelocity(velocity, threshold = Pointer.SWIPE_VELOCITY) {\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Remove event listeners and element references.\n   */\n  dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this.element.removeEventListener(events.POINTERDOWN, this._onStart);\n    this.element.removeEventListener(events.MOUSEDOWN, this._onStart);\n    this.element.removeEventListener(events.TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this.element.style[Pointer.TouchActionSupport[this.options.axis]] = '';\n    } else if (this.options.preventEventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.removeEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.element = null;\n    this.dragEventTarget = null;\n  }\n\n  /**\n   * Whether the event is from a touch.\n   * @param {object} evt Event object.\n   * @return {boolean}\n   */\n  static isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  }\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  static _isCancelEvent(evt) {\n    return evt.type === events.POINTERCANCEL || evt.type === events.TOUCHCANCEL;\n  }\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n  static _getPageCoordinate(evt) {\n    let pagePoints;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new Coordinate(pagePoints.pageX, pagePoints.pageY);\n  }\n\n  static _preventDefault(evt) {\n    evt.preventDefault();\n  }\n}\n\n/** @enum {string} */\nPointer.Direction = Direction;\n\n/** @enum {string} */\nPointer.Axis = Axis;\n\n/** @enum {string} */\nPointer.EventType = {\n  START: 'odopointer:start',\n  MOVE: 'odopointer:move',\n  END: 'odopointer:end',\n};\n\n/** @enum {string|boolean} */\nPointer.TouchActionSupport = {\n  x: OdoDevice.prefixed('touchAction', 'pan-y'),\n  y: OdoDevice.prefixed('touchAction', 'pan-x'),\n  xy: OdoDevice.prefixed('touchAction', 'none'),\n};\n\n/** @enum {string} */\nPointer.TouchAction = {\n  x: 'pan-y',\n  y: 'pan-x',\n  xy: 'none',\n};\n\n/**\n * @typedef {{axis: Axis, preventEventDefault: boolean}} PointerOptions\n */\n\n/** @type {PointerOptions} */\nPointer.Defaults = {\n  axis: 'xy',\n  preventEventDefault: true,\n};\n\n/**\n * The current velocity property will be clamped to this value (pixels/millisecond).\n * @const {number}\n */\nPointer.MAX_VELOCITY = 12;\n\n/**\n * When the pointer is down, an interval starts to track the current velocity.\n * @const {number}\n */\nPointer.VELOCITY_INTERVAL = 100;\n\n/**\n * Velocity required for a movement to be considered a swipe.\n * @const {number}\n */\nPointer.SWIPE_VELOCITY = 0.6;\n\n/**\n * The scroll/drag amount (pixels) required on the draggable axis before\n * stopping further page scrolling/movement.\n * @const {number}\n */\nPointer.LOCK_THRESHOLD = 6;\n\n/**\n * The scroll/drag amount (pixels) required on the opposite draggable axis\n * before dragging is deactivated for the rest of the interaction.\n * @const {number}\n */\nPointer.DRAG_THRESHOLD = 5;\n\nPointer.Event = _PointerEvent;\n\nexport default Pointer;\n"],"names":["Direction","RIGHT","LEFT","UP","DOWN","NONE","Axis","X","Y","BOTH","isXAxis","axis","isYAxis","isBothAxis","hasDirection","direction","finiteOrZero","velocity","Number","isFinite","getVelocity","deltaTime","deltaX","deltaY","Coordinate","getTheDirection","value1","value2","isGreater","isLess","isEqual","getDirection","coord1","coord2","Math","abs","x","y","isOnAxis","isXAndLeftOrRight","isYAndUpOrDown","isBothAndNotNone","didMoveOnAxis","getAxisDirection","start","end","_start","Object","assign","_end","PointerEvent","options","type","target","currentTarget","delta","currentVelocity","distance","isDirectionOnAxis","axisDirection","position","defaultPrevented","preventDefault","Pointer","element","nodeType","TypeError","Defaults","pageStart","page","_lastPosition","_friction","hasDragged","_isLocked","_isDeactivated","_enabled","_velocityTrackerId","startTime","_lastTime","_hasTrackedVelocity","dragEventTarget","document","touchAction","TouchActionSupport","_isTouchActionSupported","preventEventDefault","style","TouchAction","OdoDevice","HAS_TOUCH_EVENTS","window","addEventListener","events","TOUCHMOVE","noop","listen","_onStart","_handleDragStart","bind","HAS_POINTER_EVENTS","POINTERDOWN","MOUSEDOWN","TOUCHSTART","DRAGSTART","_preventDefault","applyFriction","coordinate","scale","friction","_canStartDrag","evt","isEnabled","isTouchEvent","button","_canContinueDrag","clearInterval","_setDragStartValues","_getPageCoordinate","isPrevented","_emitEvent","_createEvent","EventType","START","_addDragHandlers","setInterval","_trackVelocity","VELOCITY_INTERVAL","_handleDragMove","_setDragMoveValues","MOVE","_finishDragMove","_maybeLock","_maybeDeactivate","_handleDragEnd","Date","now","_removeDragHandlers","endEvent","END","isCancelEvent","_isCancelEvent","pagePosition","lastDelta","difference","translate","_shouldLock","_shouldDeactivate","pastX","LOCK_THRESHOLD","pastY","DRAG_THRESHOLD","Event","pointerId","id","startType","_onMove","_onEnd","POINTERMOVE","POINTERUP","POINTERCANCEL","MOUSEMOVE","MOUSEUP","TOUCHEND","TOUCHCANCEL","removeEventListener","elapsed","maxVelocity","MAX_VELOCITY","clamp","hasVelocity","threshold","SWIPE_VELOCITY","event","emit","dispose","changedTouches","pagePoints","pageX","pageY","enabled","TinyEmitter","prefixed","xy","_PointerEvent"],"mappings":"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"}