{"version":3,"file":"odo-pointer.js","sources":["../src/settings.js","../src/pointer-event.js","../src/pointer.js"],"sourcesContent":["import OdoDevice from '@odopod/odo-device';\n\nexport default {\n  /** @enum {string} */\n  EventType: {\n    START: 'odopointer:start',\n    MOVE: 'odopointer:move',\n    END: 'odopointer:end',\n  },\n\n  /** @enum {string} */\n  Direction: {\n    RIGHT: 'right',\n    LEFT: 'left',\n    UP: 'up',\n    DOWN: 'down',\n    NONE: 'no_movement',\n  },\n\n  /** @enum {string|boolean} */\n  TouchActionSupport: {\n    x: OdoDevice.prefixed('touchAction', 'pan-y'),\n    y: OdoDevice.prefixed('touchAction', 'pan-x'),\n    xy: OdoDevice.prefixed('touchAction', 'none'),\n  },\n\n  /** @enum {string} */\n  TouchAction: {\n    x: 'pan-y',\n    y: 'pan-x',\n    xy: 'none',\n  },\n\n  /** @enum {string} */\n  Axis: {\n    X: 'x',\n    Y: 'y',\n    BOTH: 'xy',\n  },\n\n  Defaults: {\n    axis: 'xy',\n    preventEventDefault: true,\n  },\n\n  /**\n   * The current velocity property will be clamped to this value (pixels/millisecond).\n   * @const {number}\n   */\n  MAX_VELOCITY: 12,\n\n  /**\n   * When the pointer is down, an interval starts to track the current velocity.\n   * @const {number}\n   */\n  VELOCITY_INTERVAL: 100,\n\n  /**\n   * Velocity required for a movement to be considered a swipe.\n   * @const {number}\n   */\n  SWIPE_VELOCITY: 0.6,\n\n  /**\n   * The scroll/drag amount (pixels) required on the draggable axis before\n   * stopping further page scrolling/movement.\n   * @const {number}\n   */\n  LOCK_THRESHOLD: 6,\n\n  /**\n   * The scroll/drag amount (pixels) required on the opposite draggable axis\n   * before dragging is deactivated for the rest of the interaction.\n   * @const {number}\n   */\n  DRAG_THRESHOLD: 5,\n};\n","import { Coordinate } from '@odopod/odo-helpers';\nimport settings from './settings';\n\nfunction isXAxis(axis) {\n  return axis === settings.Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === settings.Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === settings.Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== settings.Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new Coordinate(\n    finiteOrZero(deltaX / deltaTime),\n    finiteOrZero(deltaY / deltaTime),\n  );\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(\n      coord1.x, coord2.x, settings.Direction.LEFT,\n      settings.Direction.RIGHT, settings.Direction.NONE,\n    );\n  }\n\n  return getTheDirection(\n    coord1.y, coord2.y, settings.Direction.UP,\n    settings.Direction.DOWN, settings.Direction.NONE,\n  );\n}\n\nfunction isOnAxis(axis, direction) {\n  const isXAndLeftOrRight = isXAxis(axis) && (\n    direction === settings.Direction.LEFT ||\n    direction === settings.Direction.RIGHT);\n\n  const isYAndUpOrDown = isYAxis(axis) && (\n    direction === settings.Direction.UP ||\n    direction === settings.Direction.DOWN);\n\n  const isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return (isXAxis(axis) && Math.abs(deltaX) > 0) ||\n\n  // Y axis and deltaY > 0\n  (isYAxis(axis) && Math.abs(deltaY) > 0) ||\n\n  // Both axis, as long as it actually moved.\n  (isBothAxis(axis) && hasDirection(direction));\n}\n\nfunction getAxisDirection(axis, start, end) {\n  const _start = Object.assign({}, start);\n  const _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nclass PointerEvent {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  constructor(options) {\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = Coordinate.distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {settings.Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(\n      options.axis, this.direction,\n      this.delta.x, this.delta.y,\n    );\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {settings.Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\nexport default PointerEvent;\n","/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney\n */\n\nimport TinyEmitter from 'tiny-emitter';\nimport OdoDevice from '@odopod/odo-device';\nimport {\n  clamp,\n  Coordinate,\n  events,\n  noop,\n} from '@odopod/odo-helpers';\nimport settings from './settings';\nimport PointerEvent from './pointer-event';\n\nclass Pointer extends TinyEmitter {\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {Element} element Element to watch.\n   * @param {Object} options Options object.\n   */\n  constructor(element, options = {}) {\n    super();\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    const opts = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * Whether to prevent the default event action on move.\n     * @type {boolean}\n     * @private\n     */\n    this._shouldPreventDefault = opts.preventEventDefault;\n\n    /**\n     * The draggable element.\n     * @type {Element}\n     * @private\n     */\n    this._el = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    this.pageStart = new Coordinate();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    this.page = new Coordinate();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    this.delta = new Coordinate();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    this._lastPosition = new Coordinate();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    this._friction = 1;\n\n    /**\n     * Draggable axis.\n     * @type {string}\n     * @private\n     */\n    this.axis = opts.axis;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    this.velocity = new Coordinate();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    this.dragEventTarget = document;\n\n    const touchAction = Pointer.TouchActionSupport[this.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (this._shouldPreventDefault && this._isTouchActionSupported) {\n      this.element.style[touchAction] = Pointer.TouchAction[this.axis];\n    } else if (this._shouldPreventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.addEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this.listen();\n  }\n\n  listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (OdoDevice.HAS_POINTER_EVENTS) {\n      this._el.addEventListener(events.POINTERDOWN, this._onStart);\n    } else {\n      this._el.addEventListener(events.MOUSEDOWN, this._onStart);\n\n      if (OdoDevice.HAS_TOUCH_EVENTS) {\n        this._el.addEventListener(events.TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this._el.addEventListener(events.DRAGSTART, Pointer._preventDefault);\n  }\n\n  /**\n   * Returns the draggable element.\n   * @return {Element}\n   */\n  get element() {\n    return this._el;\n  }\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n\n  /**\n   * Set whether dragger is enabled.\n   * @param {boolean} enabled Whether dragger is enabled.\n   */\n  set isEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  isXAxis() {\n    return this.axis === Pointer.Axis.X;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n  isYAxis() {\n    return this.axis === Pointer.Axis.Y;\n  }\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n  isBothAxis() {\n    return this.axis === Pointer.Axis.BOTH;\n  }\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n  get friction() {\n    return this._friction;\n  }\n\n  /**\n   * Set the friction value.\n   * @param {number} friction A number between [1, 0].\n   */\n  set friction(friction) {\n    this._friction = friction;\n  }\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  }\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  }\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n  _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  }\n\n  /**\n   * Drag start handler.\n   * @param  {Event} evt The drag event object.\n   * @private\n   */\n  _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(\n        this._trackVelocity.bind(this),\n        Pointer.VELOCITY_INTERVAL,\n      );\n    }\n  }\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {Event} evt The dragger event.\n   * @private\n   */\n  _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    const isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this._shouldPreventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  }\n\n  /**\n   * Finish the drag move function.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  }\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n  _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    const endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    const isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  }\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new Coordinate();\n    this.velocity = new Coordinate();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  }\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n  _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    const lastDelta = Coordinate.difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  }\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n  _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  }\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n  _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n  _shouldLock(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  }\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n  _shouldDeactivate(delta) {\n    const pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    const pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  }\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!PointerEvent}\n   * @private\n   */\n  _createEvent(type, evt) {\n    return new Pointer.Event({\n      type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity,\n    });\n  }\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n  _addDragHandlers(startType) {\n    const target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case events.POINTERDOWN:\n        target.addEventListener(events.POINTERMOVE, this._onMove);\n        target.addEventListener(events.POINTERUP, this._onEnd);\n        target.addEventListener(events.POINTERCANCEL, this._onEnd);\n        break;\n      case events.MOUSEDOWN:\n        target.addEventListener(events.MOUSEMOVE, this._onMove);\n        target.addEventListener(events.MOUSEUP, this._onEnd);\n        break;\n      case events.TOUCHSTART:\n        target.addEventListener(events.TOUCHMOVE, this._onMove);\n        target.addEventListener(events.TOUCHEND, this._onEnd);\n        target.addEventListener(events.TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  }\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n  _removeDragHandlers() {\n    const target = this.dragEventTarget;\n    target.removeEventListener(events.POINTERMOVE, this._onMove);\n    target.removeEventListener(events.POINTERUP, this._onEnd);\n    target.removeEventListener(events.POINTERCANCEL, this._onEnd);\n    target.removeEventListener(events.MOUSEMOVE, this._onMove);\n    target.removeEventListener(events.MOUSEUP, this._onEnd);\n    target.removeEventListener(events.TOUCHMOVE, this._onMove);\n    target.removeEventListener(events.TOUCHEND, this._onEnd);\n    target.removeEventListener(events.TOUCHCANCEL, this._onEnd);\n  }\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n  _trackVelocity() {\n    const now = Date.now();\n    const elapsed = now - this._lastTime;\n    const delta = Coordinate.difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    const maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = clamp(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = clamp(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  }\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n  hasVelocity(velocity, threshold = Pointer.SWIPE_VELOCITY) {\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  }\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Remove event listeners and element references.\n   */\n  dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this._el.removeEventListener(events.POINTERDOWN, this._onStart);\n    this._el.removeEventListener(events.MOUSEDOWN, this._onStart);\n    this._el.removeEventListener(events.TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this._el.style[Pointer.TouchActionSupport[this.axis]] = '';\n    } else if (this._shouldPreventDefault && OdoDevice.HAS_TOUCH_EVENTS) {\n      window.removeEventListener(events.TOUCHMOVE, noop);\n    }\n\n    this._el = null;\n    this.dragEventTarget = null;\n  }\n\n  /**\n   * Whether the event is from a touch.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   */\n  static isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  }\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {Event} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n  static _isCancelEvent(evt) {\n    return evt.type === events.POINTERCANCEL || evt.type === events.TOUCHCANCEL;\n  }\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {Event} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n  static _getPageCoordinate(evt) {\n    let pagePoints;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new Coordinate(pagePoints.pageX, pagePoints.pageY);\n  }\n\n  static _preventDefault(evt) {\n    evt.preventDefault();\n  }\n}\n\nObject.assign(Pointer, settings);\n\n/** @type {PointerEvent} */\nPointer.Event = PointerEvent;\n\nexport default Pointer;\n"],"names":["OdoDevice","prefixed","isXAxis","axis","settings","Axis","X","isYAxis","Y","isBothAxis","BOTH","hasDirection","direction","Direction","NONE","finiteOrZero","velocity","Number","isFinite","getVelocity","deltaTime","deltaX","deltaY","Coordinate","getTheDirection","value1","value2","isGreater","isLess","isEqual","getDirection","coord1","coord2","Math","abs","x","y","LEFT","RIGHT","UP","DOWN","isOnAxis","isXAndLeftOrRight","isYAndUpOrDown","isBothAndNotNone","didMoveOnAxis","getAxisDirection","start","end","_start","Object","assign","_end","PointerEvent","options","type","target","currentTarget","delta","currentVelocity","distance","isDirectionOnAxis","axisDirection","position","defaultPrevented","preventDefault","Pointer","element","nodeType","TypeError","opts","Defaults","_shouldPreventDefault","preventEventDefault","_el","pageStart","page","_lastPosition","_friction","hasDragged","_isLocked","_isDeactivated","_enabled","_velocityTrackerId","startTime","_lastTime","_hasTrackedVelocity","dragEventTarget","document","touchAction","TouchActionSupport","_isTouchActionSupported","style","TouchAction","HAS_TOUCH_EVENTS","addEventListener","events","TOUCHMOVE","noop","listen","_onStart","_handleDragStart","bind","HAS_POINTER_EVENTS","POINTERDOWN","MOUSEDOWN","TOUCHSTART","DRAGSTART","_preventDefault","applyFriction","coordinate","scale","friction","_canStartDrag","evt","isEnabled","isTouchEvent","button","_canContinueDrag","_setDragStartValues","_getPageCoordinate","isPrevented","_emitEvent","_createEvent","EventType","START","_addDragHandlers","setInterval","_trackVelocity","VELOCITY_INTERVAL","_handleDragMove","_setDragMoveValues","MOVE","_finishDragMove","_maybeLock","_maybeDeactivate","_handleDragEnd","Date","now","_removeDragHandlers","endEvent","END","isCancelEvent","_isCancelEvent","pagePosition","lastDelta","difference","translate","_shouldLock","_shouldDeactivate","pastX","LOCK_THRESHOLD","pastY","DRAG_THRESHOLD","Event","id","startType","_onMove","_onEnd","POINTERMOVE","POINTERUP","POINTERCANCEL","MOUSEMOVE","MOUSEUP","TOUCHEND","TOUCHCANCEL","removeEventListener","elapsed","maxVelocity","MAX_VELOCITY","clamp","hasVelocity","threshold","SWIPE_VELOCITY","event","emit","dispose","changedTouches","pagePoints","pageX","pageY","enabled","TinyEmitter"],"mappings":"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"}