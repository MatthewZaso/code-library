{"version":3,"file":"odo-scroll-animation.js","sources":["../src/scroll-animation.js"],"sourcesContent":["/**\n * @fileoverview A service for adding a scroll listener to a target (like the\n * page or a modal) and receiving a callback which is throttled to once per frame\n * using requestAnimationFrame. If the scroll event is dispatched more than once\n * in one frame, the service cancels the previous request and makes a new one.\n * It will only bind one scroll event listener per target, no matter the number\n * of callbacks associated with it.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nlet id = 0;\nfunction uniqueId() {\n  id += 1;\n  return `sa_${id}`;\n}\n\nfunction isWindow(obj) {\n  return obj && obj.window && obj.document && obj.location && obj.alert && obj.setInterval;\n}\n\nfunction isDocument(obj) {\n  return obj && obj.nodeType === 9;\n}\n\nconst service = {\n\n  /**\n   * A collection of scroll listeners the service is using.\n   * @type {Map.<string, Object>}\n   * @private\n   */\n  _listeners: new Map(),\n\n  /**\n   * A map of request animation frame ids for each target.\n   * @type {Map.<Element|Window, number>}\n   * @private\n   */\n  _targets: new Map(),\n\n  /**\n   * Finds all listeners registered with the given target element.\n   * @param {Window|Element} element Target element.\n   * @return {Array.<Function>} An array of listener functions.\n   * @private\n   */\n  _getListenersForTarget(element) {\n    const functions = [];\n\n    this._listeners.forEach((obj) => {\n      if (obj.target === element) {\n        functions.push(obj.fn);\n      }\n    });\n\n    return functions;\n  },\n\n  /**\n   * The window uses `pageXOffset` and `pageYOffset` while regular elements use\n   * `scrollLeft` and `scrollTop`.\n   * @param {Element|Window} target The element which scrolled.\n   * @return {{top: number, left: number}}\n   * @private\n   */\n  _getScrollPosition(target) {\n    let top;\n    let left;\n\n    // If this is a document or window, get the offset from the window.\n    if (isWindow(target)) {\n      // IE9+ have pageYOffset and pageXOffset.\n      top = window.pageYOffset;\n      left = window.pageXOffset;\n    } else {\n      top = target.scrollTop;\n      left = target.scrollLeft;\n    }\n\n    return {\n      top,\n      left,\n    };\n  },\n\n  /**\n   * Calls all handlers for a give target with the target's new scroll top\n   * value.\n   * @param {Element} target Element which was scrolled.\n   * @private\n   */\n  _callListeners(target) {\n    const scroll = this._getScrollPosition(target);\n\n    // Find all listeners tied to the element which is currently scrolling.\n    const listeners = this._getListenersForTarget(target);\n    for (let i = 0, len = listeners.length; i < len; i++) {\n      listeners[i](scroll.top, scroll.left);\n    }\n\n    // Remove the request id, meaning this request has finished.\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Handles scroll events on an element. It uses request animation frame\n   * to execute the real handlers only once per frame.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleTargetScrolled(evt) {\n    const target = /** @type {Element|Window} */ (evt.currentTarget);\n\n    // Cancel the last request animation frame if it hasn't executed yet.\n    if (this._targets.get(target)) {\n      cancelAnimationFrame(this._targets.get(target));\n    }\n\n    // Request a new animation frame.\n    const requestId = requestAnimationFrame(this._callListeners.bind(this, target));\n    this._targets.set(target, requestId);\n  },\n\n  /**\n   * Adds a scroll listener to a target.\n   * @param {Element|Window} target Element.\n   * @private\n   */\n  _register(target) {\n    target.addEventListener('scroll', this._onScroll, false);\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Remove the scroll listener and target from the map.\n   * @param {Element} target Target element.\n   * @private\n   */\n  _unregister(target) {\n    target.removeEventListener('scroll', this._onScroll, false);\n    this._targets.delete(target);\n  },\n\n  /**\n   * Add a new scroll listener to an optional target. Defaults to when the\n   * page is scrolled.\n   * @param {Element|Window|function(number):void} target Optional element. Default = window.\n   * @param {function(number):void} [fn] Callback method with the new scroll top\n   *     value as the first parameter.\n   * @return {string} Id to unbind with.\n   */\n  add(target, fn) {\n    // Assume the window/document should be the scroll target if none is provided.\n    if (typeof target === 'function') {\n      fn = target; // eslint-disable-line no-param-reassign\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    // Attach events to the window instead of the document.\n    if (isDocument(target)) {\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    if (!target || !target.addEventListener) {\n      throw new TypeError(`OdoScrollAnimation: \"${target}\" is not an Element, Document, or Window`);\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError(`OdoScrollAnimation: \"${fn}\" is not a function`);\n    }\n\n    // Check if this target already has a scroll listener.\n    if (!this._targets.has(target)) {\n      this._register(target);\n    }\n\n    const id = uniqueId();\n\n    this._listeners.set(id, {\n      target,\n      fn,\n    });\n\n    return id;\n  },\n\n  /**\n   * Remove a scroll listener by id.\n   * @param {string} id The id returned from adding it.\n   */\n  remove(id) {\n    const listener = this._listeners.get(id);\n    if (listener) {\n      const listeners = this._getListenersForTarget(listener.target);\n\n      // If this listener is the last one listening to this target, unbind\n      // the scroll event from it.\n      if (listeners.length === 1) {\n        this._unregister(listener.target);\n      }\n\n      this._listeners.delete(id);\n    }\n  },\n};\n\n// Proxied functions are different every time they are created. To be able to\n// remove the same handler, the context is bound here instead of inside `add`.\nservice._onScroll = service._handleTargetScrolled.bind(service);\n\nexport default service;\n"],"names":["id","uniqueId","isWindow","obj","window","document","location","alert","setInterval","isDocument","nodeType","service","_listeners","Map","_targets","_getListenersForTarget","element","functions","forEach","target","push","fn","_getScrollPosition","top","left","pageYOffset","pageXOffset","scrollTop","scrollLeft","_callListeners","scroll","listeners","i","len","length","set","_handleTargetScrolled","evt","currentTarget","get","cancelAnimationFrame","requestId","requestAnimationFrame","bind","_register","addEventListener","_onScroll","_unregister","removeEventListener","delete","add","TypeError","has","remove","listener"],"mappings":"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"}