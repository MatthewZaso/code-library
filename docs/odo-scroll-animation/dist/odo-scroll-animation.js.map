{"version":3,"file":"odo-scroll-animation.js","sources":["../src/scroll-animation.js"],"sourcesContent":["/**\n * @fileoverview A service for adding a scroll listener to a target (like the\n * page or a modal) and receiving a callback which is throttled to once per frame\n * using requestAnimationFrame. If the scroll event is dispatched more than once\n * in one frame, the service cancels the previous request and makes a new one.\n * It will only bind one scroll event listener per target, no matter the number\n * of callbacks associated with it.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nlet id = 0;\nfunction uniqueId() {\n  id += 1;\n  return `sa_${id}`;\n}\n\nfunction isWindow(obj) {\n  return obj && obj.window && obj.document && obj.location && obj.alert && obj.setInterval;\n}\n\nfunction isDocument(obj) {\n  return obj && obj.nodeType === 9;\n}\n\nconst service = {\n\n  /**\n   * A collection of scroll listeners the service is using.\n   * @type {Map.<string, Object>}\n   * @private\n   */\n  _listeners: new Map(),\n\n  /**\n   * A map of request animation frame ids for each target.\n   * @type {Map.<Element|Window, number>}\n   * @private\n   */\n  _targets: new Map(),\n\n  /**\n   * Finds all listeners registered with the given target element.\n   * @param {Window|Element} element Target element.\n   * @return {Array.<Function>} An array of listener functions.\n   * @private\n   */\n  _getListenersForTarget(element) {\n    const functions = [];\n\n    this._listeners.forEach((obj) => {\n      if (obj.target === element) {\n        functions.push(obj.fn);\n      }\n    });\n\n    return functions;\n  },\n\n  /**\n   * The window uses `pageXOffset` and `pageYOffset` while regular elements use\n   * `scrollLeft` and `scrollTop`.\n   * @param {Element|Window} target The element which scrolled.\n   * @return {{top: number, left: number}}\n   * @private\n   */\n  _getScrollPosition(target) {\n    let top;\n    let left;\n\n    // If this is a document or window, get the offset from the window.\n    if (isWindow(target)) {\n      // IE9+ have pageYOffset and pageXOffset.\n      top = window.pageYOffset;\n      left = window.pageXOffset;\n    } else {\n      top = target.scrollTop;\n      left = target.scrollLeft;\n    }\n\n    return {\n      top,\n      left,\n    };\n  },\n\n  /**\n   * Calls all handlers for a give target with the target's new scroll top\n   * value.\n   * @param {Element} target Element which was scrolled.\n   * @private\n   */\n  _callListeners(target) {\n    const scroll = this._getScrollPosition(target);\n\n    // Find all listeners tied to the element which is currently scrolling.\n    const listeners = this._getListenersForTarget(target);\n    for (let i = 0, len = listeners.length; i < len; i++) {\n      listeners[i](scroll.top, scroll.left);\n    }\n\n    // Remove the request id, meaning this request has finished.\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Handles scroll events on an element. It uses request animation frame\n   * to execute the real handlers only once per frame.\n   * @param {Event} evt Event object.\n   * @private\n   */\n  _handleTargetScrolled(evt) {\n    const target = /** @type {Element|Window} */ (evt.currentTarget);\n\n    // Cancel the last request animation frame if it hasn't executed yet.\n    if (this._targets.get(target)) {\n      cancelAnimationFrame(this._targets.get(target));\n    }\n\n    // Request a new animation frame.\n    const requestId = requestAnimationFrame(this._callListeners.bind(this, target));\n    this._targets.set(target, requestId);\n  },\n\n  /**\n   * Adds a scroll listener to a target.\n   * @param {Element|Window} target Element.\n   * @private\n   */\n  _register(target) {\n    target.addEventListener('scroll', this._onScroll, false);\n    this._targets.set(target, null);\n  },\n\n  /**\n   * Remove the scroll listener and target from the map.\n   * @param {Element} target Target element.\n   * @private\n   */\n  _unregister(target) {\n    target.removeEventListener('scroll', this._onScroll, false);\n    this._targets.delete(target);\n  },\n\n  /**\n   * Add a new scroll listener to an optional target. Defaults to when the\n   * page is scrolled.\n   * @param {Element|Window|function(number):void} target Optional element. Default = window.\n   * @param {function(number):void} [fn] Callback method with the new scroll top\n   *     value as the first parameter.\n   * @return {string} Id to unbind with.\n   */\n  add(target, fn) {\n    // Assume the window/document should be the scroll target if none is provided.\n    if (typeof target === 'function') {\n      fn = target; // eslint-disable-line no-param-reassign\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    // Attach events to the window instead of the document.\n    if (isDocument(target)) {\n      target = window; // eslint-disable-line no-param-reassign\n    }\n\n    if (!target || !target.addEventListener) {\n      throw new TypeError(`OdoScrollAnimation: \"${target}\" is not an Element, Document, or Window`);\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError(`OdoScrollAnimation: \"${fn}\" is not a function`);\n    }\n\n    // Check if this target already has a scroll listener.\n    if (!this._targets.has(target)) {\n      this._register(target);\n    }\n\n    const id = uniqueId();\n\n    this._listeners.set(id, {\n      target,\n      fn,\n    });\n\n    return id;\n  },\n\n  /**\n   * Remove a scroll listener by id.\n   * @param {string} id The id returned from adding it.\n   */\n  remove(id) {\n    const listener = this._listeners.get(id);\n    if (listener) {\n      const listeners = this._getListenersForTarget(listener.target);\n\n      // If this listener is the last one listening to this target, unbind\n      // the scroll event from it.\n      if (listeners.length === 1) {\n        this._unregister(listener.target);\n      }\n\n      this._listeners.delete(id);\n    }\n  },\n};\n\n// Proxied functions are different every time they are created. To be able to\n// remove the same handler, the context is bound here instead of inside `add`.\nservice._onScroll = service._handleTargetScrolled.bind(service);\n\nexport default service;\n"],"names":["id","uniqueId","isWindow","obj","window","document","location","alert","setInterval","isDocument","nodeType","service","Map","element","functions","_listeners","forEach","target","push","fn","top","left","pageYOffset","pageXOffset","scrollTop","scrollLeft","scroll","_getScrollPosition","listeners","_getListenersForTarget","i","len","length","_targets","set","evt","currentTarget","get","requestId","requestAnimationFrame","_callListeners","bind","addEventListener","_onScroll","removeEventListener","delete","TypeError","has","_register","listener","_unregister","_handleTargetScrolled"],"mappings":"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"}