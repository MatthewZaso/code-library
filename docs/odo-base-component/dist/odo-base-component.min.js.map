{"version":3,"file":"odo-base-component.min.js","sources":["../node_modules/debounce/index.js","../src/base-component.js"],"sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n","import debounce from 'debounce';\nimport TinyEmitter from 'tiny-emitter';\n\n/**\n * A class to be inherited from for components which interact with the DOM.\n * @extends {TinyEmitter}\n */\nclass BaseComponent extends TinyEmitter {\n  /**\n   * Create a new base component.\n   * @param {Element} element Main element which represents this class.\n   * @param {boolean} [addMediaListeners=false] Whether or not to add media\n   *     query listeners to allow this component to react to media changes.\n   * @throws {TypeError} Throws when the element is not defined.\n   */\n  constructor(element, addMediaListeners = false) {\n    super();\n\n    if (!element) {\n      throw new TypeError(`${this.constructor.name}'s \"element\" in the constructor must be element. Got: \"${element}\".`);\n    }\n\n    /**\n     * Main element for this class.\n     * @type {Element}\n     */\n    this.element = element;\n\n    if (addMediaListeners && BaseComponent.hasMediaQueries) {\n      this._registerMediaQueryListeners();\n    }\n  }\n\n  /**\n   * Determine the context for queries to the DOM.\n   * @param {Element} [context=this.element] Optional element to search within.\n   * @return {!Element}\n   * @private\n   */\n  _getContext(context = this.element) {\n    return context;\n  }\n\n  /**\n   * Retrieve an element by class name within the main element for this class.\n   * @param {string} klass Name of the class to search for.\n   * @param {Element} [context] Element to search within. Defaults to main element.\n   * @return {?Element} The first element which matches the class name, or null.\n   */\n  getElementByClass(klass, context) {\n    return this._getContext(context).getElementsByClassName(klass)[0] || null;\n  }\n\n  /**\n   * Retrieve elements by class name within the main element for this class.\n   * @param {string} klass Name of the class to search for.\n   * @param {Element} [context] Element to search within. Defaults to main element.\n   * @return {Array.<Element>} An array of elements matching the class name.\n   */\n  getElementsByClass(klass, context) {\n    return Array.from(this._getContext(context).getElementsByClassName(klass));\n  }\n\n  /**\n   * Retrieve elements by selector within the main element for this class.\n   * @param {string} selector Selector to search for.\n   * @param {Element} [context] Element to search within. Defaults to main element.\n   * @return {Array.<Element>} An array of elements matching the selector.\n   */\n  getElementsBySelector(selector, context) {\n    return Array.from(this._getContext(context).querySelectorAll(selector));\n  }\n\n  /**\n   * Alias for the static getter `breakpoint`.\n   * @return {Object}\n   */\n  get breakpoint() {\n    return BaseComponent.breakpoint;\n  }\n\n  /**\n   * Override this method to respond to media query changes.\n   */\n  onMediaQueryChange() {}\n\n  /**\n   * Clean up element references and event listeners.\n   */\n  dispose() {\n    this.element = null;\n\n    if (this._onMediaChange) {\n      Object.keys(BaseComponent.queries).forEach((k) => {\n        BaseComponent.queries[k].removeListener(this._onMediaChange);\n      });\n\n      this._onMediaChange = null;\n    }\n  }\n\n  _registerMediaQueryListeners() {\n    this._onMediaChange = debounce(this.onMediaQueryChange.bind(this), 50);\n    Object.keys(BaseComponent.queries).forEach((k) => {\n      BaseComponent.queries[k].addListener(this._onMediaChange);\n    });\n  }\n\n  /**\n   * Returns an object with `matches` and `current`. This is an alias for\n   * `BaseComponent.matches` and `BaseComponent.getCurrentBreakpoint()`.\n   * @return {!Object}\n   * @static\n   */\n  static get breakpoint() {\n    return {\n      matches: BaseComponent.matches,\n      get current() {\n        return BaseComponent.getCurrentBreakpoint();\n      },\n    };\n  }\n\n  /**\n   * Query the media query list to see if it currently matches.\n   * @param {string} key Breakpoint key to see if it matches.\n   * @return {boolean} Whether the given key is the current breakpoint.\n   * @throws {Error} Will throw an error if the key is not recognized.\n   * @static\n   */\n  static matches(key) {\n    if (BaseComponent.queries[key]) {\n      return BaseComponent.queries[key].matches;\n    }\n\n    throw new Error(`Unrecognized breakpoint key: \"${key}\"`);\n  }\n\n  /**\n   * Loop through the 4 media query lists to determine which one currently\n   * matches. Returns the key which matches or `null` if none match.\n   * @return {?string}\n   * @static\n   */\n  static getCurrentBreakpoint() {\n    const key = Object.keys(BaseComponent.queries)\n      .find(k => BaseComponent.queries[k].matches);\n\n    return key || null;\n  }\n\n  /**\n   * Create a new media queries object with keys for each breakpoint.\n   * @param {Array.<number>} bps Array of breakpoints.\n   * @return {!Object}\n   * @private\n   * @static\n   */\n  static _getQueries(bps) {\n    return {\n      xs: matchMedia(`(max-width:${bps[0] - 1}px)`),\n      sm: matchMedia(`(min-width:${bps[0]}px) and (max-width:${bps[1] - 1}px)`),\n      md: matchMedia(`(min-width:${bps[1]}px) and (max-width:${bps[2] - 1}px)`),\n      lg: matchMedia(`(min-width:${bps[2]}px)`),\n    };\n  }\n\n  /**\n   * Allows you to redefine the default breakpoints. If you want to redefine\n   * breakpoints, make sure you call this method before initializing classes\n   * which inherit from BaseComponent.\n   * @param {Array.<number>} breakpoints An array of 3 numbers.\n   * @static\n   */\n  static defineBreakpoints(breakpoints) {\n    BaseComponent.BREAKPOINTS = breakpoints;\n    BaseComponent.queries = BaseComponent._getQueries(breakpoints);\n  }\n}\n\n// Define breakpoints commonly used on Odopod projects.\nBaseComponent.defineBreakpoints([768, 1024, 1392]);\n\n/**\n * Array of breakpoint key names.\n * @type {Array.<string>}\n */\nBaseComponent.BREAKPOINT_NAMES = Object.keys(BaseComponent.queries);\n\n/**\n * Support: IE9\n * Whether the browser has `addListener` on `MediaQueryList` instances.\n * @type {boolean}\n */\nBaseComponent.hasMediaQueries = typeof BaseComponent.queries.xs.addListener === 'function';\n\nexport default BaseComponent;\n"],"names":["func","wait","immediate","later","last","Date","now","timestamp","setTimeout","apply","context","args","timeout","result","debounced","this","arguments","callNow","clear","BaseComponent","element","addMediaListeners","_TinyEmitter","TypeError","_this","constructor","name","hasMediaQueries","_registerMediaQueryListeners","_getContext","getElementByClass","klass","getElementsByClassName","getElementsByClass","Array","from","getElementsBySelector","selector","querySelectorAll","onMediaQueryChange","dispose","_onMediaChange","keys","queries","forEach","k","removeListener","_this2","debounce","bind","addListener","_this3","matches","key","Error","getCurrentBreakpoint","Object","find","_getQueries","bps","matchMedia","defineBreakpoints","breakpoints","BREAKPOINTS","breakpoint","TinyEmitter","BREAKPOINT_NAMES","xs"],"mappings":"+RAeA,MAAiB,SAAkBA,EAAMC,EAAMC,YAIpCC,QACHC,EAAOC,KAAKC,MAAQC,EAEpBH,EAAOH,GAAQG,GAAQ,IACfI,WAAWL,EAAOF,EAAOG,MAEzB,KACLF,MACMF,EAAKS,MAAMC,EAASC,KACnBA,EAAO,WAZnBC,EAASD,EAAMD,EAASH,EAAWM,EACnC,MAAQZ,IAAMA,EAAO,SAgBrBa,EAAY,aACJC,OACHC,YACKX,KAAKC,UACbW,EAAUf,IAAcU,SACvBA,IAASA,EAAUJ,WAAWL,EAAOF,IACtCgB,MACOjB,EAAKS,MAAMC,EAASC,KACnBA,EAAO,MAGZE,YAGCK,MAAQ,WACZN,iBACWA,KACH,OAIPE,uzBC/CHK,yBAQQC,OAASC,iFACnBC,kBAEKF,QACG,IAAIG,UAAaC,EAAKC,YAAYC,gEAA8DN,iBAOnGA,QAAUA,EAEXC,GAAqBF,EAAcQ,mBAChCC,2DAUTC,qFAAsBd,KAAKK,qBAU3BU,2BAAkBC,EAAOrB,UAChBK,KAAKc,YAAYnB,GAASsB,uBAAuBD,GAAO,IAAM,kBASvEE,4BAAmBF,EAAOrB,UACjBwB,MAAMC,KAAKpB,KAAKc,YAAYnB,GAASsB,uBAAuBD,iBASrEK,+BAAsBC,EAAU3B,UACvBwB,MAAMC,KAAKpB,KAAKc,YAAYnB,GAAS4B,iBAAiBD,iBAc/DE,4CAKAC,mCACOpB,QAAU,KAEXL,KAAK0B,wBACAC,KAAKvB,EAAcwB,SAASC,QAAQ,SAACC,KAC5BF,QAAQE,GAAGC,eAAeC,EAAKN,uBAG1CA,eAAiB,mBAI1Bb,wDACOa,eAAiBO,EAASjC,KAAKwB,mBAAmBU,KAAKlC,MAAO,WAC5D2B,KAAKvB,EAAcwB,SAASC,QAAQ,SAACC,KAC5BF,QAAQE,GAAGK,YAAYC,EAAKV,qBA0BvCW,iBAAQC,MACTlC,EAAcwB,QAAQU,UACjBlC,EAAcwB,QAAQU,GAAKD,cAG9B,IAAIE,uCAAuCD,UAS5CE,uCACOC,OAAOd,KAAKvB,EAAcwB,SACnCc,KAAK,mBAAKtC,EAAcwB,QAAQE,GAAGO,WAExB,QAUTM,qBAAYC,aAEXC,0BAAyBD,EAAI,GAAK,aAClCC,yBAAyBD,EAAI,0BAAwBA,EAAI,GAAK,aAC9DC,yBAAyBD,EAAI,0BAAwBA,EAAI,GAAK,aAC9DC,yBAAyBD,EAAI,cAW9BE,2BAAkBC,KACTC,YAAcD,IACdnB,QAAUxB,EAAcuC,YAAYI,iDAlG3C3C,EAAc6C,+DAsCV7C,EAAciC,6BAEdjC,EAAcoC,gCA/GDU,UA8K5B9C,EAAc0C,mBAAmB,IAAK,KAAM,OAM5C1C,EAAc+C,iBAAmBV,OAAOd,KAAKvB,EAAcwB,SAO3DxB,EAAcQ,gBAAkE,mBAAzCR,EAAcwB,QAAQwB,GAAGjB"}