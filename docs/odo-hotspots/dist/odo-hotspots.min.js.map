{"version":3,"file":"odo-hotspots.min.js","sources":["../src/unique-id.js","../node_modules/debounce/index.js","../src/settings.js","../src/hotspot.js","../src/hotspots.js"],"sourcesContent":["let count = 0;\nexport default function setUniqueId(element) {\n  if (!element.id) {\n    count += 1;\n    element.id = `odo-hotspots${count}`;\n  }\n}\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n","export default {\n  ClassName: {\n    HOTSPOT: 'odo-hotspot',\n    HOTSPOT_LEFT: 'odo-hotspot--left',\n    HOTSPOT_RIGHT: 'odo-hotspot--right',\n    HOTSPOT_TOP: 'odo-hotspot--top',\n    HOTSPOT_BOTTOM: 'odo-hotspot--bottom',\n    BUTTON: 'odo-hotspot__button',\n    CONTENT: 'odo-hotspot__content',\n    LOADED: 'is-loaded',\n    OPEN: 'is-open',\n  },\n\n  EventType: {\n    INITIALIZED: 'odohotspotsinitialized',\n    WILL_OPEN: 'odohotspotswillopen',\n    WILL_CLOSE: 'odohotspotswillclose',\n  },\n};\n","import settings from './settings';\nimport setUniqueId from './unique-id';\n\nclass Hotspot {\n  /**\n   * The hotspot class represents a single hotspot.\n   * @param {Element} element Main wrapper element for the hotspot.\n   * @param {Hotspots} parent A reference to the parent class.\n   * @constructor\n   */\n  constructor(element, parent) {\n    this.parent = parent;\n    this.isOpen = false;\n    this.wrapper = element;\n    this.button = element.querySelector('.' + settings.ClassName.BUTTON);\n    this.content = element.querySelector('.' + settings.ClassName.CONTENT);\n    this.percentPosition = this.parseWrapperPosition();\n    this.size = this.getContentSize();\n    this.side = this.getSide();\n    this.anchor = this.getAnchor();\n    this.position = this.getWrapperPosition();\n  }\n\n  /**\n   * Converts the data-position=\"x,y\" attribute to an object with x and y properties.\n   * @return {{x: number, y: number}}\n   */\n  parseWrapperPosition() {\n    const positions = this.wrapper.getAttribute('data-position').split(',');\n    return {\n      x: parseInt(positions[0], 10),\n      y: parseInt(positions[1], 10),\n    };\n  }\n\n  /**\n   * Returns the width and height of the content element.\n   * @return {{width: number, height: number}}\n   */\n  getContentSize() {\n    return {\n      width: this.content.offsetWidth,\n      height: this.content.offsetHeight,\n    };\n  }\n\n  /**\n   * Returns the class name of the side the hotspot should go to. If it doesn't\n   * have a side, a side will be calculated for it.\n   * @return {?string}\n   */\n  getSide() {\n    if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_LEFT)) {\n      return settings.ClassName.HOTSPOT_LEFT;\n    } else if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_RIGHT)) {\n      return settings.ClassName.HOTSPOT_RIGHT;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the class name of the anchor the hotspot should go to. If it doesn't\n   * have a anchor, a anchor will be calculated for it.\n   * @return {?string}\n   */\n  getAnchor() {\n    if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_TOP)) {\n      return settings.ClassName.HOTSPOT_TOP;\n    } else if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_BOTTOM)) {\n      return settings.ClassName.HOTSPOT_BOTTOM;\n    }\n    return null;\n  }\n\n  /**\n   * Updates the position and size of the hotspot.\n   */\n  refresh() {\n    // Read\n    this.size = this.getContentSize();\n    this.position = this.getWrapperPosition();\n\n    // Write async so that multiple hotspots can be refreshed at a time without\n    // causing layout thrashing.\n    this.refreshId = requestAnimationFrame(() => {\n      this._removeContentPosition();\n      this._setContentPosition();\n    });\n  }\n\n  /**\n   * Applies the data-position attribute to the wrapper.\n   */\n  _setWrapperPosition() {\n    this.wrapper.style.left = this.percentPosition.x + '%';\n    this.wrapper.style.top = this.percentPosition.y + '%';\n  }\n\n  /**\n   * Returns a rectangle describing the wrapper (not the content).\n   * @return {Object}\n   */\n  getWrapperPosition() {\n    const left = Math.round(this.parent.size.width * this.percentPosition.x / 100);\n    const top = Math.round(this.parent.size.height * this.percentPosition.y / 100);\n    const width = Math.round(this.wrapper.offsetWidth);\n    const height = Math.round(this.wrapper.offsetHeight);\n    return {\n      left,\n      top,\n      right: left + width,\n      bottom: top + height,\n    };\n  }\n\n  /**\n   * Determines the side which the hotspot should go to based on the container's\n   * width and the width of the hotspot content.\n   * @return {string}\n   */\n  _getOptimalSide() {\n    let side = null;\n\n    const fitsRight = this.position.right + this.size.width <= this.parent.size.width;\n    const fitsLeft = this.position.left - this.size.width >= 0;\n\n    // If both or neither fit, choose the side which has more room.\n    if ((fitsLeft && fitsRight) || (!fitsLeft && !fitsRight)) {\n      if (this.percentPosition.x < 50) {\n        side = settings.ClassName.HOTSPOT_RIGHT;\n      } else {\n        side = settings.ClassName.HOTSPOT_LEFT;\n      }\n\n    // If only on side fits, then it has to be chosen.\n    } else if (fitsRight) {\n      side = settings.ClassName.HOTSPOT_RIGHT;\n    } else /* fitsLeft */ {\n      side = settings.ClassName.HOTSPOT_LEFT;\n    }\n\n    return side;\n  }\n\n  /**\n   * Determines the anchor which the hotspot should go to based on the container's\n   * height and the height of the hotspot content.\n   * @return {string}\n   */\n  _getOptimalAnchor() {\n    let anchor = null;\n\n    const fitsTop = this.position.bottom - this.size.height >= 0;\n    const fitsBottom = this.position.top + this.size.height <= this.parent.size.height;\n\n    // If both or neither fit, choose the anchor which has more room.\n    if ((fitsBottom && fitsTop) || (!fitsBottom && !fitsTop)) {\n      if (this.percentPosition.y > 50) {\n        anchor = settings.ClassName.HOTSPOT_TOP;\n      } else {\n        anchor = settings.ClassName.HOTSPOT_BOTTOM;\n      }\n\n    // If only on anchor fits, then it has to be chosen.\n    } else if (fitsTop) {\n      anchor = settings.ClassName.HOTSPOT_TOP;\n    } else /* fitsBottom */ {\n      anchor = settings.ClassName.HOTSPOT_BOTTOM;\n    }\n\n    return anchor;\n  }\n\n  /**\n   * If the hotspot does not have a side or anchor, they will be set for it.\n   */\n  _setContentPosition() {\n    if (this.side === null) {\n      this.wrapper.classList.add(this._getOptimalSide());\n    }\n\n    if (this.anchor === null) {\n      this.wrapper.classList.add(this._getOptimalAnchor());\n    }\n  }\n\n  /**\n   * If the hotspot did not have a side or anchor originally, they will be removed.\n   */\n  _removeContentPosition() {\n    if (this.side === null) {\n      this.wrapper.classList.remove(\n        settings.ClassName.HOTSPOT_LEFT,\n        settings.ClassName.HOTSPOT_RIGHT,\n      );\n    }\n\n    if (this.anchor === null) {\n      this.wrapper.classList.remove(\n        settings.ClassName.HOTSPOT_TOP,\n        settings.ClassName.HOTSPOT_BOTTOM,\n      );\n    }\n  }\n\n  /**\n   * Positions the wrapper and the content.\n   */\n  setPosition() {\n    this._setWrapperPosition();\n    this._setContentPosition();\n  }\n\n  /**\n   * Show the hotspot.\n   */\n  show() {\n    this.wrapper.classList.add(settings.ClassName.OPEN);\n    this.content.setAttribute('aria-hidden', false);\n    this.button.setAttribute('aria-describedby', this.content.id);\n    this.isOpen = true;\n  }\n\n  /**\n   * Hide the hotspot.\n   */\n  hide() {\n    this.wrapper.classList.remove(settings.ClassName.OPEN);\n    this.content.setAttribute('aria-hidden', true);\n    this.button.removeAttribute('aria-describedby');\n    this.isOpen = false;\n  }\n\n  /**\n   * Set accessibility attributes so that the implementor doesn't have to worry\n   * about it.\n   */\n  setA11yAttributes() {\n    setUniqueId(this.content);\n    this.content.setAttribute('aria-hidden', true);\n    this.content.setAttribute('role', 'tooltip');\n  }\n\n  _removeA11yAttributes() {\n    this.button.removeAttribute('aria-hidden');\n    this.content.removeAttribute('role');\n  }\n\n  /**\n   * Destroys the hotspot instance. It removes DOM references, classes, and styles\n   * set by this class.\n   */\n  dispose() {\n    cancelAnimationFrame(this.refreshId);\n    this._removeContentPosition();\n    this._removeA11yAttributes();\n    this.wrapper.style.left = '';\n    this.wrapper.style.top = '';\n    this.wrapper = null;\n    this.button = null;\n    this.content = null;\n    this.parent = null;\n  }\n}\n\nexport default Hotspot;\n","import TinyEmitter from 'tiny-emitter';\nimport debounce from 'debounce';\nimport Hotspot from './hotspot';\nimport settings from './settings';\n\nclass Hotspots extends TinyEmitter {\n  /**\n   * Component which has a draggable element in the middle which reveals one or\n   * the other sides as the user drags.\n   *\n   * @constructor\n   */\n  constructor(el) {\n    super();\n    this.element = el;\n\n    this.size = this._getContainerSize();\n    this.hotspots = this._getHotspots();\n    this._noopElement = this._getFirstBodyDescendant();\n    this._noop = () => {};\n\n    this._activeHotspot = null;\n\n    this._bindEvents();\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.setA11yAttributes();\n      hotspot.setPosition();\n    });\n\n    this.element.classList.add(Hotspots.ClassName.LOADED);\n    this.dispatchEvent(Hotspots.EventType.INITIALIZED);\n  }\n\n  /**\n   * Scope the query to the main element.\n   * @param {string} className Class name of the desired elements.\n   * @return {Array.<Element>} An array of elements.\n   */\n  getElementsByClass(className) {\n    return Array.from(this.element.querySelectorAll('.' + className));\n  }\n\n  /**\n   * In iOS, event delegation does not work for click events.\n   * http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   * @return {?Element} The first child of the body which is a parent of the\n   *     main element in this class.\n   */\n  _getFirstBodyDescendant() {\n    let { element } = this;\n    while (element) {\n      const parent = element.parentElement;\n      if (parent === document.body) {\n        return element;\n      }\n\n      element = parent;\n    }\n\n    return null;\n  }\n\n  /**\n   * Creates the hotspot instances.\n   * @return {Array.<Hotspot>}\n   */\n  _getHotspots() {\n    return this.getElementsByClass(Hotspots.ClassName.HOTSPOT)\n      .map(element => new Hotspot(element, this));\n  }\n\n  /**\n   * Finds the hotspot instance which uses the given wrapper element.\n   * @param {Element} wrapper Element.\n   * @return {?Hotspot}\n   */\n  _getHotspotByWrapper(wrapper) {\n    for (let i = 0, len = this.hotspots.length; i < len; i++) {\n      if (this.hotspots[i].wrapper === wrapper) {\n        return this.hotspots[i];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the dimensions of the main element.\n   * @return {{width: number, height: number}}\n   */\n  _getContainerSize() {\n    return {\n      width: this.element.offsetWidth,\n      height: this.element.offsetHeight,\n    };\n  }\n\n  /**\n   * Triggers a custom event on the main element.\n   * @param {string} eventName Name of event.\n   * @param {Hotspot} [hotspot] Optional hotspot object.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  dispatchEvent(eventName, hotspot) {\n    const event = {\n      defaultPrevented: false,\n      preventDefault() {\n        this.defaultPrevented = true;\n      },\n    };\n\n    if (hotspot) {\n      event.hotspot = hotspot;\n    }\n\n    this.emit(eventName, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Add event listeners.\n   */\n  _bindEvents() {\n    this._clickHandler = this._handleHotspotClick.bind(this);\n    this._resizeHandler = debounce(this._handleResize.bind(this), 200);\n    this._loadHandler = this._handleLoad.bind(this);\n    this._outerClickHandler = this._handleOuterClick.bind(this);\n\n    window.addEventListener('resize', this._resizeHandler, false);\n    window.addEventListener('load', this._loadHandler, false);\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.button.addEventListener('click', this._clickHandler, false);\n    });\n  }\n\n  /**\n   * Closes all open hotspots so that only one can be open at a time.\n   */\n  closeAllHotspots() {\n    this.hotspots.forEach((hotspot) => {\n      this.closeHotspot(hotspot);\n    });\n  }\n\n  /**\n   * Toggles the display of a hotspot.\n   * @param {Hotspot} hotspot Hotspot to toggle.\n   */\n  toggleHotspot(hotspot) {\n    if (hotspot.isOpen) {\n      this.closeHotspot(hotspot);\n    } else {\n      this.openHotspot(hotspot);\n    }\n  }\n\n  /**\n   * Attempts to show the hotspot. It will emit an event which, if preventDefault\n   * is called on, can be canceled.\n   * @param {Hotspot} hotspot Hotspot to open.\n   */\n  openHotspot(hotspot) {\n    // If preventDefault is called on this event, do not open the hotspot.\n    if (hotspot.isOpen || this.dispatchEvent(Hotspots.EventType.WILL_OPEN, hotspot)) {\n      return;\n    }\n\n    this.closeAllHotspots();\n    hotspot.show();\n    this.setActiveHotspot(hotspot);\n\n    // Listen for clicks outside the hotspot which will close it.\n    // In a timeout so that a click on the hotspot button doesn't bubble\n    // up to the body and register as a click outside the hotspot.\n    setTimeout(() => {\n      this._listenForOuterClicks();\n    }, 0);\n  }\n\n  /**\n   * Attempts to hide the hotspot. It will emit an event which, if preventDefault\n   * is called on, can be canceled.\n   * @param {Hotspot} hotspot Hotspot to close.\n   */\n  closeHotspot(hotspot) {\n    // If preventDefault is called on this event, do not close the hotspot.\n    if (!hotspot.isOpen || this.dispatchEvent(Hotspots.EventType.WILL_CLOSE, hotspot)) {\n      return;\n    }\n\n    hotspot.hide();\n    this.setActiveHotspot(null);\n    this._removeOuterClick();\n  }\n\n  /**\n   * Bind a click listener to the body which closes any active hotspots if the\n   * user clicked outside of the current hotspot. This method also adds a no-op\n   * event lister to the first child of the body that is a parent of this module.\n   * This is due to a bug in iOS where click events do not bubble properly.\n   * The no-op element's tap highlight color is also set to transparent because\n   * it would show the default color on tap because it has a click handler.\n   */\n  _listenForOuterClicks() {\n    this._noopElement.addEventListener('click', this._noop, false);\n    this._noopElement.style.WebkitTapHighlightColor = 'transparent';\n    document.body.addEventListener('click', this._outerClickHandler, false);\n  }\n\n  /**\n   * Remove the delegated click listeners and tap highlight color.\n   */\n  _removeOuterClick() {\n    this._noopElement.removeEventListener('click', this._noop, false);\n    this._noopElement.style.WebkitTapHighlightColor = '';\n    document.body.removeEventListener('click', this._outerClickHandler, false);\n  }\n\n  /**\n   * Listener for clicks on the button inside the hotspot and toggles the hotspot's state.\n   * @param {Event} evt Click event object.\n   */\n  _handleHotspotClick(evt) {\n    evt.preventDefault();\n    const hotspot = this._getHotspotByWrapper(evt.currentTarget.parentElement);\n    this.toggleHotspot(hotspot);\n  }\n\n  /**\n   * When a hotspot is open, this handler is active. If the user clicks outside\n   * the hotspot, it will be closed.\n   * @param {Event} evt Click event object.\n   */\n  _handleOuterClick(evt) {\n    if (!this.getActiveHotspot().content.contains(evt.target)) {\n      this.closeHotspot(this.getActiveHotspot());\n    }\n  }\n\n  /**\n   * When the window size changes, recalculate things.\n   */\n  _handleResize() {\n    this.refresh();\n  }\n\n  /**\n   * Refresh when the page has finished loading. There are likely images within\n   * the hotspot content which may now have a width/height which affects the\n   * size of the hotspot content.\n   */\n  _handleLoad() {\n    window.removeEventListener('load', this._loadHandler, false);\n    this.refresh();\n  }\n\n  /**\n   * Returns the currently open hotspot or null if none are open.\n   * @return {?Hotspot}\n   */\n  getActiveHotspot() {\n    return this._activeHotspot;\n  }\n\n  /**\n   * Update the active hotspot property.\n   * @param {Hotspot} hotspot\n   */\n  setActiveHotspot(hotspot) {\n    this._activeHotspot = hotspot;\n  }\n\n  /**\n   * Recalculates offsets and sizes.\n   */\n  refresh() {\n    this.size = this._getContainerSize();\n    this.hotspots.forEach((hotspot) => {\n      hotspot.refresh();\n    });\n  }\n\n  /**\n   * Remove event listeners and DOM references.\n   */\n  dispose() {\n    this.closeAllHotspots();\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.button.removeEventListener('click', this._clickHandler, false);\n      hotspot.dispose();\n    });\n\n    this.hotspots = null;\n\n    window.removeEventListener('load', this._loadHandler, false);\n    window.removeEventListener('resize', this._resizeHandler, false);\n\n    this.element.classList.remove(Hotspots.ClassName.LOADED);\n\n    this.element = null;\n    this._activeHotspot = null;\n    this._noopElement = null;\n  }\n}\n\nObject.assign(Hotspots, settings);\n\nexport default Hotspots;\n"],"names":["setUniqueId","element","id","count","func","wait","immediate","later","last","Date","now","timestamp","setTimeout","apply","context","args","timeout","result","debounced","this","arguments","callNow","clear","Hotspot","parent","isOpen","wrapper","button","querySelector","settings","ClassName","BUTTON","content","CONTENT","percentPosition","parseWrapperPosition","size","getContentSize","side","getSide","anchor","getAnchor","position","getWrapperPosition","positions","getAttribute","split","parseInt","offsetWidth","offsetHeight","classList","contains","HOTSPOT_LEFT","HOTSPOT_RIGHT","HOTSPOT_TOP","HOTSPOT_BOTTOM","refresh","refreshId","requestAnimationFrame","_removeContentPosition","_setContentPosition","_setWrapperPosition","style","left","x","top","y","Math","round","width","height","_getOptimalSide","fitsRight","right","fitsLeft","_getOptimalAnchor","fitsTop","bottom","fitsBottom","add","remove","setPosition","show","OPEN","setAttribute","hide","removeAttribute","setA11yAttributes","_removeA11yAttributes","dispose","Hotspots","el","_TinyEmitter","_this","_getContainerSize","hotspots","_getHotspots","_noopElement","_getFirstBodyDescendant","_noop","_activeHotspot","_bindEvents","forEach","hotspot","LOADED","dispatchEvent","EventType","INITIALIZED","getElementsByClass","className","Array","from","querySelectorAll","parentElement","document","body","HOTSPOT","map","_getHotspotByWrapper","i","len","length","eventName","event","defaultPrevented","emit","_clickHandler","_handleHotspotClick","bind","_resizeHandler","debounce","_handleResize","_loadHandler","_handleLoad","_outerClickHandler","_handleOuterClick","addEventListener","_this3","closeAllHotspots","closeHotspot","toggleHotspot","openHotspot","WILL_OPEN","setActiveHotspot","_listenForOuterClicks","WILL_CLOSE","_removeOuterClick","WebkitTapHighlightColor","removeEventListener","evt","preventDefault","currentTarget","getActiveHotspot","target","_this6","TinyEmitter","Object","assign"],"mappings":"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"}