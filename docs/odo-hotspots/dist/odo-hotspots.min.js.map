{"version":3,"file":"odo-hotspots.min.js","sources":["../node_modules/debounce/index.js","../src/settings.js","../src/unique-id.js","../src/hotspot.js","../src/hotspots.js"],"sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n","export default {\n  ClassName: {\n    HOTSPOT: 'odo-hotspot',\n    HOTSPOT_LEFT: 'odo-hotspot--left',\n    HOTSPOT_RIGHT: 'odo-hotspot--right',\n    HOTSPOT_TOP: 'odo-hotspot--top',\n    HOTSPOT_BOTTOM: 'odo-hotspot--bottom',\n    BUTTON: 'odo-hotspot__button',\n    CONTENT: 'odo-hotspot__content',\n    LOADED: 'is-loaded',\n    OPEN: 'is-open',\n  },\n\n  EventType: {\n    INITIALIZED: 'odohotspotsinitialized',\n    WILL_OPEN: 'odohotspotswillopen',\n    WILL_CLOSE: 'odohotspotswillclose',\n  },\n};\n","let count = 0;\nexport default function setUniqueId(element) {\n  if (!element.id) {\n    count += 1;\n    element.id = `odo-hotspots${count}`;\n  }\n}\n","import settings from './settings';\nimport setUniqueId from './unique-id';\n\nclass Hotspot {\n  /**\n   * The hotspot class represents a single hotspot.\n   * @param {Element} element Main wrapper element for the hotspot.\n   * @param {Hotspots} parent A reference to the parent class.\n   * @constructor\n   */\n  constructor(element, parent) {\n    this.parent = parent;\n    this.isOpen = false;\n    this.wrapper = element;\n    this.button = element.querySelector('.' + settings.ClassName.BUTTON);\n    this.content = element.querySelector('.' + settings.ClassName.CONTENT);\n    this.percentPosition = this.parseWrapperPosition();\n    this.size = this.getContentSize();\n    this.side = this.getSide();\n    this.anchor = this.getAnchor();\n    this.position = this.getWrapperPosition();\n  }\n\n  /**\n   * Converts the data-position=\"x,y\" attribute to an object with x and y properties.\n   * @return {{x: number, y: number}}\n   */\n  parseWrapperPosition() {\n    const positions = this.wrapper.getAttribute('data-position').split(',');\n    return {\n      x: parseFloat(positions[0]),\n      y: parseFloat(positions[1]),\n    };\n  }\n\n  /**\n   * Returns the width and height of the content element.\n   * @return {{width: number, height: number}}\n   */\n  getContentSize() {\n    return {\n      width: this.content.offsetWidth,\n      height: this.content.offsetHeight,\n    };\n  }\n\n  /**\n   * Returns the class name of the side the hotspot should go to. If it doesn't\n   * have a side, a side will be calculated for it.\n   * @return {?string}\n   */\n  getSide() {\n    if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_LEFT)) {\n      return settings.ClassName.HOTSPOT_LEFT;\n    } else if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_RIGHT)) {\n      return settings.ClassName.HOTSPOT_RIGHT;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the class name of the anchor the hotspot should go to. If it doesn't\n   * have a anchor, a anchor will be calculated for it.\n   * @return {?string}\n   */\n  getAnchor() {\n    if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_TOP)) {\n      return settings.ClassName.HOTSPOT_TOP;\n    } else if (this.wrapper.classList.contains(settings.ClassName.HOTSPOT_BOTTOM)) {\n      return settings.ClassName.HOTSPOT_BOTTOM;\n    }\n    return null;\n  }\n\n  /**\n   * Updates the position and size of the hotspot.\n   */\n  refresh() {\n    // Read\n    this.percentPosition = this.parseWrapperPosition();\n    this.size = this.getContentSize();\n    this.position = this.getWrapperPosition();\n\n    // Write async so that multiple hotspots can be refreshed at a time without\n    // causing layout thrashing.\n    this.refreshId = requestAnimationFrame(() => {\n      this._removeContentPosition();\n      this.setPosition();\n    });\n  }\n\n  /**\n   * Applies the data-position attribute to the wrapper.\n   */\n  _setWrapperPosition() {\n    this.wrapper.style.left = this.percentPosition.x + '%';\n    this.wrapper.style.top = this.percentPosition.y + '%';\n  }\n\n  /**\n   * Returns a rectangle describing the wrapper (not the content).\n   * @return {Object}\n   */\n  getWrapperPosition() {\n    const left = Math.round(this.parent.size.width * this.percentPosition.x / 100);\n    const top = Math.round(this.parent.size.height * this.percentPosition.y / 100);\n    const width = Math.round(this.wrapper.offsetWidth);\n    const height = Math.round(this.wrapper.offsetHeight);\n    return {\n      left,\n      top,\n      right: left + width,\n      bottom: top + height,\n    };\n  }\n\n  /**\n   * Determines the side which the hotspot should go to based on the container's\n   * width and the width of the hotspot content.\n   * @return {string}\n   */\n  _getOptimalSide() {\n    let side = null;\n\n    const fitsRight = this.position.right + this.size.width <= this.parent.size.width;\n    const fitsLeft = this.position.left - this.size.width >= 0;\n\n    // If both or neither fit, choose the side which has more room.\n    if ((fitsLeft && fitsRight) || (!fitsLeft && !fitsRight)) {\n      if (this.percentPosition.x < 50) {\n        side = settings.ClassName.HOTSPOT_RIGHT;\n      } else {\n        side = settings.ClassName.HOTSPOT_LEFT;\n      }\n\n    // If only on side fits, then it has to be chosen.\n    } else if (fitsRight) {\n      side = settings.ClassName.HOTSPOT_RIGHT;\n    } else /* fitsLeft */ {\n      side = settings.ClassName.HOTSPOT_LEFT;\n    }\n\n    return side;\n  }\n\n  /**\n   * Determines the anchor which the hotspot should go to based on the container's\n   * height and the height of the hotspot content.\n   * @return {string}\n   */\n  _getOptimalAnchor() {\n    let anchor = null;\n\n    const fitsTop = this.position.bottom - this.size.height >= 0;\n    const fitsBottom = this.position.top + this.size.height <= this.parent.size.height;\n\n    // If both or neither fit, choose the anchor which has more room.\n    if ((fitsBottom && fitsTop) || (!fitsBottom && !fitsTop)) {\n      if (this.percentPosition.y > 50) {\n        anchor = settings.ClassName.HOTSPOT_TOP;\n      } else {\n        anchor = settings.ClassName.HOTSPOT_BOTTOM;\n      }\n\n    // If only on anchor fits, then it has to be chosen.\n    } else if (fitsTop) {\n      anchor = settings.ClassName.HOTSPOT_TOP;\n    } else /* fitsBottom */ {\n      anchor = settings.ClassName.HOTSPOT_BOTTOM;\n    }\n\n    return anchor;\n  }\n\n  /**\n   * If the hotspot does not have a side or anchor, they will be set for it.\n   */\n  _setContentPosition() {\n    if (this.side === null) {\n      this.wrapper.classList.add(this._getOptimalSide());\n    }\n\n    if (this.anchor === null) {\n      this.wrapper.classList.add(this._getOptimalAnchor());\n    }\n  }\n\n  /**\n   * If the hotspot did not have a side or anchor originally, they will be removed.\n   */\n  _removeContentPosition() {\n    if (this.side === null) {\n      this.wrapper.classList.remove(\n        settings.ClassName.HOTSPOT_LEFT,\n        settings.ClassName.HOTSPOT_RIGHT,\n      );\n    }\n\n    if (this.anchor === null) {\n      this.wrapper.classList.remove(\n        settings.ClassName.HOTSPOT_TOP,\n        settings.ClassName.HOTSPOT_BOTTOM,\n      );\n    }\n  }\n\n  /**\n   * Positions the wrapper and the content.\n   */\n  setPosition() {\n    this._setWrapperPosition();\n    this._setContentPosition();\n  }\n\n  /**\n   * Show the hotspot.\n   */\n  show() {\n    this.wrapper.classList.add(settings.ClassName.OPEN);\n    this.content.setAttribute('aria-hidden', false);\n    this.button.setAttribute('aria-describedby', this.content.id);\n    this.isOpen = true;\n  }\n\n  /**\n   * Hide the hotspot.\n   */\n  hide() {\n    this.wrapper.classList.remove(settings.ClassName.OPEN);\n    this.content.setAttribute('aria-hidden', true);\n    this.button.removeAttribute('aria-describedby');\n    this.isOpen = false;\n  }\n\n  /**\n   * Set accessibility attributes so that the implementor doesn't have to worry\n   * about it.\n   */\n  setA11yAttributes() {\n    setUniqueId(this.content);\n    this.content.setAttribute('aria-hidden', true);\n    this.content.setAttribute('role', 'tooltip');\n  }\n\n  _removeA11yAttributes() {\n    this.button.removeAttribute('aria-hidden');\n    this.content.removeAttribute('role');\n  }\n\n  /**\n   * Destroys the hotspot instance. It removes DOM references, classes, and styles\n   * set by this class.\n   */\n  dispose() {\n    cancelAnimationFrame(this.refreshId);\n    this._removeContentPosition();\n    this._removeA11yAttributes();\n    this.wrapper.style.left = '';\n    this.wrapper.style.top = '';\n    this.wrapper = null;\n    this.button = null;\n    this.content = null;\n    this.parent = null;\n  }\n}\n\nexport default Hotspot;\n","import TinyEmitter from 'tiny-emitter';\nimport debounce from 'debounce';\nimport Hotspot from './hotspot';\nimport settings from './settings';\n\nclass Hotspots extends TinyEmitter {\n  /**\n   * Component which has a draggable element in the middle which reveals one or\n   * the other sides as the user drags.\n   *\n   * @constructor\n   */\n  constructor(el) {\n    super();\n    this.element = el;\n\n    this.size = this._getContainerSize();\n    this.hotspots = this._getHotspots();\n    this._noopElement = this._getFirstBodyDescendant();\n    this._noop = () => {};\n\n    this._activeHotspot = null;\n\n    this._bindEvents();\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.setA11yAttributes();\n      hotspot.setPosition();\n    });\n\n    this.element.classList.add(Hotspots.ClassName.LOADED);\n    this.dispatchEvent(Hotspots.EventType.INITIALIZED);\n  }\n\n  /**\n   * Scope the query to the main element.\n   * @param {string} className Class name of the desired elements.\n   * @return {Array.<Element>} An array of elements.\n   */\n  getElementsByClass(className) {\n    return Array.from(this.element.querySelectorAll('.' + className));\n  }\n\n  /**\n   * In iOS, event delegation does not work for click events.\n   * http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   * @return {?Element} The first child of the body which is a parent of the\n   *     main element in this class.\n   */\n  _getFirstBodyDescendant() {\n    let { element } = this;\n    while (element) {\n      const parent = element.parentElement;\n      if (parent === document.body) {\n        return element;\n      }\n\n      element = parent;\n    }\n\n    return null;\n  }\n\n  /**\n   * Creates the hotspot instances.\n   * @return {Array.<Hotspot>}\n   */\n  _getHotspots() {\n    return this.getElementsByClass(Hotspots.ClassName.HOTSPOT)\n      .map(element => new Hotspot(element, this));\n  }\n\n  /**\n   * Finds the hotspot instance which uses the given wrapper element.\n   * @param {Element} wrapper Element.\n   * @return {?Hotspot}\n   */\n  _getHotspotByWrapper(wrapper) {\n    for (let i = 0, len = this.hotspots.length; i < len; i++) {\n      if (this.hotspots[i].wrapper === wrapper) {\n        return this.hotspots[i];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the dimensions of the main element.\n   * @return {{width: number, height: number}}\n   */\n  _getContainerSize() {\n    return {\n      width: this.element.offsetWidth,\n      height: this.element.offsetHeight,\n    };\n  }\n\n  /**\n   * Triggers a custom event on the main element.\n   * @param {string} eventName Name of event.\n   * @param {Hotspot} [hotspot] Optional hotspot object.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n  dispatchEvent(eventName, hotspot) {\n    const event = {\n      defaultPrevented: false,\n      preventDefault() {\n        this.defaultPrevented = true;\n      },\n    };\n\n    if (hotspot) {\n      event.hotspot = hotspot;\n    }\n\n    this.emit(eventName, event);\n    return event.defaultPrevented;\n  }\n\n  /**\n   * Add event listeners.\n   */\n  _bindEvents() {\n    this._clickHandler = this._handleHotspotClick.bind(this);\n    this._resizeHandler = debounce(this._handleResize.bind(this), 200);\n    this._loadHandler = this._handleLoad.bind(this);\n    this._outerClickHandler = this._handleOuterClick.bind(this);\n\n    window.addEventListener('resize', this._resizeHandler, false);\n    window.addEventListener('load', this._loadHandler, false);\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.button.addEventListener('click', this._clickHandler, false);\n    });\n  }\n\n  /**\n   * Closes all open hotspots so that only one can be open at a time.\n   */\n  closeAllHotspots() {\n    this.hotspots.forEach((hotspot) => {\n      this.closeHotspot(hotspot);\n    });\n  }\n\n  /**\n   * Toggles the display of a hotspot.\n   * @param {Hotspot} hotspot Hotspot to toggle.\n   */\n  toggleHotspot(hotspot) {\n    if (hotspot.isOpen) {\n      this.closeHotspot(hotspot);\n    } else {\n      this.openHotspot(hotspot);\n    }\n  }\n\n  /**\n   * Attempts to show the hotspot. It will emit an event which, if preventDefault\n   * is called on, can be canceled.\n   * @param {Hotspot} hotspot Hotspot to open.\n   */\n  openHotspot(hotspot) {\n    // If preventDefault is called on this event, do not open the hotspot.\n    if (hotspot.isOpen || this.dispatchEvent(Hotspots.EventType.WILL_OPEN, hotspot)) {\n      return;\n    }\n\n    this.closeAllHotspots();\n    hotspot.show();\n    this.setActiveHotspot(hotspot);\n\n    // Listen for clicks outside the hotspot which will close it.\n    // In a timeout so that a click on the hotspot button doesn't bubble\n    // up to the body and register as a click outside the hotspot.\n    setTimeout(() => {\n      this._listenForOuterClicks();\n    }, 0);\n  }\n\n  /**\n   * Attempts to hide the hotspot. It will emit an event which, if preventDefault\n   * is called on, can be canceled.\n   * @param {Hotspot} hotspot Hotspot to close.\n   */\n  closeHotspot(hotspot) {\n    // If preventDefault is called on this event, do not close the hotspot.\n    if (!hotspot.isOpen || this.dispatchEvent(Hotspots.EventType.WILL_CLOSE, hotspot)) {\n      return;\n    }\n\n    hotspot.hide();\n    this.setActiveHotspot(null);\n    this._removeOuterClick();\n  }\n\n  /**\n   * Bind a click listener to the body which closes any active hotspots if the\n   * user clicked outside of the current hotspot. This method also adds a no-op\n   * event lister to the first child of the body that is a parent of this module.\n   * This is due to a bug in iOS where click events do not bubble properly.\n   * The no-op element's tap highlight color is also set to transparent because\n   * it would show the default color on tap because it has a click handler.\n   */\n  _listenForOuterClicks() {\n    this._noopElement.addEventListener('click', this._noop, false);\n    this._noopElement.style.WebkitTapHighlightColor = 'transparent';\n    document.body.addEventListener('click', this._outerClickHandler, false);\n  }\n\n  /**\n   * Remove the delegated click listeners and tap highlight color.\n   */\n  _removeOuterClick() {\n    this._noopElement.removeEventListener('click', this._noop, false);\n    this._noopElement.style.WebkitTapHighlightColor = '';\n    document.body.removeEventListener('click', this._outerClickHandler, false);\n  }\n\n  /**\n   * Listener for clicks on the button inside the hotspot and toggles the hotspot's state.\n   * @param {Event} evt Click event object.\n   */\n  _handleHotspotClick(evt) {\n    evt.preventDefault();\n    const hotspot = this._getHotspotByWrapper(evt.currentTarget.parentElement);\n    this.toggleHotspot(hotspot);\n  }\n\n  /**\n   * When a hotspot is open, this handler is active. If the user clicks outside\n   * the hotspot, it will be closed.\n   * @param {Event} evt Click event object.\n   */\n  _handleOuterClick(evt) {\n    if (!this.getActiveHotspot().content.contains(evt.target)) {\n      this.closeHotspot(this.getActiveHotspot());\n    }\n  }\n\n  /**\n   * When the window size changes, recalculate things.\n   */\n  _handleResize() {\n    this.refresh();\n  }\n\n  /**\n   * Refresh when the page has finished loading. There are likely images within\n   * the hotspot content which may now have a width/height which affects the\n   * size of the hotspot content.\n   */\n  _handleLoad() {\n    window.removeEventListener('load', this._loadHandler, false);\n    this.refresh();\n  }\n\n  /**\n   * Returns the currently open hotspot or null if none are open.\n   * @return {?Hotspot}\n   */\n  getActiveHotspot() {\n    return this._activeHotspot;\n  }\n\n  /**\n   * Update the active hotspot property.\n   * @param {Hotspot} hotspot\n   */\n  setActiveHotspot(hotspot) {\n    this._activeHotspot = hotspot;\n  }\n\n  /**\n   * Recalculates offsets and sizes.\n   */\n  refresh() {\n    this.size = this._getContainerSize();\n    this.hotspots.forEach((hotspot) => {\n      hotspot.refresh();\n    });\n  }\n\n  /**\n   * Remove event listeners and DOM references.\n   */\n  dispose() {\n    this.closeAllHotspots();\n\n    this.hotspots.forEach((hotspot) => {\n      hotspot.button.removeEventListener('click', this._clickHandler, false);\n      hotspot.dispose();\n    });\n\n    this.hotspots = null;\n\n    window.removeEventListener('load', this._loadHandler, false);\n    window.removeEventListener('resize', this._resizeHandler, false);\n\n    this.element.classList.remove(Hotspots.ClassName.LOADED);\n\n    this.element = null;\n    this._activeHotspot = null;\n    this._noopElement = null;\n  }\n}\n\nObject.assign(Hotspots, settings);\n\nexport default Hotspots;\n"],"names":["count","Hotspot","element","parent","isOpen","wrapper","button","querySelector","settings","ClassName","BUTTON","content","CONTENT","percentPosition","this","parseWrapperPosition","size","getContentSize","side","getSide","anchor","getAnchor","position","getWrapperPosition","positions","getAttribute","split","parseFloat","offsetWidth","offsetHeight","classList","contains","HOTSPOT_LEFT","HOTSPOT_RIGHT","HOTSPOT_TOP","HOTSPOT_BOTTOM","refresh","refreshId","requestAnimationFrame","_removeContentPosition","setPosition","_setWrapperPosition","style","left","x","top","y","Math","round","width","height","_getOptimalSide","fitsRight","right","fitsLeft","_getOptimalAnchor","fitsTop","bottom","fitsBottom","_setContentPosition","add","remove","show","OPEN","setAttribute","id","hide","removeAttribute","setA11yAttributes","_removeA11yAttributes","dispose","Hotspots","el","_TinyEmitter","_this","_getContainerSize","hotspots","_getHotspots","_noopElement","_getFirstBodyDescendant","_noop","_activeHotspot","_bindEvents","forEach","hotspot","LOADED","dispatchEvent","EventType","INITIALIZED","getElementsByClass","className","Array","from","querySelectorAll","parentElement","document","body","HOTSPOT","map","_getHotspotByWrapper","i","len","length","eventName","event","defaultPrevented","emit","_clickHandler","_handleHotspotClick","bind","_resizeHandler","func","wait","immediate","later","last","Date","now","timestamp","setTimeout","apply","context","args","timeout","result","debounced","arguments","callNow","clear","debounce","_handleResize","_loadHandler","_handleLoad","_outerClickHandler","_handleOuterClick","addEventListener","_this3","closeAllHotspots","closeHotspot","toggleHotspot","openHotspot","WILL_OPEN","setActiveHotspot","_listenForOuterClicks","WILL_CLOSE","_removeOuterClick","WebkitTapHighlightColor","removeEventListener","evt","preventDefault","currentTarget","getActiveHotspot","target","_this6","TinyEmitter","Object","assign"],"mappings":"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"}