{"version":3,"file":"odo-responsive-images.min.js","sources":["../node_modules/debounce/index.js","../src/responsive-images.js"],"sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n","import picturefill from 'picturefill';\nimport debounce from 'debounce';\nimport Viewport from '@odopod/odo-viewport';\n\n/**\n * If the first parameter is not an array, return an array containing the first\n * parameter.\n * @param {*} thing Anything.\n * @return {Array.<*>} Array of things.\n */\nfunction arrayify(thing) {\n  if (Array.isArray(thing)) {\n    return thing;\n  }\n\n  if (thing && typeof thing.length === 'number') {\n    return Array.from(thing);\n  }\n\n  return [thing];\n}\n\n/**\n * Move children from one element to another. Ignores <noscript> elements.\n * @param {Element} fromElement Element to move children from.\n * @param {Element} toElement Element to move children to.\n * @private\n */\nfunction transferChildren(fromElement, toElement) {\n  // Include comment nodes. Convert to array because the NodeList is \"live\"\n  // and will be updated when an element is removed from it.\n  const frag = document.createDocumentFragment();\n  const children = Array.from(fromElement.childNodes);\n\n  for (let i = 0; i < children.length; i++) {\n    if (children[i].nodeName !== 'NOSCRIPT') {\n      frag.appendChild(children[i]);\n    }\n  }\n\n  toElement.appendChild(frag);\n}\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nclass ResponsiveImages {\n  constructor() {\n    /**\n     * Because this class is a singleton, assign settings to the instance.\n     * @enum {string}\n     */\n    this.ClassName = {\n      IMAGE: 'odo-responsive-img',\n      LOADED: 'odo-responsive-img--loaded',\n    };\n\n    /**\n     * An array of viewport item ids and picture elements.\n     * @type {Array.<{id: string, element: Element}>}\n     */\n    this.images = [];\n\n    // Save context for this callback so it can easily be removed.\n    this._imageLoadHandler = this._handleImageLoad.bind(this);\n    this._imageInViewHandler = this._handleImageInView.bind(this);\n\n    /**\n     * Debounce calls to `_update`.\n     * @type {function}\n     */\n    this.updateOffsets = debounce(this._update, ResponsiveImages.DEBOUNCE_TIME);\n  }\n\n  initialize() {\n    // Ignore elements which are already <picture>.\n    this._add(Array.from(document.querySelectorAll(`.${this.ClassName.IMAGE}:not(picture)`)));\n  }\n\n  /**\n   * Add an array of images to track.\n   * @param {Array.<Element>} newImages Images array.\n   */\n  _add(newImages) {\n    const options = newImages.map(image => this._getViewportOptions(image));\n    const ids = Viewport.add(options);\n    this.images = this.images.concat(ids.map((id, i) => ({\n      id,\n      element: newImages[i],\n    })));\n  }\n\n  /**\n   * Retrieve options to give OdoViewport for an element.\n   * @param {Element} picture The picture/div element.\n   * @return {!Object} OdoViewportItem options.\n   */\n  _getViewportOptions(picture) {\n    return {\n      element: picture,\n      threshold: picture.getAttribute('data-threshold') || 0,\n      enter: this._imageInViewHandler,\n    };\n  }\n\n  /**\n   * Callback for when the image has entered the viewport. This triggers the image\n   * to start loading.\n   * @param {ViewportItem} viewportItem Data about the element entering view.\n   */\n  _handleImageInView(viewportItem) {\n    this._loadImage(viewportItem.element);\n  }\n\n  /**\n   * Given the parent placeholder div, load the responsive image inside it.\n   * @param {Element} placeholder An element with the odo responsive image class.\n   * @private\n   */\n  _loadImage(placeholder) {\n    let img = placeholder.querySelector('img');\n\n    if (!img) {\n      throw new Error('Unable to find <img> element within Odo Responsive Images placeholder.');\n    }\n\n    const srcset = img.getAttribute('data-srcset');\n\n    // Determine if this is img[srcset] or if it should be a <picture>.\n    if (srcset !== null) {\n      // Not sure what is best here, setting the property or the attribute, for both\n      // picturefill and native responsive images, so both are set.\n      img.srcset = srcset;\n      img.setAttribute('srcset', srcset);\n      img.removeAttribute('data-srcset');\n      placeholder._odoResponsiveImageUsed = true;\n    } else {\n      // Create a new picture element with the same contents and replace the\n      // placeholder with it.\n      const parent = placeholder.parentElement;\n      const picture = document.createElement('picture');\n      picture.className = placeholder.className;\n      transferChildren(placeholder, picture);\n      const type = placeholder.getAttribute('data-type');\n      if (type) {\n        picture.setAttribute('data-type', type);\n      }\n\n      img = picture.querySelector('img');\n\n      // Replace the placeholder element with the picture.\n      parent.replaceChild(picture, placeholder);\n      picture._odoResponsiveImageUsed = true;\n    }\n\n    // Splice out of array.\n    this._removeImageEntry(placeholder);\n\n    // Now that the DOM is in the final state, see if this image is already loaded.\n    if (this.isImageLoaded(img)) {\n      setTimeout(this._handleImageLoad.bind(this, {\n        target: img,\n      }), 30);\n    }\n\n    // When the image first loads, add the loaded class and possibly update\n    // the background-image property.\n    img.addEventListener('load', this._imageLoadHandler, false);\n    img.addEventListener('error', this._imageLoadHandler, false);\n\n    // Run picturefill on the new element.\n    picturefill({\n      elements: [img],\n    });\n  }\n\n  /**\n   * Retrieve the image object which matches the given placeholder element.\n   * @param {Element} placeholder Responsive image element wrapper (the one which\n   *     gets replaced when using <picture>).\n   * @return {?number} Index of the responsive image object.\n   */\n  _getImageIndexByPlaceholder(placeholder) {\n    let index = null;\n\n    for (let i = 0, len = this.images.length; i < len; i++) {\n      if (this.images[i].element === placeholder) {\n        index = i;\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  /**\n   * Removes an image stored in the `images` array from the array and from the\n   * Viewport watcher.\n   * @param {Element} placeholder Placeholder element.\n   * @private\n   */\n  _removeImageEntry(placeholder) {\n    const index = this._getImageIndexByPlaceholder(placeholder);\n\n    // Unable to find the index of the placeholder image. It is either already\n    // loaded, or the \"placeholder\" was the replacement?\n    if (index === null) {\n      return;\n    }\n\n    Viewport.remove(this.images[index].id);\n    this.images.splice(index, 1);\n  }\n\n  /**\n   * Whether an image element has already been loaded.\n   * @param {HTMLImageElement} img The <img>.\n   * @return {boolean}\n   */\n  isImageLoaded(img) {\n    return img.naturalWidth > 0;\n  }\n\n  /**\n   * Determine if this is element should use a background image.\n   * @param {HTMLImageElement} img Image in question.\n   * @return {boolean}\n   */\n  _isBackgroundImage(img) {\n    return img.parentElement.getAttribute('data-type') === 'background';\n  }\n\n  /**\n   * Whether the given element is a Odo Responsive Image which is not already\n   * loading and has not been loaded yet.\n   * @param {Element} picture Element to test.\n   */\n  _isUnloadedResponsiveImage(picture) {\n    if (!isElement(picture)) {\n      throw new TypeError(`Odo Responsive Images requires an element. Got: \"${picture}\"`);\n    }\n\n    if (!picture.classList.contains(this.ClassName.IMAGE)) {\n      throw new TypeError(`${picture} is not a Odo Responsive Image.`);\n    }\n\n    // The _loadImage method adds this property to the picture (or div when using\n    // img[srcset]) after it has done its business.\n    return picture._odoResponsiveImageUsed !== true;\n  }\n\n  /**\n   * Whether the given element is already in the `images` object array.\n   * @param {Element} placeholder Element to test.\n   * @return {boolean}\n   */\n  isUntrackedImage(placeholder) {\n    return this._getImageIndexByPlaceholder(placeholder) === null;\n  }\n\n  /**\n   * Load event handler for images.\n   * @param {UIEvent} evt Image load event object.\n   */\n  _handleImageLoad(evt) {\n    const img = /** @type {HTMLImageElement} */ (evt.target);\n\n    // Exit early if this image is longer in the DOM.\n    if (!img.parentNode) {\n      return;\n    }\n\n    // Call debounced update offsets because once an image loads, it could\n    // offset everything below it on the page.\n    this.updateOffsets();\n\n    // Set the background image url if it has a [data-type=\"background\"] attribute.\n    if (this._isBackgroundImage(img)) {\n      this._updateBackgroundImage(img);\n    } else {\n      // No longer need to listen for the load event for <picture>s. It will be\n      // handled natively or by picturefill.\n      this._removeImageHandlers(img);\n    }\n\n    // Write to the DOM all at once if many images load at the same time.\n    requestAnimationFrame(() => {\n      // classList is smart enough not to change the className property if the\n      // element already has the class which is being added.\n      img.parentNode.classList.add(this.ClassName.LOADED);\n    });\n  }\n\n  /**\n   * Update the background image property with the current source of a responsive image.\n   * @param {HTMLImageElement} img Image element.\n   */\n  _updateBackgroundImage(img) {\n    img.parentNode.style.backgroundImage = `url(\"${(img.currentSrc || img.src)}\")`;\n  }\n\n  /**\n   * Notify the Viewport to update its value. This method is called when a new\n   * image loads. It should also be called manually if offsets on the page change.\n   */\n  _update() {\n    Viewport.update();\n  }\n\n  /**\n   * Remove the event listeners bound to the image.\n   * @param {Element} img Image element.\n   */\n  _removeImageHandlers(img) {\n    if (img) {\n      img.removeEventListener('load', this._imageLoadHandler, false);\n      img.removeEventListener('error', this._imageLoadHandler, false);\n    }\n  }\n\n  /**\n   * Clean up all references and listeners for current images.\n   */\n  flush() {\n    // Remove load listener for each image and stop the Viewport component\n    // from watching it.\n    this.images.forEach((image) => {\n      const img = image.element.querySelector('img');\n      this._removeImageHandlers(img);\n      Viewport.remove(image.id);\n    });\n\n    this.images.length = 0;\n\n    // Remove all `load` events from background images.\n    const selector = `.${this.ClassName.IMAGE}[data-type=\"background\"] img`;\n    Array.from(document.querySelectorAll(selector)).forEach((img) => {\n      this._removeImageHandlers(img);\n    });\n  }\n\n  /**\n   * Remove watched images from this component.\n   * @param {Element|Array.<Element>} placeholders An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n  remove(placeholders) {\n    arrayify(placeholders).forEach((placeholder) => {\n      this._removeImageEntry(placeholder);\n      this._removeImageHandlers(placeholder.querySelector('img'));\n    });\n  }\n\n  /**\n   * Add more images for the ResponsiveImages component to watch.\n   * @param {Element|Array.<Element>} pictures An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n  add(pictures) {\n    const pics = arrayify(pictures)\n      .filter(this._isUnloadedResponsiveImage, this)\n      .filter(this.isUntrackedImage, this);\n\n    if (pics.length === 0) {\n      return;\n    }\n\n    this._add(pics);\n  }\n\n  /**\n   * Force the load of an element or group of elements instead of waiting for it\n   * to come into the viewport.\n   * @param {Element|Array.<Element>} pictures An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n  load(pictures) {\n    arrayify(pictures)\n      .filter(this._isUnloadedResponsiveImage, this)\n      .forEach(this._loadImage, this);\n  }\n}\n\nResponsiveImages.DEBOUNCE_TIME = 300;\n\n// Create a single instance and return that.\nexport default new ResponsiveImages();\n"],"names":["func","wait","immediate","timeout","args","context","timestamp","result","later","last","Date","now","setTimeout","apply","debounced","this","arguments","callNow","clear","flush","arrayify","thing","Array","isArray","length","from","ResponsiveImages","ClassName","images","_imageLoadHandler","_handleImageLoad","bind","_imageInViewHandler","_handleImageInView","updateOffsets","debounce","_update","DEBOUNCE_TIME","initialize","_add","document","querySelectorAll","IMAGE","newImages","options","map","_this","_getViewportOptions","image","ids","Viewport","add","concat","id","i","picture","getAttribute","viewportItem","_loadImage","element","placeholder","img","querySelector","Error","srcset","setAttribute","removeAttribute","_odoResponsiveImageUsed","parent","parentElement","createElement","className","fromElement","toElement","frag","createDocumentFragment","children","childNodes","nodeName","appendChild","type","replaceChild","_removeImageEntry","isImageLoaded","addEventListener","_getImageIndexByPlaceholder","index","len","remove","splice","naturalWidth","_isBackgroundImage","_isUnloadedResponsiveImage","nodeType","TypeError","classList","contains","isUntrackedImage","evt","target","parentNode","_updateBackgroundImage","_removeImageHandlers","_this2","LOADED","style","backgroundImage","currentSrc","src","update","removeEventListener","forEach","selector","placeholders","pictures","pics","filter","load"],"mappings":"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"}