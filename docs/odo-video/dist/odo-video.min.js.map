{"version":3,"file":"odo-video.min.js","sources":["../src/settings.js","../src/autoplay-test.js","../src/controls.js","../src/support-test.js","../src/video.js"],"sourcesContent":["export default {\n  Classes: {\n    BASE: 'odo-video',\n\n    IS_PLAYING: 'odo-video--playing',\n    IS_FULLSCREEN: 'odo-video--fullscreen',\n    IS_MUTED: 'odo-video--muted',\n    IS_BUFFERING: 'odo-video--buffering',\n    IS_IDLE: 'odo-video--idle',\n    NO_FLEXBOX: 'odo-video--no-flexbox',\n    CONTROLS_STACKED: 'odo-video__controls--stacked',\n    CONTROLS_HIDDEN: 'odo-video__controls--hidden',\n\n    CONTROLS: 'odo-video__controls',\n    PLAY_TOGGLE: 'odo-video__play-toggle',\n    PLAY_CONTROL: 'odo-video__play-control',\n    PAUSE_CONTROL: 'odo-video__pause-control',\n    PROGRESS_CONTAINER: 'odo-video__progress-container',\n    PROGRESS_HOLDER: 'odo-video__progress-holder',\n    BUFFER: 'odo-video__buffer',\n    PROGRESS: 'odo-video__progress',\n    CURRENT_TIME: 'odo-video__current-time',\n    VOLUME: 'odo-video__volume',\n    MUTE_CONTROL: 'odo-video__mute-control',\n    UNMUTE_CONTROL: 'odo-video__unmute-control',\n    FULLSCREEN: 'odo-video__fullscreen',\n    FULLSCREEN_CONTROL: 'odo-video__fullscreen-control',\n    EXIT_FULLSCREEN_CONTROL: 'odo-video__exit-fullscreen-control',\n    FLEXIBLE_SPACE: 'odo-video__flexible-space',\n  },\n\n  Icons: {\n    FULLSCREEN: '<svg viewBox=\"0 0 16 16\" enable-background=\"new 0 0 16 16\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 2H8v2h2.586L8 6.587 9.414 8 12 5.415V8h2V2zM8 9.414L6.586 8 4 10.586V8H2v6h6v-2H5.415z\"/></svg>',\n    EXIT_FULLSCREEN: '<svg viewBox=\"0 0 16 16\" enable-background=\"new 0 0 16 16\"><path d=\"M15 2.4L13.6 1 11 3.6V1H9v6h6V5h-2.6L15 2.4zM5 9H1v2h2.6L1 13.6 2.4 15 5 12.4V15h2V9H5z\"/></svg>',\n    AUDIO_ON: '<svg viewBox=\"0 0 16 16\" enable-background=\"new 0 0 16 16\"><path d=\"M1 5.366v5.294c0 .177.142.32.317.32h2.89c.093 0 .18.034.254.093l4.505 3.743c.16.135.4.018.402-.19l.002-13.25c0-.21-.243-.325-.403-.193L4.47 4.923c-.077.064-.173.098-.27.098H1.33c-.235 0-.33.17-.33.346zm10.292-1.03c-.295-.296-.76-.296-1.057 0-.292.296-.292.775.002 1.07v-.002c.642.652 1.04 1.55 1.04 2.54 0 .992-.396 1.884-1.04 2.535-.294.295-.294.774 0 1.07.143.148.334.222.526.222.19 0 .388-.074.528-.22.91-.922 1.476-2.202 1.476-3.606 0-1.41-.567-2.69-1.476-3.61h.002zm1.71-1.732c-.294-.296-.76-.296-1.053 0-.294.296-.293.772 0 1.066 1.08 1.096 1.754 2.602 1.754 4.273s-.667 3.176-1.753 4.273c-.294.294-.294.77 0 1.067.142.146.337.222.53.222.19 0 .386-.076.526-.222 1.35-1.366 2.19-3.257 2.19-5.34-.008-2.08-.843-3.975-2.194-5.34z\"/></svg>',\n    AUDIO_OFF: '<svg viewBox=\"0 0 16 16\" enable-background=\"new 0 0 16 16\"><path d=\"M1 5.366v5.294c0 .177.142.32.317.32h2.89c.093 0 .18.034.254.093l4.505 3.743c.16.135.4.018.402-.19l.002-13.25c0-.21-.243-.325-.403-.193L4.47 4.923c-.077.064-.173.098-.27.098H1.33c-.235 0-.33.17-.33.346z\"/></svg>',\n  },\n\n  IDLE_TIMEOUT: 2000,\n\n  Defaults: {\n    controls: 1,\n    layoutControls: null,\n    updateControls: null,\n    pauseOnClick: true,\n  },\n\n  Controls: {\n    NONE: 0,\n    INLINE_PROGRESS: 1,\n    STACKED_PROGRESS: 2,\n    CUSTOM: 3,\n  },\n\n  VideoEvents: {\n    LOADED_METADATA: {\n      name: 'loadedmetadata',\n      readyState: 1,\n    },\n    LOADED_DATA: {\n      name: 'loadeddata',\n      readyState: 2,\n    },\n    CAN_PLAY: {\n      name: 'canplay',\n      readyState: 3,\n    },\n    CAN_PLAYTHROUGH: {\n      name: 'canplaythrough',\n      readyState: 4,\n    },\n  },\n};\n","function test(support) {\n  // If the test has already passed, return a resolved promise.\n  if (test.HAS_LOCAL_STORAGE && window.localStorage.getItem('odovideoautoplay') === 'true') {\n    return Promise.resolve(true);\n  }\n\n  // Retrieve the number of autoplay test attempts. Max is 3.\n  const tries = test.HAS_LOCAL_STORAGE && parseInt(window.localStorage.getItem('odovideoautoplaytries'), 10) || 0;\n  if (tries > 2) {\n    return Promise.resolve(false);\n  }\n\n  /* istanbul ignore next */\n  return new Promise((resolve) => {\n    let timeout;\n\n    // Chrome can handle 300ms. IE11 requires at least 900 to avoid failing consistenly.\n    const waitTime = 1000;\n    const elem = document.createElement('video');\n\n    const complete = (bool) => {\n      if (test.HAS_LOCAL_STORAGE) {\n        window.localStorage.setItem('odovideoautoplay', bool);\n        window.localStorage.setItem('odovideoautoplaytries', tries + 1);\n      }\n\n      resolve(bool);\n    };\n\n    const testAutoplay = (arg) => {\n      clearTimeout(timeout);\n      elem.removeEventListener('playing', testAutoplay);\n      complete(arg && arg.type === 'playing' || elem.currentTime !== 0);\n      elem.parentNode.removeChild(elem);\n    };\n\n    // Skip the test if video itself, or the autoplay element on it isn't supported.\n    if (!support || !('autoplay' in elem)) {\n      complete(false);\n      return;\n    }\n\n    // Starting with iOS 10, video[autoplay] videos must be on screen, visible\n    // through css, and inserted into the DOM.\n    // https://webkit.org/blog/6784/new-video-policies-for-ios/\n    elem.style.cssText = 'position:fixed;top:0;left:0;height:1px;width:1px;opacity:0;';\n    elem.src = 'data:video/mp4;base64,AAAAFGZ0eXBNU05WAAACAE1TTlYAAAOUbW9vdgAAAGxtdmhkAAAAAM9ghv7PYIb+AAACWAAACu8AAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAnh0cmFrAAAAXHRraGQAAAAHz2CG/s9ghv4AAAABAAAAAAAACu8AAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAFAAAAA4AAAAAAHgbWRpYQAAACBtZGhkAAAAAM9ghv7PYIb+AAALuAAANq8AAAAAAAAAIWhkbHIAAAAAbWhscnZpZGVBVlMgAAAAAAABAB4AAAABl21pbmYAAAAUdm1oZAAAAAAAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAVdzdGJsAAAAp3N0c2QAAAAAAAAAAQAAAJdhdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAFAAOABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAAEmNvbHJuY2xjAAEAAQABAAAAL2F2Y0MBTUAz/+EAGGdNQDOadCk/LgIgAAADACAAAAMA0eMGVAEABGjuPIAAAAAYc3R0cwAAAAAAAAABAAAADgAAA+gAAAAUc3RzcwAAAAAAAAABAAAAAQAAABxzdHNjAAAAAAAAAAEAAAABAAAADgAAAAEAAABMc3RzegAAAAAAAAAAAAAADgAAAE8AAAAOAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA4AAAAOAAAAFHN0Y28AAAAAAAAAAQAAA7AAAAA0dXVpZFVTTVQh0k/Ou4hpXPrJx0AAAAAcTVREVAABABIAAAAKVcQAAAAAAAEAAAAAAAAAqHV1aWRVU01UIdJPzruIaVz6ycdAAAAAkE1URFQABAAMAAAAC1XEAAACHAAeAAAABBXHAAEAQQBWAFMAIABNAGUAZABpAGEAAAAqAAAAASoOAAEAZABlAHQAZQBjAHQAXwBhAHUAdABvAHAAbABhAHkAAAAyAAAAA1XEAAEAMgAwADAANQBtAGUALwAwADcALwAwADYAMAA2ACAAMwA6ADUAOgAwAAABA21kYXQAAAAYZ01AM5p0KT8uAiAAAAMAIAAAAwDR4wZUAAAABGjuPIAAAAAnZYiAIAAR//eBLT+oL1eA2Nlb/edvwWZflzEVLlhlXtJvSAEGRA3ZAAAACkGaAQCyJ/8AFBAAAAAJQZoCATP/AOmBAAAACUGaAwGz/wDpgAAAAAlBmgQCM/8A6YEAAAAJQZoFArP/AOmBAAAACUGaBgMz/wDpgQAAAAlBmgcDs/8A6YEAAAAJQZoIBDP/AOmAAAAACUGaCQSz/wDpgAAAAAlBmgoFM/8A6YEAAAAJQZoLBbP/AOmAAAAACkGaDAYyJ/8AFBAAAAAKQZoNBrIv/4cMeQ==';\n\n    elem.setAttribute('autoplay', '');\n    elem.setAttribute('muted', '');\n    elem.setAttribute('playsinline', '');\n    document.documentElement.appendChild(elem);\n\n    // Wait for the next tick to add the listener, otherwise the element may\n    // not have time to play in high load situations (e.g. the test suite).\n    setTimeout(() => {\n      elem.addEventListener('playing', testAutoplay);\n      timeout = setTimeout(testAutoplay, waitTime);\n    }, 0);\n  });\n}\n\n// Support: Safari private browsing.\ntest.HAS_LOCAL_STORAGE = (() => {\n  try {\n    const testKey = 'test';\n    window.localStorage.setItem(testKey, '1');\n    window.localStorage.removeItem(testKey);\n    return true;\n  } catch (error) /* istanbul ignore next */ {\n    return false;\n  }\n})();\n\nexport default test;\n","import settings from './settings';\n\nclass Controls {\n  createElement(type, options) {\n    const el = document.createElement(type);\n    Object.keys(options).forEach((k) => {\n      el[k] = options[k];\n    });\n\n    return el;\n  }\n\n  createElements() {\n    return {\n      controls: this.createElement('div', {\n        className: settings.Classes.CONTROLS,\n      }),\n      playToggle: this.createElement('button', {\n        className: settings.Classes.PLAY_TOGGLE,\n        title: Controls.LABEL.PLAY_TOGGLE,\n      }),\n      playControl: this.createElement('span', {\n        className: settings.Classes.PLAY_CONTROL,\n      }),\n      pauseControl: this.createElement('span', {\n        className: settings.Classes.PAUSE_CONTROL,\n      }),\n      progressContainer: this.createElement('div', {\n        className: settings.Classes.PROGRESS_CONTAINER,\n      }),\n      progressHolder: this.createElement('div', {\n        className: settings.Classes.PROGRESS_HOLDER,\n      }),\n      buffer: this.createElement('div', {\n        className: settings.Classes.BUFFER,\n      }),\n      progress: this.createElement('div', {\n        className: settings.Classes.PROGRESS,\n      }),\n      currentTime: this.createElement('div', {\n        className: settings.Classes.CURRENT_TIME,\n      }),\n      volumeToggle: this.createElement('button', {\n        className: settings.Classes.VOLUME,\n        title: Controls.LABEL.VOLUME,\n      }),\n      muteControl: this.createElement('span', {\n        className: settings.Classes.MUTE_CONTROL,\n        innerHTML: settings.Icons.AUDIO_ON,\n      }),\n      unmuteControl: this.createElement('span', {\n        className: settings.Classes.UNMUTE_CONTROL,\n        innerHTML: settings.Icons.AUDIO_OFF,\n      }),\n      fullScreenToggle: this.createElement('button', {\n        className: settings.Classes.FULLSCREEN,\n        title: Controls.LABEL.FULLSCREEN,\n      }),\n      enterFullscreen: this.createElement('span', {\n        className: settings.Classes.FULLSCREEN_CONTROL,\n        innerHTML: settings.Icons.FULLSCREEN,\n      }),\n      exitFullscreen: this.createElement('span', {\n        className: settings.Classes.EXIT_FULLSCREEN_CONTROL,\n        innerHTML: settings.Icons.EXIT_FULLSCREEN,\n      }),\n      flexibleSpace: this.createElement('div', {\n        className: settings.Classes.FLEXIBLE_SPACE,\n      }),\n    };\n  }\n\n  create(style, customFn) {\n    const elements = this.createElements();\n\n    elements.playToggle.appendChild(elements.playControl);\n    elements.playToggle.appendChild(elements.pauseControl);\n\n    elements.volumeToggle.appendChild(elements.muteControl);\n    elements.volumeToggle.appendChild(elements.unmuteControl);\n\n    elements.fullScreenToggle.appendChild(elements.enterFullscreen);\n    elements.fullScreenToggle.appendChild(elements.exitFullscreen);\n\n    elements.progressHolder.appendChild(elements.buffer);\n    elements.progressHolder.appendChild(elements.progress);\n    elements.progressContainer.appendChild(elements.progressHolder);\n\n    switch (style) {\n      case settings.Controls.INLINE_PROGRESS:\n        this._createInline(elements);\n        break;\n      case settings.Controls.NONE:\n\n        // When no controls are specified, create them anyways. It's easier to hide\n        // the controls and still have them in the DOM than it is to many if-statements\n        // checking if the controls exist before modifying them.\n        this._createInline(elements);\n        elements.controls.classList.add(settings.Classes.CONTROLS_HIDDEN);\n        break;\n      case settings.Controls.STACKED_PROGRESS:\n        this._createStacked(elements);\n        break;\n      case settings.Controls.CUSTOM:\n        customFn(elements);\n        break;\n      // no default\n    }\n\n    return elements.controls;\n  }\n\n  _createInline(elements) {\n    elements.controls.appendChild(elements.playToggle);\n    elements.controls.appendChild(elements.progressContainer);\n    elements.controls.appendChild(elements.currentTime);\n    elements.controls.appendChild(elements.volumeToggle);\n    elements.controls.appendChild(elements.fullScreenToggle);\n  }\n\n  _createStacked(elements) {\n    elements.controls.appendChild(elements.progressContainer);\n    elements.controls.appendChild(elements.playToggle);\n    elements.controls.appendChild(elements.flexibleSpace);\n    elements.controls.appendChild(elements.currentTime);\n    elements.controls.appendChild(elements.volumeToggle);\n    elements.controls.appendChild(elements.fullScreenToggle);\n    elements.controls.classList.add(settings.Classes.CONTROLS_STACKED);\n  }\n}\n\nControls.LABEL = {\n  PLAY_TOGGLE: 'toggle video playback.',\n  VOLUME: 'toggle mute for video.',\n  FULLSCREEN: 'toggle video fullscreen mode.',\n};\n\nexport default Controls;\n","// Determine support for videos. From Modernizr source.\n// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/video.js\n\n// Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845\nexport default () => {\n  const elem = document.createElement('video');\n  let bool = !!elem.canPlayType;\n\n  // IE9 Running on Windows Server 2008 can cause an exception to be thrown, bug #224\n  // End of life for 'mainstream' WS2008 was 2015-1-13.\n  /* istanbul ignore next */\n  if (bool) {\n    bool = new Boolean(bool); // eslint-disable-line no-new-wrappers\n    bool.ogg = elem.canPlayType('video/ogg; codecs=\"theora\"');\n\n    // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546\n    bool.h264 = elem.canPlayType('video/mp4; codecs=\"avc1.42E01E\"');\n    bool.webm = elem.canPlayType('video/webm; codecs=\"vp8, vorbis\"');\n    bool.vp9 = elem.canPlayType('video/webm; codecs=\"vp9\"');\n    bool.hls = elem.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"');\n  }\n\n  return bool;\n};\n","import screenfull from 'screenfull';\nimport settings from './settings';\nimport supportTest from './support-test';\nimport autoplayTest from './autoplay-test';\nimport Controls from './controls';\n\n/**\n * Features:\n *\n * Autoplay support callbacks.\n * Skinnable UI controls.\n * Fullscreen mode.\n * Click-to-seek.\n * Preload video.\n * Dynamically update source.\n * Hide controls & mouse in fullscreen when idle.\n * Spacebar pauses video in fullscreen mode.\n * Function to define control structure.\n * Callback for updating controls on video progress.\n */\nclass Video {\n  constructor(element, options) {\n    /**\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * @type {HTMLVideoElement}\n     */\n    this.videoEl = this._findVideoElement();\n\n    /**\n     * Random id for this instance.\n     */\n    this.id = Math.random().toString(36).substring(7);\n\n    /**\n     * Options for this instance.\n     * @type {object}\n     */\n    this.options = Object.assign({}, Video.Defaults, options);\n\n    this.isPlaying = this._isPlaying();\n    this.isFullscreen = false;\n    this._idleTimeout = null;\n\n    /**\n     * Whether the browser can go in fullscreen mode. This will be true for iOS\n     * because the video element can go fullscreen, but false for IE<11.\n     * @private {boolean}\n     */\n    this._noFullscreen = false;\n\n    this.element.classList.toggle(Video.Classes.NO_FLEXBOX, Video.NO_FLEXBOX);\n\n    // Set id attributes for each source.\n    this._setSourceIds();\n    this._createControls();\n    this._saveElements();\n    this.bindEvents();\n\n    if (this._isMetadataLoaded()) {\n      this._setProgressDisplay();\n      this._setBufferDisplay();\n    }\n\n    this.autoplay = Promise.resolve(Video.autoplay);\n  }\n\n  /**\n   * Bind the correct `this` context to each event listener. The native `bind`\n   * method returns a different function each time `bind` is called, so the value\n   * must be saved in order to remove the correct listener.\n   * @protected\n   */\n  _bindListeners() {\n    this._onMetadataLoaded = this._handleMetadataLoaded.bind(this);\n    this._onClick = this._handleClick.bind(this);\n    this._onPlay = this._handlePlaying.bind(this);\n    this._onPause = this._handlePaused.bind(this);\n    this._onTimeUpdate = this._handleTimeUpdate.bind(this);\n    this._onProgress = this._handleProgress.bind(this);\n    this._onFullscreenToggle = this.toggleFullscreen.bind(this);\n    this._onFullscreenChange = this._fullscreenChanged.bind(this);\n    this._onVolumeToggle = this.toggleVolume.bind(this);\n    this._onProgressClick = this._handleProgressClick.bind(this);\n    this._onSeeking = this._handleSeeking.bind(this);\n    this._onSeeked = this._handleSeeked.bind(this);\n    this._onMouseMove = this._returnFromIdle.bind(this);\n    this._onIdleTimeout = this._wentIdle.bind(this);\n    this._onKeyboardPlaybackToggle = this._handleKeyboardPlaybackToggle.bind(this);\n  }\n\n  /**\n   * Add event listeners to the video and UI elements.\n   * @protected\n   */\n  bindEvents() {\n    this._bindListeners();\n    this._waitForMetadata();\n\n    if (this.options.pauseOnClick) {\n      this.videoEl.addEventListener('click', this._onClick);\n    }\n\n    // Sent when playback is paused.\n    this.videoEl.addEventListener('pause', this._onPause);\n\n    // Sent when the media begins to play (either for the first time, after having\n    // been paused, or after ending and then restarting).\n    this.videoEl.addEventListener('playing', this._onPlay);\n    this.videoEl.addEventListener('timeupdate', this._onTimeUpdate);\n    this.videoEl.addEventListener('progress', this._onProgress);\n    // this.videoEl.addEventListener('volumechange', this._onVolumeChange);\n    this.videoEl.addEventListener('seeking', this._onSeeking);\n    this.videoEl.addEventListener('seeked', this._onSeeked);\n\n    this.getElementByClass(Video.Classes.PLAY_TOGGLE)\n      .addEventListener('click', this._onClick);\n    this.getElementByClass(Video.Classes.VOLUME)\n      .addEventListener('click', this._onVolumeToggle);\n    this.getElementByClass(Video.Classes.PROGRESS_HOLDER)\n      .addEventListener('click', this._onProgressClick);\n    this.getElementByClass(Video.Classes.FULLSCREEN)\n      .addEventListener('click', this._onFullscreenToggle);\n\n    if (Video.screenfull.enabled) {\n      document.addEventListener(\n        Video.screenfull.raw.fullscreenchange,\n        this._onFullscreenChange,\n      );\n      document.addEventListener(\n        Video.screenfull.raw.fullscreenerror,\n        this._onFullscreenChange,\n      );\n\n      // iOS handles full screen differently.\n    } else if (this.videoEl.webkitSupportsFullscreen) {\n      this.videoEl.addEventListener('webkitbeginfullscreen', this._onFullscreenChange);\n      this.videoEl.addEventListener('webkitendfullscreen', this._onFullscreenChange);\n    } else {\n      this._noFullscreen = true;\n    }\n  }\n\n  /**\n   * Checks the network state of the video element. Returns true if the metadata\n   * for the video is present.\n   * @return {boolean}\n   * @private\n   */\n  _isMetadataLoaded() {\n    return this.videoEl.readyState > 0;\n  }\n\n  /**\n   * Add the `loadedmetadata` event listener if the video has not loaded yet, or\n   * call the event handler directly if it has.\n   * @private\n   */\n  _waitForMetadata() {\n    if (this._isMetadataLoaded()) {\n      this._handleMetadataLoaded();\n    } else {\n      this.videoEl.addEventListener('loadedmetadata', this._onMetadataLoaded);\n    }\n  }\n\n  /**\n   * Save references to UI elements which needs to be constantly updated.\n   * @protected\n   */\n  _saveElements() {\n    this.currentTimeEl = this.getElementByClass(Video.Classes.CURRENT_TIME);\n    this.progressEl = this.getElementByClass(Video.Classes.PROGRESS);\n    this.bufferEl = this.getElementByClass(Video.Classes.BUFFER);\n  }\n\n  /**\n   * Separated into its own function so sinon can stub it in the tests.\n   * @return {HTMLVideoElement}\n   * @private\n   */\n  _findVideoElement() {\n    return this.element.getElementsByTagName('video')[0];\n  }\n\n  /**\n   * Whether the video is currently playing.\n   * @return {boolean}\n   */\n  _isPlaying() {\n    if (this.videoEl.ended || this.videoEl.paused) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * For each <source> element, set a unique id on it.\n   * @private\n   */\n  _setSourceIds() {\n    this.getSourceElements().forEach((source) => {\n      source.id = this.id + source.type.split('/')[1];\n    });\n  }\n\n  /**\n   * Retrieve all <source> elements within the video.\n   * @return {Array.<HTMLSourceElement>}\n   */\n  getSourceElements() {\n    return Array.from(this.videoEl.getElementsByTagName('source'));\n  }\n\n  /**\n   * Return the main element this component was instantiated with.\n   * @return {Element}\n   */\n  getElement() {\n    return this.element;\n  }\n\n  /**\n   * Returns the <video> element associated with this component.\n   * @return {HTMLVideoElement}\n   */\n  getVideoElement() {\n    return this.videoEl;\n  }\n\n  /**\n   * Retrieve an element from within the main element by a class name.\n   * @param {string} className Class name to search for.\n   * @return {?Element} The element or null if it isn't found.\n   */\n  getElementByClass(className) {\n    return this.element.getElementsByClassName(className)[0];\n  }\n\n  /**\n   * Play the current video.\n   * https://googlechrome.github.io/samples/play-return-promise/\n   * @return {?Promise<void>} Chrome 50+, Firefox 53+, and Safari 10+ return a\n   *     promise which is rejected if the device cannot autoplay.\n   */\n  play() {\n    return this.videoEl.play();\n  }\n\n  /**\n   * Pause the currently playing video.\n   */\n  pause() {\n    this.videoEl.pause();\n  }\n\n  /**\n   * If playing, pause. If paused, play.\n   */\n  togglePlayback() {\n    if (this.isPlaying) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  /**\n   * Get the current time, in seconds.\n   * @return {number}\n   */\n  getCurrentTime() {\n    return this.videoEl.currentTime;\n  }\n\n  /**\n   * Go to a specified time in the video.\n   * @param {number} time Time in seconds.\n   */\n  setCurrentTime(time) {\n    this.videoEl.currentTime = time;\n  }\n\n  /**\n   * Mute the video.\n   */\n  mute() {\n    this.videoEl.volume = 0;\n    this.element.classList.add(Video.Classes.IS_MUTED);\n  }\n\n  /**\n   * Unmute the video.\n   */\n  unmute() {\n    this.videoEl.volume = 1;\n    this.element.classList.remove(Video.Classes.IS_MUTED);\n  }\n\n  /**\n   * Whether the video is currently muted.\n   * @return {boolean}\n   */\n  isMuted() {\n    return this.videoEl.volume === 0;\n  }\n\n  /**\n   * Mute the video if it's playing audio or unmute it if it's already muted.\n   */\n  toggleVolume() {\n    if (this.isMuted()) {\n      this.unmute();\n    } else {\n      this.mute();\n    }\n  }\n\n  /**\n   * Update the current video source. This method changes the appropriate <source>\n   * `src` property.\n   *\n   * IE9 does not work when the <video>s `src` property or attribute is updated.\n   *\n   * @param {string} src Absolute or relative path to the video, without the extension.\n   *     e.g. \"/videos/cool-feature\".\n   */\n  updateSource(src) {\n    const { extension } = Video.getVideoType();\n    const sources = this.getSourceElements();\n\n    // Find the <source> element by Id.\n    const source = sources.filter(source => source.id === this.id + extension)[0];\n\n    const videoSource = src + '.' + extension;\n\n    // Update the source's src.\n    source.setAttribute('src', videoSource);\n\n    this.videoEl.load();\n\n    // Reset progress bars.\n    this._setProgressDisplay();\n    this._setBufferDisplay();\n\n    // When metadata loads, update the times.\n    this._waitForMetadata();\n  }\n\n  /**\n   * Show the video is currently buffering.\n   * @protected\n   */\n  showBuffering() {\n    this.element.classList.add(Video.Classes.IS_BUFFERING);\n  }\n\n  /**\n   * Show the video is done buffering.\n   * @protected\n   */\n  hideBuffering() {\n    this.element.classList.remove(Video.Classes.IS_BUFFERING);\n  }\n\n  /**\n   * Converts a time value to MMSS, so 91 seconds is \"1:31\".\n   * @param {number} currentTime Time in seconds.\n   * @return {string} Human readable time.\n   */\n  static getPrettyTime(currentTime) {\n    const hours = Math.floor(currentTime / 3600);\n    const minutes = Math.floor((currentTime - (hours * 3600)) / 60);\n    let seconds = currentTime - (hours * 3600) - (minutes * 60);\n\n    if (seconds < 10) {\n      seconds = '0' + seconds;\n    }\n\n    let time = minutes + ':' + seconds;\n    if (hours > 0) {\n      if (minutes < 10) {\n        time = '0' + time;\n      }\n\n      time = hours + ':' + time;\n    }\n\n    return time;\n  }\n\n  /**\n   * Generate the controls elemenet and append it to the main element.\n   * @private\n   */\n  _createControls() {\n    const controls = new Video.ControlsCreator();\n    const mainElement = controls.create(this.options.controls, this.options.layoutControls);\n    this.element.appendChild(mainElement);\n  }\n\n  /**\n   * Update the controls state/display with the new current time.\n   * @private\n   */\n  _updateControls() {\n    const seconds = this.getCurrentTime();\n    this._setCurrentTimeDisplay(seconds);\n    this._setProgressDisplay();\n\n    // Give a hook to update custom controls.\n    if (this.options.updateControls) {\n      this.options.updateControls(seconds);\n    }\n  }\n\n  /**\n   * Sets the current time element's text to a pretty time given a float.\n   * @param {number} seconds The current time of the video.\n   */\n  _setCurrentTimeDisplay(seconds) {\n    this.currentTimeEl.textContent = Video.getPrettyTime(Math.round(seconds));\n  }\n\n  /**\n   * Set the progress elements to a percentage.\n   * @param {number} percentage Number between 0 and 1. If undefined, the percentage\n   *     will be calculated from the video's current time and duration.\n   * @private\n   */\n  _setProgressDisplay(percentage = this.videoEl.currentTime / this.videoEl.duration) {\n    this.progressEl.style.width = percentage * 100 + '%';\n  }\n\n  /**\n   * Determine the amount the video has buffered and set the buffer element's width\n   * as that percentage.\n   * @private\n   */\n  _setBufferDisplay() {\n    // Progress events can be emitted before there is anything buffered.\n    const percentage = this.videoEl.buffered.length > 0 ?\n      this.videoEl.buffered.end(0) / this.videoEl.duration :\n      0;\n\n    this.bufferEl.style.width = percentage * 100 + '%';\n  }\n\n  /**\n   * Clicked the fullscreen icon. Request or exit from fullscreen.\n   */\n  toggleFullscreen() {\n    if (Video.screenfull) {\n      // Handle it the standardized way.\n      Video.screenfull.toggle(this.element);\n    } else if (this._noFullscreen) {\n      // Support: IE<11. Since there won't be any entered/exited fullscreen events,\n      // that callback must be invoked immediately.\n      this._fullscreenChanged();\n    } else {\n      // Since the native video controls will be shown and not the Video\n      // custom controls, it can be assumed that this event handler will only\n      // be triggered by requesting fullscreen.\n      this.videoEl.webkitEnterFullscreen();\n    }\n  }\n\n  /**\n   * Event handler for both fullscreenchange and fullscreenerror. The state of\n   * fullscreen has changed and styles need to be updated.\n   * @private\n   */\n  _fullscreenChanged() {\n    this.isFullscreen = !this.isFullscreen;\n    this._toggleFullscreenState();\n  }\n\n  _toggleFullscreenState() {\n    this.element.classList.toggle(Video.Classes.IS_FULLSCREEN, this.isFullscreen);\n\n    if (this.isFullscreen) {\n      this._startIdleTimer();\n\n      // Take focus off the fullscreen button because the spacebar should pause\n      // the video, but when it's focused, it will exit fullscreen.\n      document.activeElement.blur();\n      this.element.focus();\n      this.element.addEventListener('mousemove', this._onMouseMove);\n\n      // Use keyup instead of keypress because special keys (control, shift, alt, etc.)\n      // do not trigger the keypress event.\n      document.addEventListener('keyup', this._onKeyboardPlaybackToggle);\n    } else {\n      this._returnFromIdle();\n\n      // Return from idle starts a new timer, which isn't wanted when closing fullscreen.\n      clearTimeout(this._idleTimeout);\n      this.element.removeEventListener('mousemove', this._onMouseMove);\n      document.removeEventListener('keyup', this._onKeyboardPlaybackToggle);\n    }\n  }\n\n  /**\n   * When the user stops interacting with the page, the cursor should disappear and\n   * the controls should be hidden.\n   * @private\n   */\n  _wentIdle() {\n    this.element.classList.add(Video.Classes.IS_IDLE);\n  }\n\n  /**\n   * When returning from the idle state, the cursor and controls should be shown.\n   * Another timer is started to wait for idle state again.\n   * @private\n   */\n  _returnFromIdle() {\n    clearTimeout(this._idleTimeout);\n    this._startIdleTimer();\n    this.element.classList.remove(Video.Classes.IS_IDLE);\n  }\n\n  /**\n   * Sets a timeout which will trigger the `wentIdle` method when it expires.\n   * @private\n   */\n  _startIdleTimer() {\n    this._idleTimeout = setTimeout(this._onIdleTimeout, Video.IDLE_TIMEOUT);\n  }\n\n  /**\n   * Calculate the position of the click relative to the element the click listener\n   * was bound to.\n   * @param {MouseEvent} event Event object.\n   * @return {{x: number, y: number}}\n   * @private\n   */\n  static _getClickOffset(event) {\n    if ('offsetX' in event) {\n      return {\n        x: event.offsetX,\n        y: event.offsetY,\n      };\n    }\n\n    const rect = event.currentTarget.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top,\n    };\n  }\n\n  /**\n   * Event handler for the `loadedmetadata` event. Update UI with new data.\n   * @private\n   */\n  _handleMetadataLoaded() {\n    this.videoEl.removeEventListener('loadedmetadata', this._onMetadataLoaded);\n    this._setCurrentTimeDisplay(this.videoEl.duration);\n  }\n\n  /**\n   * Clicked on the main element. Toggle video playback.\n   */\n  _handleClick() {\n    this.togglePlayback();\n  }\n\n  /**\n   * Event handler for the `playing` event. Add the is-playing class.\n   * @private\n   */\n  _handlePlaying() {\n    this.isPlaying = true;\n    this.element.classList.toggle(Video.Classes.IS_PLAYING, this.isPlaying);\n  }\n\n  /**\n   * Event handler for the `paused` event. Remove the is-playing class.\n   * @private\n   */\n  _handlePaused() {\n    this.isPlaying = false;\n    this.element.classList.toggle(Video.Classes.IS_PLAYING, this.isPlaying);\n  }\n\n  /**\n   * Event handler for the `timeupdate` event. Update the UI.\n   * @private\n   */\n  _handleTimeUpdate() {\n    this._updateControls();\n  }\n\n  /**\n   * Event handler for the `progress` event. Update the buffer display bar.\n   * @private\n   */\n  _handleProgress() {\n    this._setBufferDisplay();\n  }\n\n  /**\n   * Clicked the progress bar track. Seek to the location of the click.\n   * @param {MouseEvent} evt Event object.\n   * @private\n   */\n  _handleProgressClick(evt) {\n    const offset = Video._getClickOffset(evt);\n    const width = evt.currentTarget.offsetWidth;\n    const percent = offset.x / width;\n    this._setProgressDisplay(percent);\n    this.setCurrentTime(percent * this.videoEl.duration);\n  }\n\n  /**\n   * Video started seeking. Show the user it's buffering.\n   * @private\n   */\n  _handleSeeking() {\n    // Avoid adding the buffering class when the video is looping - issue #1\n    if (this.videoEl.buffered.length === 0 ||\n        this.videoEl.buffered.end(0) < this.videoEl.currentTime) {\n      this.showBuffering();\n    }\n  }\n\n  /**\n   * Video stopped seeking. Show the user it's ready to play.\n   * @private\n   */\n  _handleSeeked() {\n    this.hideBuffering();\n  }\n\n  /**\n   * If the spacebar is pressed, toggle playback.\n   * @param {KeyboardEvent} evt Event object.\n   * @private\n   */\n  _handleKeyboardPlaybackToggle(evt) {\n    // Trigger the controls to show again.\n    this._returnFromIdle();\n\n    // Spacebar.\n    if (Video._getWhichKey(evt) === 32) {\n      this.togglePlayback();\n      evt.preventDefault();\n    }\n  }\n\n  /**\n   * Crossbrowser way to get the key which was pressed in a keyboard event.\n   * @param {KeyboardEvent} event Event object.\n   * @return {number}\n   * @private\n   */\n  static _getWhichKey(event) {\n    if (event.which) {\n      return event.which;\n    }\n    return event.charCode || event.keyCode;\n  }\n\n  /**\n   * Handler for triggering events on readyState or video data events\n   * @param {Object} event Object containing event name and readyState.\n   * @param {function():void} cb Callback function for event.\n   * @public\n   */\n  listenOnData(event, cb) {\n    let loaded;\n    if (this.videoEl.readyState > event.readyState) {\n      cb();\n    } else {\n      this.videoEl.addEventListener(event.name, loaded = () => {\n        this.videoEl.removeEventListener(event.name, loaded);\n        cb();\n      });\n    }\n  }\n\n  /**\n   * Remove all event listeners, references to DOM elements, and generated elements.\n   */\n  dispose() {\n    this.videoEl.removeEventListener('click', this._onClick);\n    this.videoEl.removeEventListener('pause', this._onPause);\n    this.videoEl.removeEventListener('playing', this._onPlay);\n    this.videoEl.removeEventListener('timeupdate', this._onTimeUpdate);\n    this.videoEl.removeEventListener('progress', this._onProgress);\n    this.videoEl.removeEventListener('seeking', this._onSeeking);\n    this.videoEl.removeEventListener('seeked', this._onSeeked);\n    this.videoEl.removeEventListener('loadedmetadata', this._onMetadataLoaded);\n\n    this.getElementByClass(Video.Classes.PLAY_TOGGLE)\n      .removeEventListener('click', this._onClick);\n    this.getElementByClass(Video.Classes.VOLUME)\n      .removeEventListener('click', this._onVolumeToggle);\n    this.getElementByClass(Video.Classes.PROGRESS_HOLDER)\n      .removeEventListener('click', this._onProgressClick);\n    this.getElementByClass(Video.Classes.FULLSCREEN)\n      .removeEventListener('click', this._onFullscreenToggle);\n\n    const fullscreenChange = this._onFullscreenChange;\n    if (Video.screenfull.enabled) {\n      document.removeEventListener(Video.screenfull.raw.fullscreenchange, fullscreenChange);\n      document.removeEventListener(Video.screenfull.raw.fullscreenerror, fullscreenChange);\n    } else if (this.videoEl.webkitSupportsFullscreen) {\n      this.videoEl.removeEventListener('webkitbeginfullscreen', fullscreenChange);\n      this.videoEl.removeEventListener('webkitendfullscreen', fullscreenChange);\n    }\n\n    this.element.removeChild(this.getElementByClass(Video.Classes.CONTROLS));\n\n    this.currentTimeEl = null;\n    this.progressEl = null;\n    this.bufferEl = null;\n    this.element = null;\n    this.videoEl = null;\n  }\n\n  /**\n   * Get the media type and extension for the currently supported video types.\n   * @return {{extension: string, type: string}}\n   */\n  static getVideoType() {\n    // Webm is best.\n    if (Video.support.webm) {\n      return {\n        extension: 'webm',\n        type: 'video/webm',\n      };\n    }\n\n    return {\n      extension: 'mp4',\n      type: 'video/mp4',\n    };\n  }\n}\n\n/* Merge in settings */\nObject.assign(Video, settings);\n\n/**\n * Determine support for videos. It is a boolean value with properties for\n * h264, webm, vp9, ogg, hls.\n * @type {Boolean}\n */\nVideo.support = supportTest();\n\n/**\n * An async test for autoplay feature.\n * @type {Promise}\n */\nVideo.autoplay = autoplayTest(Video.support);\nVideo._autoplayTest = autoplayTest;\n\n/** @type {Controls} */\nVideo.ControlsCreator = Controls;\n\n/** @type {boolean} IE9 is the only supported browser without flexbox. */\n/* istanbul ignore next */\nVideo.NO_FLEXBOX = document.all && document.addEventListener && !window.atob;\n\n/** @type {boolean|Object} Expose for testing. */\nVideo.screenfull = screenfull;\n\nexport default Video;\n"],"names":["test","support","HAS_LOCAL_STORAGE","window","localStorage","getItem","Promise","resolve","tries","parseInt","timeout","elem","document","createElement","complete","bool","setItem","testAutoplay","arg","removeEventListener","type","currentTime","parentNode","removeChild","style","cssText","src","setAttribute","documentElement","appendChild","addEventListener","setTimeout","removeItem","error","Controls","options","el","keys","forEach","k","createElements","this","settings","Classes","CONTROLS","PLAY_TOGGLE","LABEL","PLAY_CONTROL","PAUSE_CONTROL","PROGRESS_CONTAINER","PROGRESS_HOLDER","BUFFER","PROGRESS","CURRENT_TIME","VOLUME","MUTE_CONTROL","Icons","AUDIO_ON","UNMUTE_CONTROL","AUDIO_OFF","FULLSCREEN","FULLSCREEN_CONTROL","EXIT_FULLSCREEN_CONTROL","EXIT_FULLSCREEN","FLEXIBLE_SPACE","create","customFn","elements","playToggle","playControl","pauseControl","volumeToggle","muteControl","unmuteControl","fullScreenToggle","enterFullscreen","exitFullscreen","progressHolder","buffer","progress","progressContainer","INLINE_PROGRESS","_createInline","NONE","controls","classList","add","CONTROLS_HIDDEN","STACKED_PROGRESS","_createStacked","CUSTOM","flexibleSpace","CONTROLS_STACKED","Video","element","videoEl","_findVideoElement","id","Math","random","toString","substring","Object","assign","Defaults","isPlaying","_isPlaying","isFullscreen","_idleTimeout","_noFullscreen","toggle","NO_FLEXBOX","_setSourceIds","_createControls","_saveElements","bindEvents","_isMetadataLoaded","_setProgressDisplay","_setBufferDisplay","autoplay","_bindListeners","_onMetadataLoaded","_handleMetadataLoaded","bind","_onClick","_handleClick","_onPlay","_handlePlaying","_onPause","_handlePaused","_onTimeUpdate","_handleTimeUpdate","_onProgress","_handleProgress","_onFullscreenToggle","toggleFullscreen","_onFullscreenChange","_fullscreenChanged","_onVolumeToggle","toggleVolume","_onProgressClick","_handleProgressClick","_onSeeking","_handleSeeking","_onSeeked","_handleSeeked","_onMouseMove","_returnFromIdle","_onIdleTimeout","_wentIdle","_onKeyboardPlaybackToggle","_handleKeyboardPlaybackToggle","_waitForMetadata","pauseOnClick","getElementByClass","screenfull","enabled","raw","fullscreenchange","fullscreenerror","webkitSupportsFullscreen","readyState","currentTimeEl","progressEl","bufferEl","getElementsByTagName","ended","paused","getSourceElements","source","_this","split","Array","from","getElement","getVideoElement","className","getElementsByClassName","play","pause","togglePlayback","getCurrentTime","setCurrentTime","time","mute","volume","IS_MUTED","unmute","remove","isMuted","updateSource","extension","getVideoType","filter","_this2","videoSource","load","showBuffering","IS_BUFFERING","hideBuffering","getPrettyTime","hours","floor","minutes","seconds","mainElement","ControlsCreator","layoutControls","_updateControls","_setCurrentTimeDisplay","updateControls","textContent","round","percentage","duration","width","buffered","length","end","webkitEnterFullscreen","_toggleFullscreenState","IS_FULLSCREEN","_startIdleTimer","activeElement","blur","focus","IS_IDLE","IDLE_TIMEOUT","_getClickOffset","event","offsetX","offsetY","rect","currentTarget","getBoundingClientRect","clientX","left","clientY","top","IS_PLAYING","evt","offset","offsetWidth","percent","x","_getWhichKey","preventDefault","which","charCode","keyCode","listenOnData","cb","loaded","name","dispose","fullscreenChange","webm","canPlayType","Boolean","ogg","h264","vp9","hls","autoplayTest","_autoplayTest","all","atob"],"mappings":"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"}