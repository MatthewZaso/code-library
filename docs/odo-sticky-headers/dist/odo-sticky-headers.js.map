{"version":3,"file":"odo-sticky-headers.js","sources":["../src/sticky-item.js","../src/sticky-headers.js"],"sourcesContent":["/**\n * @fileoverview This class describes a sticky header element. It caches the\n * offsets for the element and has methods to stick, affix, and unstick the\n * sticky element.\n */\n\nfunction applyCss(element, css) {\n  Object.keys(css).forEach((property) => {\n    element.style[property] = css[property];\n  });\n}\n\nclass StickyItem {\n  /**\n   * Create a new sticky item.\n   * @param {Element} element Element to stick.\n   * @constructor\n   */\n  constructor(element) {\n    /**\n     * Main sticky element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the element is position:fixed.\n     * @type {boolean}\n     */\n    this.isFixed = false;\n\n    /**\n     * Whether the element is affixed to the bottom.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the element is layer promoted.\n     * @type {boolean}\n     */\n    this.isPromoted = false;\n\n    this._wrapStickyElement();\n    this.update();\n  }\n\n  /**\n   * Initialize by wrapping in an element to take up space while the main\n   * element is positin:fixed.\n   * @private\n   */\n  _wrapStickyElement() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = StickyItem.Classes.WRAPPER;\n    this.element.parentNode.insertBefore(this.wrapper, this.element);\n\n    applyCss(this.element, {\n      position: StickyItem.INITIAL_POSITION,\n      zIndex: 1,\n      top: 0,\n      left: 0,\n      width: '100%',\n      overflow: 'hidden',\n    });\n\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.wrapper.appendChild(this.element);\n  }\n\n  /**\n   * Remove the placeholder element added when this sticky item is initialized.\n   * @private\n   */\n  _unwrapStickyElement() {\n    const container = this.wrapper.parentNode;\n    container.appendChild(this.element);\n    container.removeChild(this.wrapper);\n  }\n\n  /**\n   * Save the dimensions of the sticky item.\n   */\n  update() {\n    const rect = this.element.getBoundingClientRect();\n    this.top = rect.top + window.pageYOffset;\n    this.height = Math.round(rect.height);\n  }\n\n  /**\n   * Stick the sticky item to a specific value.\n   * @param {number} stackHeight The current stack height of sticky elements.\n   * @param {Element} [parent] Optional element to put the sticky within.\n   */\n  stick(stackHeight, parent) {\n    this.wrapper.style.height = this.height + 'px';\n    this.element.style.position = 'fixed';\n    this.element.style.top = stackHeight + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    if (parent) {\n      parent.appendChild(this.element);\n    }\n\n    this.isAtBottom = false;\n    this.isFixed = true;\n  }\n\n  /**\n   * Remove stickiness of sticky item.\n   */\n  unstick() {\n    this.wrapper.style.height = '';\n    this.element.style.position = StickyItem.INITIAL_POSITION;\n    this.element.style.top = '';\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n\n    if (this.element.parentNode !== this.wrapper) {\n      this.wrapper.appendChild(this.element);\n    }\n\n    this.isFixed = false;\n    this.isAtBottom = false;\n  }\n\n  stickToBottom(placement) {\n    this.element.style.position = 'absolute';\n    this.element.style.top = placement + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    // When the sticky is position absolute, it has to be absolute relative\n    // to the page, not another fixed-position element.\n    document.body.appendChild(this.element);\n\n    this.isFixed = false;\n    this.isAtBottom = true;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Get rid of this sticky item instance.\n   */\n  dispose() {\n    this.unstick();\n    this._unwrapStickyElement();\n\n    applyCss(this.element, {\n      position: '',\n      zIndex: '',\n      top: '',\n      left: '',\n      width: '',\n      overflow: '',\n      willChange: '',\n      transform: '',\n    });\n\n    this.element = null;\n    this.wrapper = null;\n  }\n}\n\nStickyItem.INITIAL_POSITION = 'relative';\n\nStickyItem.Classes = {\n  BASE: 'odo-sticky-headers__item',\n  WRAPPER: 'odo-sticky-headers__item-wrapper',\n  IS_FIXED: 'is-fixed',\n  IS_AT_TOP: 'is-at-top',\n  IS_AT_BOTTOM: 'is-at-bottom',\n};\n\nexport default StickyItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\nimport StickyItem from './sticky-item';\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nfunction withinRange(value, min, max, threshold) {\n  return value >= min - threshold && value <= max + threshold;\n}\n\nclass StickyHeaders {\n  /**\n   * Create a new Sticky instance.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Mapping of elements to StickyItem instances.\n     * @type {Map.<Element, StickyItem>}\n     */\n    this.items = new Map();\n\n    /**\n     * Items sorted in order they appear on the page.\n     * @type {Array}\n     */\n    this._orderedItems = [];\n\n    /**\n     * Scroll event listener id.\n     * @type {?string}\n     */\n    this._scrollId = null;\n\n    /**\n     * Window resize id.\n     * @type {?string}\n     * @private\n     */\n    this._resizeId = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Where to start positioning new sticky items.\n     * @type {number}\n     * @private\n     */\n    this._startingOffset = 0;\n\n    /**\n     * Element which holds sticky elements.\n     * @type {Element}\n     * @private\n     */\n    this._holder = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page. A sticky navigation,\n     * for example, would cause an overlap equal to its height.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOverlap = () => 0;\n\n    /**\n     * Where to start positioning new sticky items. By default it's the same as\n     * the ui overlap, but can be customized.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOffset = this._getUiOverlap;\n\n    /**\n     * Which mode to handle sticky headers.\n     * @type {StickyHeaders.Mode}\n     * @private\n     */\n    this._mode = StickyHeaders.Mode.PUSH;\n  }\n\n  /**\n   * Track a sticky item.\n   * @param {Element[]|Element} element An array of elements or a single\n   *    element which will become sticky.\n   * @return {Element} The key to the items map for this new StickyItem.\n   */\n  add(element) {\n    const elements = Array.isArray(element) ? element : [element];\n\n    elements.forEach((element) => {\n      if (!isElement(element)) {\n        throw new TypeError(`StickyHeaders requires an element. Got: \"${element}\"`);\n      }\n\n      // Avoid adding duplicate items.\n      if (!this.items.has(element)) {\n        this.items.set(element, new StickyItem(element));\n      }\n    });\n\n    // Add event listeners if they aren't already added.\n    if (this._scrollId) {\n      this._cacheItemValues();\n    } else {\n      this._resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n      this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n      this._cacheStyles();\n    }\n\n    this.process();\n\n    return element;\n  }\n\n  /**\n   * Stop tracking a sticky item.\n   * @param {Element} element Element which was added to the sticky headers.\n   */\n  remove(element) {\n    if (this.items.has(element)) {\n      this.items.get(element).dispose();\n      this.items.delete(element);\n\n      // Remove event listeners when there aren't any instances to watch.\n      if (this.items.size === 0) {\n        OdoScrollAnimation.remove(this._scrollId);\n        OdoWindowEvents.remove(this._resizeId);\n        this._scrollId = null;\n        this._resizeId = null;\n      }\n    }\n  }\n\n  /**\n   * On every scroll event, push or stack sticky headers, depending on the mode.\n   * @param {number} [scrollTop=window.pageYoffset] Page scroll position.\n   */\n  process(scrollTop = window.pageYOffset) {\n    if (this.mode === StickyHeaders.Mode.STACK) {\n      this._processStack(scrollTop);\n    } else {\n      this._processPush(scrollTop);\n    }\n  }\n\n  /**\n   * Depending on the position of the viewport, make sticky headers position\n   * fixed. If multiple sticky headers are \"fixed\", they will stack on each other.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processStack(scrollTop) {\n    this._orderedItems.forEach((item) => {\n      // Because the stack height can change inside the loop, it must be updated.\n      const stackHeight = this._getStackHeight();\n      const top = scrollTop + this._overlap + stackHeight;\n\n      if (!item.isFixed && top >= item.top) {\n        item.stick(this._startingOffset + stackHeight, this._holder);\n      } else if (item.isFixed && top < item.top + item.height) {\n        item.unstick();\n      }\n    });\n  }\n\n  /**\n   * Like the Contacts app on iPhone, as new headers come into view, they \"push\"\n   * out the old header and then become stuck at the top until its section has\n   * been scrolled through.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processPush(scrollTop) {\n    const top = scrollTop + this._overlap;\n\n    this._orderedItems.forEach((item) => {\n      // Stick (position fixed).\n      if (!item.isFixed && top >= item.top && top < item.bottom) {\n        item.stick(this._startingOffset, this._holder);\n\n      // Affix. Item has reached the end of its view-length, stick it to the bottom.\n      } else if (!item.isAtBottom && top >= item.bottom) {\n        item.stickToBottom(item.bottom);\n\n      // Above the position where the sticky element should be position fixed, so unstick it.\n      } else if (item.isFixed && top < item.top) {\n        item.unstick();\n      }\n\n      this._itemPositionCouldChange(item, top);\n    });\n  }\n\n  /**\n   * Sort items by their position on the page.\n   * @return {StickyItem[]} Sorted array of StickyItems.\n   */\n  _sortItemsByOffset() {\n    return Array.from(this.items.values()).sort((a, b) => a.top - b.top);\n  }\n\n  /**\n   * Add up the heights of all the currrently \"stacked\" sticky items.\n   * @return {number}\n   */\n  _getStackHeight() {\n    return this._orderedItems.reduce((h, i) => (i.isFixed ? h + i.height : h), 0);\n  }\n\n  /**\n   * When the sticky-element's position is soon going to change, promote it to a\n   * new layer so that the browser does not have to paint it on every scroll.\n   * Having the sticky-element layer promoted all the time is inefficient and greedy.\n   * @param {StickyItem} item Item to check.\n   * @param {number} top Current top position (with any overlap).\n   */\n  _itemPositionCouldChange(item, top) {\n    const isInRange = withinRange(top, item.top, item.bottom, StickyHeaders.PROMOTION_RANGE);\n    if (!item.isPromoted && isInRange) {\n      item.layerPromote();\n    } else if (item.isPromoted && !isInRange) {\n      item.layerDemote();\n    }\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   */\n  _cacheStyles() {\n    this._overlap = this._getUiOverlap();\n    this._startingOffset = this._getUiOffset();\n    this._cacheItemValues();\n  }\n\n  /**\n   * Cache values related to sticky items.\n   */\n  _cacheItemValues() {\n    this._orderedItems = this._sortItemsByOffset();\n\n    if (this.mode === StickyHeaders.Mode.PUSH) {\n      this._saveBottomPositionForItems();\n    }\n  }\n\n  /**\n   * Determine the page offset at which each item should become position absolute.\n   */\n  _saveBottomPositionForItems() {\n    this._orderedItems.forEach((item, i, array) => {\n      const next = array[i + 1];\n      item.bottom = (next && next.top - item.height) || StickyHeaders.LAST_ITEM_BOTTOM;\n    });\n  }\n\n  /**\n   * Re-cache element positions and reposition all sticky headers.\n   */\n  update() {\n    this.items.forEach((item) => {\n      item.unstick();\n    });\n\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    this._cacheStyles();\n\n    this.process();\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n   * @return {function():number}\n   */\n  get uiOverlap() {\n    return this._getUiOverlap;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._getUiOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n  * @return {function():number}\n  */\n  get uiOffset() {\n    return this._getUiOffset;\n  }\n\n  /**\n   * Define a custom getter to determine offset.\n   * @param {function():number} fn\n   */\n  set uiOffset(fn) {\n    this._getUiOffset = fn;\n  }\n\n  /**\n   * The location of sticky elements to be placed in the DOM.\n   * @return {?Element}\n   */\n  get stickyHolder() {\n    return this._holder;\n  }\n\n  /**\n   * Set the location of sticky elements to be placed in the DOM.\n   * @param {?Element} element Element which sticky items will be appended to.\n   */\n  set stickyHolder(element) {\n    this._holder = isElement(element) ? element : null;\n  }\n\n  /**\n   * Retrieve the current mode of StickyHeaders.\n   * @return {StickyHeaders.Mode}\n   */\n  get mode() {\n    return this._mode;\n  }\n\n  /**\n   * Change how the service treats multiple sticky items.\n   * @param {StickyHeaders.Mode} mode A mode.\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n\n  /**\n   * Remove element references and event listeners.\n   */\n  dispose() {\n    this.items.forEach((item, element) => {\n      this.remove(element);\n    });\n\n    this._orderedItems.length = 0;\n  }\n}\n\nStickyHeaders.PROMOTION_RANGE = 200;\nStickyHeaders.LAST_ITEM_BOTTOM = Infinity;\n\nStickyHeaders.Mode = {\n  PUSH: 1,\n  STACK: 2,\n};\n\nStickyHeaders.StickyItem = StickyItem;\n\nexport default StickyHeaders;\n"],"names":["applyCss","element","css","Object","keys","forEach","property","style","StickyItem","isFixed","isAtBottom","isPromoted","_wrapStickyElement","update","wrapper","document","createElement","className","Classes","WRAPPER","parentNode","insertBefore","position","INITIAL_POSITION","zIndex","top","left","width","overflow","classList","add","IS_AT_TOP","appendChild","_unwrapStickyElement","container","removeChild","rect","getBoundingClientRect","window","pageYOffset","height","Math","round","stick","stackHeight","parent","IS_FIXED","remove","IS_AT_BOTTOM","unstick","stickToBottom","placement","body","layerPromote","willChange","transform","layerDemote","dispose","BASE","isElement","thing","nodeType","withinRange","value","min","max","threshold","StickyHeaders","items","Map","_orderedItems","_scrollId","_resizeId","_overlap","_startingOffset","_holder","_getUiOverlap","_getUiOffset","_mode","Mode","PUSH","elements","Array","isArray","TypeError","has","set","_cacheItemValues","OdoWindowEvents","onResize","bind","OdoScrollAnimation","process","_cacheStyles","get","delete","size","scrollTop","mode","STACK","_processStack","_processPush","item","_getStackHeight","bottom","_itemPositionCouldChange","_sortItemsByOffset","from","values","sort","a","b","reduce","h","i","isInRange","PROMOTION_RANGE","_saveBottomPositionForItems","array","next","LAST_ITEM_BOTTOM","length","fn","Infinity"],"mappings":"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"}