{"version":3,"file":"odo-sticky-headers.min.js","sources":["../src/sticky-item.js","../src/sticky-headers.js"],"sourcesContent":["/**\n * @fileoverview This class describes a sticky header element. It caches the\n * offsets for the element and has methods to stick, affix, and unstick the\n * sticky element.\n */\n\nfunction applyCss(element, css) {\n  Object.keys(css).forEach((property) => {\n    element.style[property] = css[property];\n  });\n}\n\nclass StickyItem {\n  /**\n   * Create a new sticky item.\n   * @param {Element} element Element to stick.\n   * @constructor\n   */\n  constructor(element) {\n    /**\n     * Main sticky element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the element is position:fixed.\n     * @type {boolean}\n     */\n    this.isFixed = false;\n\n    /**\n     * Whether the element is affixed to the bottom.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the element is layer promoted.\n     * @type {boolean}\n     */\n    this.isPromoted = false;\n\n    this._wrapStickyElement();\n    this.update();\n  }\n\n  /**\n   * Initialize by wrapping in an element to take up space while the main\n   * element is positin:fixed.\n   * @private\n   */\n  _wrapStickyElement() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = StickyItem.Classes.WRAPPER;\n    this.element.parentNode.insertBefore(this.wrapper, this.element);\n\n    applyCss(this.element, {\n      position: StickyItem.INITIAL_POSITION,\n      zIndex: 1,\n      top: 0,\n      left: 0,\n      width: '100%',\n      overflow: 'hidden',\n    });\n\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.wrapper.appendChild(this.element);\n  }\n\n  /**\n   * Remove the placeholder element added when this sticky item is initialized.\n   * @private\n   */\n  _unwrapStickyElement() {\n    const container = this.wrapper.parentNode;\n    container.appendChild(this.element);\n    container.removeChild(this.wrapper);\n  }\n\n  /**\n   * Save the dimensions of the sticky item.\n   */\n  update() {\n    const rect = this.element.getBoundingClientRect();\n    this.top = rect.top + window.pageYOffset;\n    this.height = Math.round(rect.height);\n  }\n\n  /**\n   * Stick the sticky item to a specific value.\n   * @param {number} stackHeight The current stack height of sticky elements.\n   * @param {Element} [parent] Optional element to put the sticky within.\n   */\n  stick(stackHeight, parent) {\n    this.wrapper.style.height = this.height + 'px';\n    this.element.style.position = 'fixed';\n    this.element.style.top = stackHeight + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    if (parent) {\n      parent.appendChild(this.element);\n    }\n\n    this.isAtBottom = false;\n    this.isFixed = true;\n  }\n\n  /**\n   * Remove stickiness of sticky item.\n   */\n  unstick() {\n    this.wrapper.style.height = '';\n    this.element.style.position = StickyItem.INITIAL_POSITION;\n    this.element.style.top = '';\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n\n    if (this.element.parentNode !== this.wrapper) {\n      this.wrapper.appendChild(this.element);\n    }\n\n    this.isFixed = false;\n    this.isAtBottom = false;\n  }\n\n  stickToBottom(placement) {\n    this.element.style.position = 'absolute';\n    this.element.style.top = placement + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    // When the sticky is position absolute, it has to be absolute relative\n    // to the page, not another fixed-position element.\n    document.body.appendChild(this.element);\n\n    this.isFixed = false;\n    this.isAtBottom = true;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Get rid of this sticky item instance.\n   */\n  dispose() {\n    this.unstick();\n    this._unwrapStickyElement();\n\n    applyCss(this.element, {\n      position: '',\n      zIndex: '',\n      top: '',\n      left: '',\n      width: '',\n      overflow: '',\n      willChange: '',\n      transform: '',\n    });\n\n    this.element = null;\n    this.wrapper = null;\n  }\n}\n\nStickyItem.INITIAL_POSITION = 'relative';\n\nStickyItem.Classes = {\n  BASE: 'odo-sticky-headers__item',\n  WRAPPER: 'odo-sticky-headers__item-wrapper',\n  IS_FIXED: 'is-fixed',\n  IS_AT_TOP: 'is-at-top',\n  IS_AT_BOTTOM: 'is-at-bottom',\n};\n\nexport default StickyItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\nimport StickyItem from './sticky-item';\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nfunction withinRange(value, min, max, threshold) {\n  return value >= min - threshold && value <= max + threshold;\n}\n\nclass StickyHeaders {\n  /**\n   * Create a new Sticky instance.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Mapping of elements to StickyItem instances.\n     * @type {Map.<Element, StickyItem>}\n     */\n    this.items = new Map();\n\n    /**\n     * Items sorted in order they appear on the page.\n     * @type {Array}\n     */\n    this._orderedItems = [];\n\n    /**\n     * Scroll event listener id.\n     * @type {?string}\n     */\n    this._scrollId = null;\n\n    /**\n     * Window resize id.\n     * @type {?string}\n     * @private\n     */\n    this._resizeId = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Where to start positioning new sticky items.\n     * @type {number}\n     * @private\n     */\n    this._startingOffset = 0;\n\n    /**\n     * Element which holds sticky elements.\n     * @type {Element}\n     * @private\n     */\n    this._holder = null;\n\n    /**\n     * Custom overlap getter. Can be overridden by setting `uiOverlap`.\n     * @type {?function}\n     * @private\n     */\n    this._customOverlap = null;\n\n    /**\n     * Custom offset getter. Can be overridden by setting `uiOffset`.\n     * @type {?function}\n     * @private\n     */\n    this._customOffset = null;\n\n    /**\n     * Which mode to handle sticky headers.\n     * @type {StickyHeaders.Mode}\n     * @private\n     */\n    this._mode = StickyHeaders.Mode.PUSH;\n  }\n\n  /**\n   * Track a sticky item.\n   * @param {Element[]|Element} element An array of elements or a single\n   *    element which will become sticky.\n   * @return {Element} The key to the items map for this new StickyItem.\n   */\n  add(element) {\n    const elements = Array.isArray(element) ? element : [element];\n\n    elements.forEach((element) => {\n      if (!isElement(element)) {\n        throw new TypeError(`StickyHeaders requires an element. Got: \"${element}\"`);\n      }\n\n      // Avoid adding duplicate items.\n      if (!this.items.has(element)) {\n        this.items.set(element, new StickyItem(element));\n      }\n    });\n\n    // Add event listeners if they aren't already added.\n    if (this._scrollId) {\n      this._cacheItemValues();\n    } else {\n      this._resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n      this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n      this._cacheStyles();\n    }\n\n    this.process();\n\n    return element;\n  }\n\n  /**\n   * Stop tracking a sticky item.\n   * @param {Element} element Element which was added to the sticky headers.\n   */\n  remove(element) {\n    if (this.items.has(element)) {\n      this.items.get(element).dispose();\n      this.items.delete(element);\n\n      // Remove event listeners when there aren't any instances to watch.\n      if (this.items.size === 0) {\n        OdoScrollAnimation.remove(this._scrollId);\n        OdoWindowEvents.remove(this._resizeId);\n        this._scrollId = null;\n        this._resizeId = null;\n      }\n    }\n  }\n\n  /**\n   * On every scroll event, push or stack sticky headers, depending on the mode.\n   * @param {number} scrollTop Page scroll position.\n   */\n  process(scrollTop = window.pageYOffset) {\n    if (this.mode === StickyHeaders.Mode.STACK) {\n      this._processStack(scrollTop);\n    } else {\n      this._processPush(scrollTop);\n    }\n  }\n\n  /**\n   * Depending on the position of the viewport, make sticky headers position\n   * fixed. If multiple sticky headers are \"fixed\", they will stack on each other.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processStack(scrollTop) {\n    this._orderedItems.forEach((item) => {\n      // Because the stack height can change inside the loop, it must be updated.\n      const stackHeight = this._getStackHeight();\n      const top = scrollTop + this._overlap + stackHeight;\n\n      if (!item.isFixed && top >= item.top) {\n        item.stick(this._startingOffset + stackHeight, this._holder);\n      } else if (item.isFixed && top < item.top + item.height) {\n        item.unstick();\n      }\n    });\n  }\n\n  /**\n   * Like the Contacts app on iPhone, as new headers come into view, they \"push\"\n   * out the old header and then become stuck at the top until its section has\n   * been scrolled through.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processPush(scrollTop) {\n    const top = scrollTop + this._overlap;\n\n    this._orderedItems.forEach((item) => {\n      // Stick (position fixed).\n      if (!item.isFixed && top >= item.top && top < item.bottom) {\n        item.stick(this._startingOffset, this._holder);\n\n      // Affix. Item has reached the end of its view-length, stick it to the bottom.\n      } else if (!item.isAtBottom && top >= item.bottom) {\n        item.stickToBottom(item.bottom);\n\n      // Above the position where the sticky element should be position fixed, so unstick it.\n      } else if (item.isFixed && top < item.top) {\n        item.unstick();\n      }\n\n      this._itemPositionCouldChange(item, top);\n    });\n  }\n\n  /**\n   * Sort items by their position on the page.\n   * @return {StickyItem[]} Sorted array of StickyItems.\n   */\n  _sortItemsByOffset() {\n    return Array.from(this.items.values()).sort((a, b) => a.top > b.top);\n  }\n\n  /**\n   * Add up the heights of all the currrently \"stacked\" sticky items.\n   * @return {number}\n   */\n  _getStackHeight() {\n    return this._orderedItems.reduce((h, i) => (i.isFixed ? h + i.height : h), 0);\n  }\n\n  /**\n   * When the sticky-element's position is soon going to change, promote it to a\n   * new layer so that the browser does not have to paint it on every scroll.\n   * Having the sticky-element layer promoted all the time is inefficient and greedy.\n   * @param {StickyItem} item Item to check.\n   * @param {number} top Current top position (with any overlap).\n   */\n  _itemPositionCouldChange(item, top) {\n    const isInRange = withinRange(top, item.top, item.bottom, StickyHeaders.PROMOTION_RANGE);\n    if (!item.isPromoted && isInRange) {\n      item.layerPromote();\n    } else if (item.isPromoted && !isInRange) {\n      item.layerDemote();\n    }\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   */\n  _cacheStyles() {\n    this._overlap = this.uiOverlap;\n    this._startingOffset = this.uiOffset;\n    this._cacheItemValues();\n  }\n\n  /**\n   * Cache values related to sticky items.\n   */\n  _cacheItemValues() {\n    this._orderedItems = this._sortItemsByOffset();\n\n    if (this.mode === StickyHeaders.Mode.PUSH) {\n      this._saveBottomPositionForItems();\n    }\n  }\n\n  /**\n   * Determine the page offset at which each item should become position absolute.\n   */\n  _saveBottomPositionForItems() {\n    this._orderedItems.forEach((item, i, array) => {\n      const next = array[i + 1];\n      item.bottom = (next && next.top - item.height) || StickyHeaders.LAST_ITEM_BOTTOM;\n    });\n  }\n\n  /**\n   * Re-cache element positions and reposition all sticky headers.\n   */\n  update() {\n    this.items.forEach((item) => {\n      item.unstick();\n    });\n\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    this._cacheStyles();\n\n    this.process();\n  }\n\n  /**\n   * The amount that the ui overlaps the top of the page. A sticky navigation,\n   * for example, would cause an overlap equal to its height.\n   * @return {number}\n   */\n  get uiOverlap() {\n    if (this._customOverlap) {\n      return this._customOverlap();\n    }\n\n    return 0;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._customOverlap = fn;\n    this.update();\n  }\n\n  /**\n  * Where to start positioning new sticky items. By default it's the same as\n  * the ui overlap, but can be customized.\n  * @return {number}\n  */\n  get uiOffset() {\n    if (this._customOffset) {\n      return this._customOffset();\n    }\n\n    return this.uiOverlap;\n  }\n\n  /**\n   * Define a custom getter to determine offset.\n   * @param {function():number} fn\n   */\n  set uiOffset(fn) {\n    this._customOffset = fn;\n  }\n\n  /**\n   * The location of sticky elements to be placed in the DOM.\n   * @return {?Element}\n   */\n  get stickyHolder() {\n    return this._holder;\n  }\n\n  /**\n   * Set the location of sticky elements to be placed in the DOM.\n   * @param {?Element} element Element which sticky items will be appended to.\n   */\n  set stickyHolder(element) {\n    this._holder = isElement(element) ? element : null;\n  }\n\n  /**\n   * Retrieve the current mode of StickyHeaders.\n   * @return {StickyHeaders.Mode}\n   */\n  get mode() {\n    return this._mode;\n  }\n\n  /**\n   * Change how the service treats multiple sticky items.\n   * @param {StickyHeaders.Mode} mode A mode.\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n\n  /**\n   * Remove element references and event listeners.\n   */\n  dispose() {\n    this.items.forEach((item, element) => {\n      this.remove(element);\n    });\n\n    this._orderedItems.length = 0;\n  }\n}\n\nStickyHeaders.PROMOTION_RANGE = 200;\nStickyHeaders.LAST_ITEM_BOTTOM = Infinity;\n\nStickyHeaders.Mode = {\n  PUSH: 1,\n  STACK: 2,\n};\n\nStickyHeaders.StickyItem = StickyItem;\n\nexport default StickyHeaders;\n"],"names":["applyCss","element","css","keys","forEach","property","style","isElement","thing","nodeType","withinRange","value","min","max","threshold","StickyItem","isFixed","isAtBottom","isPromoted","_wrapStickyElement","update","wrapper","document","createElement","className","Classes","WRAPPER","parentNode","insertBefore","this","INITIAL_POSITION","classList","add","IS_AT_TOP","appendChild","_unwrapStickyElement","container","removeChild","rect","getBoundingClientRect","top","window","pageYOffset","height","Math","round","stick","stackHeight","parent","position","IS_FIXED","remove","IS_AT_BOTTOM","unstick","stickToBottom","placement","body","layerPromote","willChange","transform","layerDemote","dispose","StickyHeaders","items","Map","_orderedItems","_scrollId","_resizeId","_overlap","_startingOffset","_holder","_customOverlap","_customOffset","_mode","Mode","PUSH","Array","isArray","TypeError","_this","has","set","_cacheItemValues","OdoWindowEvents","onResize","bind","OdoScrollAnimation","process","_cacheStyles","get","delete","size","scrollTop","mode","STACK","_processStack","_processPush","item","_this2","_getStackHeight","bottom","_this3","_itemPositionCouldChange","_sortItemsByOffset","from","values","sort","a","b","reduce","h","i","isInRange","PROMOTION_RANGE","uiOverlap","uiOffset","_saveBottomPositionForItems","array","next","LAST_ITEM_BOTTOM","length","fn","Infinity"],"mappings":"8WAMA,SAASA,EAASC,EAASC,UAClBC,KAAKD,GAAKE,QAAQ,SAACC,KAChBC,MAAMD,GAAYH,EAAIG,KCClC,SAASE,EAAUC,UACVA,GAA4B,IAAnBA,EAAMC,SAGxB,SAASC,EAAYC,EAAOC,EAAKC,EAAKC,UAC7BH,GAASC,EAAME,GAAaH,GAASE,EAAMC,obDF9CC,wBAMQd,kBAKLA,QAAUA,OAMVe,SAAU,OAMVC,YAAa,OAMbC,YAAa,OAEbC,0BACAC,4BAQPD,mCACOE,QAAUC,SAASC,cAAc,YACjCF,QAAQG,UAAYT,EAAWU,QAAQC,aACvCzB,QAAQ0B,WAAWC,aAAaC,KAAKR,QAASQ,KAAK5B,WAE/C4B,KAAK5B,kBACFc,EAAWe,wBACb,MACH,OACC,QACC,gBACG,gBAGP7B,QAAQ8B,UAAUC,IAAIjB,EAAWU,QAAQQ,gBACzCZ,QAAQa,YAAYL,KAAK5B,sBAOhCkC,oCACQC,EAAYP,KAAKR,QAAQM,aACrBO,YAAYL,KAAK5B,WACjBoC,YAAYR,KAAKR,sBAM7BD,sBACQkB,EAAOT,KAAK5B,QAAQsC,6BACrBC,IAAMF,EAAKE,IAAMC,OAAOC,iBACxBC,OAASC,KAAKC,MAAMP,EAAKK,qBAQhCG,eAAMC,EAAaC,QACZ3B,QAAQf,MAAMqC,OAASd,KAAKc,OAAS,UACrC1C,QAAQK,MAAM2C,SAAW,aACzBhD,QAAQK,MAAMkC,IAAMO,EAAc,UAClC9C,QAAQ8B,UAAUC,IAAIjB,EAAWU,QAAQyB,eACzCjD,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQ2B,mBAC5CnD,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQQ,WAE7Ce,KACKd,YAAYL,KAAK5B,cAGrBgB,YAAa,OACbD,SAAU,eAMjBqC,wBACOhC,QAAQf,MAAMqC,OAAS,QACvB1C,QAAQK,MAAM2C,SAAWlC,EAAWe,sBACpC7B,QAAQK,MAAMkC,IAAM,QACpBvC,QAAQ8B,UAAUC,IAAIjB,EAAWU,QAAQQ,gBACzChC,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQyB,eAC5CjD,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQ2B,cAE7CvB,KAAK5B,QAAQ0B,aAAeE,KAAKR,cAC9BA,QAAQa,YAAYL,KAAK5B,cAG3Be,SAAU,OACVC,YAAa,eAGpBqC,uBAAcC,QACPtD,QAAQK,MAAM2C,SAAW,gBACzBhD,QAAQK,MAAMkC,IAAMe,EAAY,UAChCtD,QAAQ8B,UAAUC,IAAIjB,EAAWU,QAAQ2B,mBACzCnD,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQyB,eAC5CjD,QAAQ8B,UAAUoB,OAAOpC,EAAWU,QAAQQ,oBAIxCuB,KAAKtB,YAAYL,KAAK5B,cAE1Be,SAAU,OACVC,YAAa,eAMpBwC,6BACOxD,QAAQK,MAAMoD,WAAa,gBAC3BzD,QAAQK,MAAMqD,UAAY,qBAC1BzC,YAAa,eAMpB0C,4BACO3D,QAAQK,MAAMoD,WAAa,QAC3BzD,QAAQK,MAAMqD,UAAY,QAC1BzC,YAAa,eAMpB2C,wBACOR,eACAlB,yBAEIN,KAAK5B,kBACF,UACF,OACH,QACC,SACC,YACG,cACE,aACD,UAGRA,QAAU,UACVoB,QAAU,WAInBN,EAAWe,iBAAmB,WAE9Bf,EAAWU,cACH,mCACG,4CACC,qBACC,yBACG,oBC/KVqC,yCAUGC,MAAQ,IAAIC,SAMZC,sBAMAC,UAAY,UAOZC,UAAY,UAOZC,SAAW,OAOXC,gBAAkB,OAOlBC,QAAU,UAOVC,eAAiB,UAOjBC,cAAgB,UAOhBC,MAAQX,EAAcY,KAAKC,wBASlC3C,aAAI/B,qBACe2E,MAAMC,QAAQ5E,GAAWA,GAAWA,IAE5CG,QAAQ,SAACH,OACXM,EAAUN,SACP,IAAI6E,sDAAsD7E,OAI7D8E,EAAKhB,MAAMiB,IAAI/E,MACb8D,MAAMkB,IAAIhF,EAAS,IAAIc,EAAWd,MAKvC4B,KAAKqC,eACFgB,yBAEAf,UAAYgB,EAAgBC,SAASvD,KAAKT,OAAOiE,KAAKxD,YACtDqC,UAAYoB,EAAmBtD,IAAIH,KAAK0D,QAAQF,KAAKxD,YACrD2D,qBAGFD,UAEEtF,eAOTkD,gBAAOlD,GACD4B,KAAKkC,MAAMiB,IAAI/E,UACZ8D,MAAM0B,IAAIxF,GAAS4D,eACnBE,MAAM2B,OAAOzF,GAGM,IAApB4B,KAAKkC,MAAM4B,SACMxC,OAAOtB,KAAKqC,aACff,OAAOtB,KAAKsC,gBACvBD,UAAY,UACZC,UAAY,oBASvBoB,uBAAQK,yDAAYnD,OAAOC,YACrBb,KAAKgE,OAAS/B,EAAcY,KAAKoB,WAC9BC,cAAcH,QAEdI,aAAaJ,gBAStBG,uBAAcH,mBACP3B,cAAc7D,QAAQ,SAAC6F,OAEpBlD,EAAcmD,EAAKC,kBACnB3D,EAAMoD,EAAYM,EAAK9B,SAAWrB,GAEnCkD,EAAKjF,SAAWwB,GAAOyD,EAAKzD,MAC1BM,MAAMoD,EAAK7B,gBAAkBtB,EAAamD,EAAK5B,SAC3C2B,EAAKjF,SAAWwB,EAAMyD,EAAKzD,IAAMyD,EAAKtD,UAC1CU,yBAWX2C,sBAAaJ,cACLpD,EAAMoD,EAAY/D,KAAKuC,cAExBH,cAAc7D,QAAQ,SAAC6F,IAErBA,EAAKjF,SAAWwB,GAAOyD,EAAKzD,KAAOA,EAAMyD,EAAKG,SAC5CtD,MAAMuD,EAAKhC,gBAAiBgC,EAAK/B,UAG5B2B,EAAKhF,YAAcuB,GAAOyD,EAAKG,SACpC9C,cAAc2C,EAAKG,QAGfH,EAAKjF,SAAWwB,EAAMyD,EAAKzD,OAC/Ba,YAGFiD,yBAAyBL,EAAMzD,kBAQxC+D,qCACS3B,MAAM4B,KAAK3E,KAAKkC,MAAM0C,UAAUC,KAAK,SAACC,EAAGC,UAAMD,EAAEnE,IAAMoE,EAAEpE,mBAOlE2D,kCACStE,KAAKoC,cAAc4C,OAAO,SAACC,EAAGC,UAAOA,EAAE/F,QAAU8F,EAAIC,EAAEpE,OAASmE,GAAI,gBAU7ER,kCAAyBL,EAAMzD,OACvBwE,EAAYtG,EAAY8B,EAAKyD,EAAKzD,IAAKyD,EAAKG,OAAQtC,EAAcmD,kBACnEhB,EAAK/E,YAAc8F,IACjBvD,eACIwC,EAAK/E,aAAe8F,KACxBpD,2BAOT4B,6BACOpB,SAAWvC,KAAKqF,eAChB7C,gBAAkBxC,KAAKsF,cACvBjC,gCAMPA,iCACOjB,cAAgBpC,KAAK0E,qBAEtB1E,KAAKgE,OAAS/B,EAAcY,KAAKC,WAC9ByC,2CAOTA,4CACOnD,cAAc7D,QAAQ,SAAC6F,EAAMc,EAAGM,OAC7BC,EAAOD,EAAMN,EAAI,KAClBX,OAAUkB,GAAQA,EAAK9E,IAAMyD,EAAKtD,QAAWmB,EAAcyD,gCAOpEnG,uBACO2C,MAAM3D,QAAQ,SAAC6F,KACb5C,iBAGFU,MAAM3D,QAAQ,SAAC6F,KACb7E,gBAGFoE,oBAEAD,uBAiFP1B,mCACOE,MAAM3D,QAAQ,SAAC6F,EAAMhG,KACnBkD,OAAOlD,UAGTgE,cAAcuD,OAAS,+CA7ExB3F,KAAK0C,eACA1C,KAAK0C,iBAGP,gBAOKkD,QACPlD,eAAiBkD,OACjBrG,iDASDS,KAAK2C,cACA3C,KAAK2C,gBAGP3C,KAAKqF,wBAODO,QACNjD,cAAgBiD,8CAQd5F,KAAKyC,sBAOGrE,QACVqE,QAAU/D,EAAUN,GAAWA,EAAU,yCAQvC4B,KAAK4C,oBAOLoB,QACFpB,MAAQoB,kBAejB/B,EAAcmD,gBAAkB,IAChCnD,EAAcyD,iBAAmBG,EAAAA,EAEjC5D,EAAcY,WACN,QACC,GAGTZ,EAAc/C,WAAaA"}