{"version":3,"file":"odo-sticky-headers.min.js","sources":["../src/sticky-item.js","../src/sticky-headers.js"],"sourcesContent":["/**\n * @fileoverview This class describes a sticky header element. It caches the\n * offsets for the element and has methods to stick, affix, and unstick the\n * sticky element.\n */\n\nfunction applyCss(element, css) {\n  Object.keys(css).forEach((property) => {\n    element.style[property] = css[property];\n  });\n}\n\nclass StickyItem {\n  /**\n   * Create a new sticky item.\n   * @param {Element} element Element to stick.\n   * @constructor\n   */\n  constructor(element) {\n    /**\n     * Main sticky element.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the element is position:fixed.\n     * @type {boolean}\n     */\n    this.isFixed = false;\n\n    /**\n     * Whether the element is affixed to the bottom.\n     * @type {boolean}\n     */\n    this.isAtBottom = false;\n\n    /**\n     * Whether the element is layer promoted.\n     * @type {boolean}\n     */\n    this.isPromoted = false;\n\n    this._wrapStickyElement();\n    this.update();\n  }\n\n  /**\n   * Initialize by wrapping in an element to take up space while the main\n   * element is positin:fixed.\n   * @private\n   */\n  _wrapStickyElement() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = StickyItem.Classes.WRAPPER;\n    this.element.parentNode.insertBefore(this.wrapper, this.element);\n\n    applyCss(this.element, {\n      position: StickyItem.INITIAL_POSITION,\n      zIndex: 1,\n      top: 0,\n      left: 0,\n      width: '100%',\n      overflow: 'hidden',\n    });\n\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.wrapper.appendChild(this.element);\n  }\n\n  /**\n   * Remove the placeholder element added when this sticky item is initialized.\n   * @private\n   */\n  _unwrapStickyElement() {\n    const container = this.wrapper.parentNode;\n    container.appendChild(this.element);\n    container.removeChild(this.wrapper);\n  }\n\n  /**\n   * Save the dimensions of the sticky item.\n   */\n  update() {\n    const rect = this.element.getBoundingClientRect();\n    this.top = rect.top + window.pageYOffset;\n    this.height = Math.round(rect.height);\n  }\n\n  /**\n   * Stick the sticky item to a specific value.\n   * @param {number} stackHeight The current stack height of sticky elements.\n   * @param {Element} [parent] Optional element to put the sticky within.\n   */\n  stick(stackHeight, parent) {\n    this.wrapper.style.height = this.height + 'px';\n    this.element.style.position = 'fixed';\n    this.element.style.top = stackHeight + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    if (parent) {\n      parent.appendChild(this.element);\n    }\n\n    this.isAtBottom = false;\n    this.isFixed = true;\n  }\n\n  /**\n   * Remove stickiness of sticky item.\n   */\n  unstick() {\n    this.wrapper.style.height = '';\n    this.element.style.position = StickyItem.INITIAL_POSITION;\n    this.element.style.top = '';\n    this.element.classList.add(StickyItem.Classes.IS_AT_TOP);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_BOTTOM);\n\n    if (this.element.parentNode !== this.wrapper) {\n      this.wrapper.appendChild(this.element);\n    }\n\n    this.isFixed = false;\n    this.isAtBottom = false;\n  }\n\n  stickToBottom(placement) {\n    this.element.style.position = 'absolute';\n    this.element.style.top = placement + 'px';\n    this.element.classList.add(StickyItem.Classes.IS_AT_BOTTOM);\n    this.element.classList.remove(StickyItem.Classes.IS_FIXED);\n    this.element.classList.remove(StickyItem.Classes.IS_AT_TOP);\n\n    // When the sticky is position absolute, it has to be absolute relative\n    // to the page, not another fixed-position element.\n    document.body.appendChild(this.element);\n\n    this.isFixed = false;\n    this.isAtBottom = true;\n  }\n\n  /**\n   * Add styles which will put the affix-element in a new layer.\n   */\n  layerPromote() {\n    this.element.style.willChange = 'position';\n    this.element.style.transform = 'translateZ(0)';\n    this.isPromoted = true;\n  }\n\n  /**\n   * Remove styles which cause layer promotion.\n   */\n  layerDemote() {\n    this.element.style.willChange = '';\n    this.element.style.transform = '';\n    this.isPromoted = false;\n  }\n\n  /**\n   * Get rid of this sticky item instance.\n   */\n  dispose() {\n    this.unstick();\n    this._unwrapStickyElement();\n\n    applyCss(this.element, {\n      position: '',\n      zIndex: '',\n      top: '',\n      left: '',\n      width: '',\n      overflow: '',\n      willChange: '',\n      transform: '',\n    });\n\n    this.element = null;\n    this.wrapper = null;\n  }\n}\n\nStickyItem.INITIAL_POSITION = 'relative';\n\nStickyItem.Classes = {\n  BASE: 'odo-sticky-headers__item',\n  WRAPPER: 'odo-sticky-headers__item-wrapper',\n  IS_FIXED: 'is-fixed',\n  IS_AT_TOP: 'is-at-top',\n  IS_AT_BOTTOM: 'is-at-bottom',\n};\n\nexport default StickyItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport OdoScrollAnimation from '@odopod/odo-scroll-animation';\nimport StickyItem from './sticky-item';\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nfunction withinRange(value, min, max, threshold) {\n  return value >= min - threshold && value <= max + threshold;\n}\n\nclass StickyHeaders {\n  /**\n   * Create a new Sticky instance.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Mapping of elements to StickyItem instances.\n     * @type {Map.<Element, StickyItem>}\n     */\n    this.items = new Map();\n\n    /**\n     * Items sorted in order they appear on the page.\n     * @type {Array}\n     */\n    this._orderedItems = [];\n\n    /**\n     * Scroll event listener id.\n     * @type {?string}\n     */\n    this._scrollId = null;\n\n    /**\n     * Window resize id.\n     * @type {?string}\n     * @private\n     */\n    this._resizeId = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page.\n     * @type {number}\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * Where to start positioning new sticky items.\n     * @type {number}\n     * @private\n     */\n    this._startingOffset = 0;\n\n    /**\n     * Element which holds sticky elements.\n     * @type {Element}\n     * @private\n     */\n    this._holder = null;\n\n    /**\n     * The amount that the ui overlaps the top of the page. A sticky navigation,\n     * for example, would cause an overlap equal to its height.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOverlap = () => 0;\n\n    /**\n     * Where to start positioning new sticky items. By default it's the same as\n     * the ui overlap, but can be customized.\n     * @type {function():number}\n     * @private\n     */\n    this._getUiOffset = this._getUiOverlap;\n\n    /**\n     * Which mode to handle sticky headers.\n     * @type {StickyHeaders.Mode}\n     * @private\n     */\n    this._mode = StickyHeaders.Mode.PUSH;\n  }\n\n  /**\n   * Track a sticky item.\n   * @param {Element[]|Element} element An array of elements or a single\n   *    element which will become sticky.\n   * @return {Element} The key to the items map for this new StickyItem.\n   */\n  add(element) {\n    const elements = Array.isArray(element) ? element : [element];\n\n    elements.forEach((element) => {\n      if (!isElement(element)) {\n        throw new TypeError(`StickyHeaders requires an element. Got: \"${element}\"`);\n      }\n\n      // Avoid adding duplicate items.\n      if (!this.items.has(element)) {\n        this.items.set(element, new StickyItem(element));\n      }\n    });\n\n    // Add event listeners if they aren't already added.\n    if (this._scrollId) {\n      this._cacheItemValues();\n    } else {\n      this._resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n      this._scrollId = OdoScrollAnimation.add(this.process.bind(this));\n      this._cacheStyles();\n    }\n\n    this.process();\n\n    return element;\n  }\n\n  /**\n   * Stop tracking a sticky item.\n   * @param {Element} element Element which was added to the sticky headers.\n   */\n  remove(element) {\n    if (this.items.has(element)) {\n      this.items.get(element).dispose();\n      this.items.delete(element);\n\n      // Remove event listeners when there aren't any instances to watch.\n      if (this.items.size === 0) {\n        OdoScrollAnimation.remove(this._scrollId);\n        OdoWindowEvents.remove(this._resizeId);\n        this._scrollId = null;\n        this._resizeId = null;\n      }\n    }\n  }\n\n  /**\n   * On every scroll event, push or stack sticky headers, depending on the mode.\n   * @param {number} [scrollTop=window.pageYoffset] Page scroll position.\n   */\n  process(scrollTop = window.pageYOffset) {\n    if (this.mode === StickyHeaders.Mode.STACK) {\n      this._processStack(scrollTop);\n    } else {\n      this._processPush(scrollTop);\n    }\n  }\n\n  /**\n   * Depending on the position of the viewport, make sticky headers position\n   * fixed. If multiple sticky headers are \"fixed\", they will stack on each other.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processStack(scrollTop) {\n    this._orderedItems.forEach((item) => {\n      // Because the stack height can change inside the loop, it must be updated.\n      const stackHeight = this._getStackHeight();\n      const top = scrollTop + this._overlap + stackHeight;\n\n      if (!item.isFixed && top >= item.top) {\n        item.stick(this._startingOffset + stackHeight, this._holder);\n      } else if (item.isFixed && top < item.top + item.height) {\n        item.unstick();\n      }\n    });\n  }\n\n  /**\n   * Like the Contacts app on iPhone, as new headers come into view, they \"push\"\n   * out the old header and then become stuck at the top until its section has\n   * been scrolled through.\n   * @param {number} scrollTop Page scroll position.\n   */\n  _processPush(scrollTop) {\n    const top = scrollTop + this._overlap;\n\n    this._orderedItems.forEach((item) => {\n      // Stick (position fixed).\n      if (!item.isFixed && top >= item.top && top < item.bottom) {\n        item.stick(this._startingOffset, this._holder);\n\n      // Affix. Item has reached the end of its view-length, stick it to the bottom.\n      } else if (!item.isAtBottom && top >= item.bottom) {\n        item.stickToBottom(item.bottom);\n\n      // Above the position where the sticky element should be position fixed, so unstick it.\n      } else if (item.isFixed && top < item.top) {\n        item.unstick();\n      }\n\n      this._itemPositionCouldChange(item, top);\n    });\n  }\n\n  /**\n   * Sort items by their position on the page.\n   * @return {StickyItem[]} Sorted array of StickyItems.\n   */\n  _sortItemsByOffset() {\n    return Array.from(this.items.values()).sort((a, b) => a.top - b.top);\n  }\n\n  /**\n   * Add up the heights of all the currrently \"stacked\" sticky items.\n   * @return {number}\n   */\n  _getStackHeight() {\n    return this._orderedItems.reduce((h, i) => (i.isFixed ? h + i.height : h), 0);\n  }\n\n  /**\n   * When the sticky-element's position is soon going to change, promote it to a\n   * new layer so that the browser does not have to paint it on every scroll.\n   * Having the sticky-element layer promoted all the time is inefficient and greedy.\n   * @param {StickyItem} item Item to check.\n   * @param {number} top Current top position (with any overlap).\n   */\n  _itemPositionCouldChange(item, top) {\n    const isInRange = withinRange(top, item.top, item.bottom, StickyHeaders.PROMOTION_RANGE);\n    if (!item.isPromoted && isInRange) {\n      item.layerPromote();\n    } else if (item.isPromoted && !isInRange) {\n      item.layerDemote();\n    }\n  }\n\n  /**\n   * Cache values so they don't need to be queried on scroll.\n   */\n  _cacheStyles() {\n    this._overlap = this._getUiOverlap();\n    this._startingOffset = this._getUiOffset();\n    this._cacheItemValues();\n  }\n\n  /**\n   * Cache values related to sticky items.\n   */\n  _cacheItemValues() {\n    this._orderedItems = this._sortItemsByOffset();\n\n    if (this.mode === StickyHeaders.Mode.PUSH) {\n      this._saveBottomPositionForItems();\n    }\n  }\n\n  /**\n   * Determine the page offset at which each item should become position absolute.\n   */\n  _saveBottomPositionForItems() {\n    this._orderedItems.forEach((item, i, array) => {\n      const next = array[i + 1];\n      item.bottom = (next && next.top - item.height) || StickyHeaders.LAST_ITEM_BOTTOM;\n    });\n  }\n\n  /**\n   * Re-cache element positions and reposition all sticky headers.\n   */\n  update() {\n    this.items.forEach((item) => {\n      item.unstick();\n    });\n\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    this._cacheStyles();\n\n    this.process();\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n   * @return {function():number}\n   */\n  get uiOverlap() {\n    return this._getUiOverlap;\n  }\n\n  /**\n  * Define a custom getter to determine overlap.\n  * @param {function():number} fn\n  */\n  set uiOverlap(fn) {\n    this._getUiOverlap = fn;\n    this.update();\n  }\n\n  /**\n   * TODO(glen): remove getter/setter.\n  * @return {function():number}\n  */\n  get uiOffset() {\n    return this._getUiOffset;\n  }\n\n  /**\n   * Define a custom getter to determine offset.\n   * @param {function():number} fn\n   */\n  set uiOffset(fn) {\n    this._getUiOffset = fn;\n  }\n\n  /**\n   * The location of sticky elements to be placed in the DOM.\n   * @return {?Element}\n   */\n  get stickyHolder() {\n    return this._holder;\n  }\n\n  /**\n   * Set the location of sticky elements to be placed in the DOM.\n   * @param {?Element} element Element which sticky items will be appended to.\n   */\n  set stickyHolder(element) {\n    this._holder = isElement(element) ? element : null;\n  }\n\n  /**\n   * Retrieve the current mode of StickyHeaders.\n   * @return {StickyHeaders.Mode}\n   */\n  get mode() {\n    return this._mode;\n  }\n\n  /**\n   * Change how the service treats multiple sticky items.\n   * @param {StickyHeaders.Mode} mode A mode.\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n\n  /**\n   * Remove element references and event listeners.\n   */\n  dispose() {\n    this.items.forEach((item, element) => {\n      this.remove(element);\n    });\n\n    this._orderedItems.length = 0;\n  }\n}\n\nStickyHeaders.PROMOTION_RANGE = 200;\nStickyHeaders.LAST_ITEM_BOTTOM = Infinity;\n\nStickyHeaders.Mode = {\n  PUSH: 1,\n  STACK: 2,\n};\n\nStickyHeaders.StickyItem = StickyItem;\n\nexport default StickyHeaders;\n"],"names":["applyCss","element","css","keys","forEach","property","style","StickyItem","isFixed","isAtBottom","isPromoted","_wrapStickyElement","update","wrapper","document","createElement","className","Classes","WRAPPER","parentNode","insertBefore","this","INITIAL_POSITION","classList","add","IS_AT_TOP","appendChild","_unwrapStickyElement","container","removeChild","rect","getBoundingClientRect","top","window","pageYOffset","height","Math","round","stick","stackHeight","parent","position","IS_FIXED","remove","IS_AT_BOTTOM","unstick","stickToBottom","placement","body","layerPromote","willChange","transform","layerDemote","dispose","isElement","thing","nodeType","StickyHeaders","items","Map","_orderedItems","_scrollId","_resizeId","_overlap","_startingOffset","_holder","_getUiOverlap","_getUiOffset","_mode","Mode","PUSH","Array","isArray","TypeError","_this","has","set","_cacheItemValues","OdoWindowEvents","onResize","bind","OdoScrollAnimation","process","_cacheStyles","get","delete","size","scrollTop","mode","STACK","_processStack","_processPush","item","_this2","_getStackHeight","bottom","_this3","_itemPositionCouldChange","_sortItemsByOffset","from","values","sort","a","b","reduce","h","i","value","min","max","threshold","isInRange","PROMOTION_RANGE","_saveBottomPositionForItems","array","next","LAST_ITEM_BOTTOM","length","fn","Infinity"],"mappings":"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"}