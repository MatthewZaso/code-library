{"version":3,"file":"odo-viewport.js","sources":["../src/viewport-item.js","../src/viewport.js"],"sourcesContent":["class ViewportItem {\n  /**\n   * A viewport item represents an element being watched by the Viewport component.\n   * @param {Object} options Viewport item options.\n   * @param {Viewport} parent A reference to the viewport.\n   * @constructor\n   */\n  constructor(options, parent) {\n    this.parent = parent;\n    this.id = Math.random().toString(36).substring(7);\n    this.triggered = false;\n    this.threshold = 200;\n    this.isThresholdPercentage = false;\n\n    // Override defaults with options.\n    Object.assign(this, options);\n\n    // The whole point is to have a callback function. Don't do anything if it's not given.\n    if (typeof this.enter !== 'function') {\n      throw new TypeError('Viewport.add :: No `enter` function provided in Viewport options.');\n    }\n\n    this.parseThreshold();\n\n    this.hasExitCallback = typeof this.exit === 'function';\n\n    // Cache element's offsets and dimensions.\n    this.update();\n  }\n\n  // Use getter for `this.offset` so that the tests don't have to assign\n  // a threshold and an offset.\n  get offset() {\n    return this.isThresholdPercentage ?\n      this.threshold * this.parent.viewportHeight :\n      this.threshold;\n  }\n\n  /**\n   * Update offset and size values.\n   */\n  update() {\n    const box = this.element.getBoundingClientRect();\n    this.height = this.element.offsetHeight;\n    this.width = this.element.offsetWidth;\n    this.top = box.top + window.pageYOffset;\n    this.left = box.left + window.pageXOffset;\n    this.right = this.width + this.left;\n    this.bottom = this.height + this.top;\n  }\n\n  /**\n   * Determine the threshold setting.\n   */\n  parseThreshold() {\n    const value = this.threshold;\n    this.threshold = parseFloat(value);\n\n    // Threshold can be a percentage. Parse it.\n    if ((typeof value === 'string' && value.indexOf('%') > -1)) {\n      this.isThresholdPercentage = true;\n      this.threshold = this.threshold / 100;\n    } else if (this.threshold < 1 && this.threshold > 0) {\n      this.isThresholdPercentage = true;\n    }\n  }\n\n  /**\n   * Nullify references so they're garbage collected.\n   */\n  dispose() {\n    this.element = null;\n    this.enter = null;\n    this.exit = null;\n    this.parent = null;\n  }\n}\n\nexport default ViewportItem;\n","import OdoWindowEvents from '@odopod/odo-window-events';\nimport ViewportItem from './viewport-item';\n\nlet instance = null;\n\nfunction inRange(value, min, max) {\n  return min <= value && value <= max;\n}\n\nclass Viewport {\n  /**\n   * Viewport singleton.\n   * @constructor\n   */\n  constructor() {\n    this.addId = null;\n    this.hasActiveHandlers = false;\n    this.items = new Map();\n\n    // Assume there is no horizontal scrollbar. documentElement.clientHeight\n    // is incorrect on iOS 8 because it includes toolbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n    this.viewportTop = 0;\n\n    // What's nice here is that rAF won't execute until the user is on this tab,\n    // so if they open the page in a new tab which they aren't looking at,\n    // this will execute when they come back to that tab.\n    requestAnimationFrame(this.handleScroll.bind(this));\n  }\n\n  get viewportBottom() {\n    return this.viewportTop + this.viewportHeight;\n  }\n\n  /**\n   * Listen for scroll and resize.\n   */\n  bindEvents() {\n    // Listen for global debounced resize.\n    this.resizeId = OdoWindowEvents.onResize(this.update.bind(this));\n\n    // Throttle scrolling because it doesn't need to be super accurate.\n    this.scrollId = OdoWindowEvents.onFastScroll(this.handleScroll.bind(this));\n\n    this.hasActiveHandlers = true;\n  }\n\n  /**\n   * Remove event listeners when there are no longer any viewport items to watch.\n   */\n  unbindEvents() {\n    if (this.items.size === 0) {\n      OdoWindowEvents.remove(this.resizeId);\n      OdoWindowEvents.remove(this.scrollId);\n\n      this.hasActiveHandlers = false;\n    }\n  }\n\n  /**\n   * Watch another item.\n   * @param {Object} options Viewport item options.\n   * @return {string} The new item's id which is used to remove it.\n   */\n  add(options) {\n    const item = new ViewportItem(options, this);\n    this.items.set(item.id, item);\n\n    // Event handlers are removed if a callback is triggered and the\n    // watch list is empty. Because modules are instantiated asynchronously,\n    // another module could potentially add itself to the watch list when the events\n    // have been unbound.\n    // Check here if events have been unbound and bind them again if they have\n    if (!this.hasActiveHandlers) {\n      this.bindEvents();\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Update each item's width/height/top/left values and the viewport size.\n   */\n  saveDimensions() {\n    this.items.forEach((item) => {\n      item.update();\n    });\n\n    // Window width and height without scrollbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n\n    return this;\n  }\n\n  /**\n   * Throttled scroll event. Update the viewport top position and process items.\n   */\n  handleScroll() {\n    return this.setScrollTop().process();\n  }\n\n  /**\n   * Update offsets and process items.\n   */\n  update() {\n    return this.saveDimensions().process();\n  }\n\n  /**\n   * Notify the viewport item it has entered view.\n   * @param {ViewportItem} item item.\n   */\n  triggerEnter(item) {\n    item.enter.call(item.element, item);\n\n    if (item.hasExitCallback) {\n      item.triggered = true;\n\n      // If the exit property is not a function, the module no longer needs to\n      // watch it, so remove from list of viewport items.\n    } else {\n      Viewport.remove(item.id);\n\n      // If there are no more, unbind from scroll and resize events\n      this.unbindEvents();\n    }\n  }\n\n  /**\n   * Notify the viewport item it has exited view.\n   * @param {ViewportItem} item item.\n   */\n  triggerExit(item) {\n    item.exit.call(item.element, item);\n    item.triggered = false;\n  }\n\n  /**\n   * Save the new scroll top\n   */\n  setScrollTop() {\n    this.viewportTop = window.pageYOffset;\n    return this;\n  }\n\n  /**\n   * Process each viewport item to see if it is now in view (or out of view).\n   */\n  process() {\n    this.items.forEach(this._processItem, this);\n    this.addId = null;\n\n    return this;\n  }\n\n  /**\n   * Determine if enter or exit callbacks should be executed for a viewport item.\n   * @param {ViewportItem} item Item to test.\n   */\n  _processItem(item) {\n    const isVisible = this.isVisible(item);\n    const isInView = isVisible && this.isInViewport(item);\n\n    // Whether the item is not in the viewport and doesn't have an exit\n    // callback. In this case, the enter callback should be executed\n    // because the browser has already scrolled past the trigger point.\n    const isTopPastView = isVisible && !item.hasExitCallback && this.isTopPastViewport(item);\n\n    // If the enter callback hasn't been triggered and it's in the viewport,\n    // trigger the enter callback.\n    if (!item.triggered && (isInView || isTopPastView)) {\n      this.triggerEnter(item);\n      return;\n    }\n\n    // This viewport has already come into view once (viewport item has been\n    // triggered) and now the bottom is out of view.\n    if (!isInView && item.triggered && item.hasExitCallback &&\n      !this.isBottomInViewport(item)) {\n      this.triggerExit(item);\n    }\n  }\n\n  /**\n   * Whether a viewport item is considered to be in view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isInViewport(item) {\n    const isTopInView = this.isTopInViewport(item);\n\n    // If the item has not come into view, ignore checking to see if the bottom\n    // is in view because this can conflict with the top being in view when the\n    // offset is greater than the height of the watched element.\n    let isBottomInView;\n    if (item.offset >= 0) {\n      if (item.triggered) {\n        isBottomInView = this.isBottomInViewport(item);\n      } else {\n        isBottomInView = false;\n      }\n    } else {\n      // If the offset is negative, assume that it shouldn't wait until the top\n      // is in view before checking the bottom again.\n      isBottomInView = this.isBottomInViewport(item);\n    }\n\n    const isViewPastBottom = this.isViewportPastBottom(item);\n    const spanningViewport = !isTopInView && !isBottomInView && this.doesSpanViewport(item);\n\n    const isSideInView = this.isSideInViewport(item);\n\n    return (isTopInView || isBottomInView || spanningViewport) && !isViewPastBottom && isSideInView;\n  }\n\n  /**\n   * Determine whether a side of the viewport item is within the viewport. A side\n   * is also considered to be in view if the viewport item is wider than the viewport\n   * and its left and right sides are out of view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n  isSideInViewport(item) {\n    const isLeftInView = inRange(item.left, 0, this.viewportWidth);\n    const isRightInView = inRange(item.right, 0, this.viewportWidth);\n\n    // To span the viewport, it must:\n    // * Wider than the viewport.\n    // * Left side not in view.\n    // * left side less than zero.\n    // * Right side not in view.\n    // * Right side greater than window width.\n    const spansViewport = item.width >= this.viewportWidth && !isLeftInView && !isRightInView &&\n      item.left < 0 && item.right > this.viewportWidth;\n\n    return isLeftInView || isRightInView || spansViewport;\n  }\n\n  /**\n   * If an element is hidden (has a parent with display:none), getBoundingClientRect\n   * will return all zeros\n   * @param {ViewportItem} item item Item to test.\n   * @return {boolean}\n   */\n  isVisible(item) {\n    return !(item.width === 0 && item.height === 0);\n  }\n\n  isTopPastViewport(item) {\n    return this.viewportTop > item.top;\n  }\n\n  isViewportPastBottom(item) {\n    return this.viewportTop >= item.bottom;\n  }\n\n  isTopInViewport(item) {\n    const elementTop = item.top + item.offset;\n    return inRange(elementTop, this.viewportTop, this.viewportBottom);\n  }\n\n  isBottomInViewport(item) {\n    // Account for threshold only from the element top. Otherwise the element\n    // won't be \"out of view\" from the bottom until after the extra threshold.\n    return inRange(item.bottom, this.viewportTop, this.viewportBottom);\n  }\n\n  doesSpanViewport(item) {\n    const elementTop = item.top + item.offset;\n    const elementBottom = item.bottom;\n    return item.height >= this.viewportHeight &&\n      elementTop < this.viewportTop && elementBottom > this.viewportBottom;\n  }\n\n  /**\n   * Remove all viewport items and unbind events.\n   */\n  static flush() {\n    const instance = Viewport.getInstance();\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n      instance.addId = null;\n    }\n\n    instance.items.forEach((item, id) => {\n      Viewport.remove(id);\n    });\n\n    instance.items.clear();\n    instance.unbindEvents();\n  }\n\n  /**\n   * Add a viewport item to watch.\n   * @param {object|object[]} options Optional options object or array of\n   *     options objects to initialize.\n   * @param {Element} options.element Element to watch.\n   * @param {number|string} [options.threshold] Optional - either a number representing\n   *     the threshold offset (like 100), a float between zero and one representing\n   *     a percentage, or a string like '50%' for a percentage.\n   * @param {function} options.enter Callback when the element enters view.\n   * @param {function} [options.exit] Optional callback when the element exits view.\n   * @return {string|string[]} Viewport item id or array of item ids if\n   *     `options` is an array.\n   */\n  static add(options) {\n    const instance = Viewport.getInstance();\n\n    let id;\n    if (Array.isArray(options)) {\n      id = options.map(option => instance.add(option));\n    } else {\n      id = instance.add(options);\n    }\n\n    // Avoid adding multiple rAFs when it should really only be processed once.\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n    }\n\n    instance.addId = requestAnimationFrame(instance.process.bind(instance));\n\n    return id;\n  }\n\n  /**\n   * Remove a viewport item from the list of viewport items to watch.\n   * @param {string} id The id returned from adding the viewport item.\n   */\n  static remove(id) {\n    const instance = Viewport.getInstance();\n    if (instance.items.has(id)) {\n      instance.items.get(id).dispose();\n      instance.items.delete(id);\n    }\n  }\n\n  /**\n   * Tell the viewport instance that offsets need to be updated.\n   */\n  static update() {\n    Viewport.getInstance().update();\n  }\n\n  /**\n   * Retrieve the viewport instance.\n   * @return {Viewport}\n   */\n  static getInstance() {\n    if (!instance) {\n      instance = new Viewport();\n    }\n\n    return instance;\n  }\n}\n\nexport default Viewport;\n"],"names":["ViewportItem","options","parent","id","Math","random","toString","substring","triggered","threshold","isThresholdPercentage","assign","enter","TypeError","parseThreshold","hasExitCallback","exit","update","box","element","getBoundingClientRect","height","offsetHeight","width","offsetWidth","top","window","pageYOffset","left","pageXOffset","right","bottom","value","parseFloat","indexOf","dispose","viewportHeight","instance","inRange","min","max","Viewport","addId","hasActiveHandlers","items","Map","innerHeight","viewportWidth","document","documentElement","clientWidth","viewportTop","handleScroll","bind","bindEvents","resizeId","OdoWindowEvents","onResize","scrollId","onFastScroll","unbindEvents","size","remove","add","item","set","saveDimensions","forEach","setScrollTop","process","triggerEnter","call","triggerExit","_processItem","isVisible","isInView","isInViewport","isTopPastView","isTopPastViewport","isBottomInViewport","isTopInView","isTopInViewport","isBottomInView","offset","isViewPastBottom","isViewportPastBottom","spanningViewport","doesSpanViewport","isSideInView","isSideInViewport","isLeftInView","isRightInView","spansViewport","elementTop","viewportBottom","elementBottom","flush","getInstance","clear","Array","isArray","map","option","requestAnimationFrame","has","get","delete"],"mappings":"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"}